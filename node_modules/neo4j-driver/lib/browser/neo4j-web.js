(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.neo4j = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

module.exports = _arrayWithHoles;
},{}],2:[function(require,module,exports){
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }
}

module.exports = _arrayWithoutHoles;
},{}],3:[function(require,module,exports){
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

module.exports = _assertThisInitialized;
},{}],4:[function(require,module,exports){
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

module.exports = _asyncToGenerator;
},{}],5:[function(require,module,exports){
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

module.exports = _classCallCheck;
},{}],6:[function(require,module,exports){
var setPrototypeOf = require("./setPrototypeOf");

function isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (isNativeReflectConstruct()) {
    module.exports = _construct = Reflect.construct;
  } else {
    module.exports = _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

module.exports = _construct;
},{"./setPrototypeOf":20}],7:[function(require,module,exports){
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

module.exports = _createClass;
},{}],8:[function(require,module,exports){
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

module.exports = _defineProperty;
},{}],9:[function(require,module,exports){
var superPropBase = require("./superPropBase");

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    module.exports = _get = Reflect.get;
  } else {
    module.exports = _get = function _get(target, property, receiver) {
      var base = superPropBase(target, property);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

module.exports = _get;
},{"./superPropBase":22}],10:[function(require,module,exports){
function _getPrototypeOf(o) {
  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

module.exports = _getPrototypeOf;
},{}],11:[function(require,module,exports){
var setPrototypeOf = require("./setPrototypeOf");

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) setPrototypeOf(subClass, superClass);
}

module.exports = _inherits;
},{"./setPrototypeOf":20}],12:[function(require,module,exports){
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

module.exports = _interopRequireDefault;
},{}],13:[function(require,module,exports){
function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};

    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};

          if (desc.get || desc.set) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    }

    newObj["default"] = obj;
    return newObj;
  }
}

module.exports = _interopRequireWildcard;
},{}],14:[function(require,module,exports){
function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

module.exports = _isNativeFunction;
},{}],15:[function(require,module,exports){
function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

module.exports = _iterableToArray;
},{}],16:[function(require,module,exports){
function _iterableToArrayLimit(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

module.exports = _iterableToArrayLimit;
},{}],17:[function(require,module,exports){
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

module.exports = _nonIterableRest;
},{}],18:[function(require,module,exports){
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

module.exports = _nonIterableSpread;
},{}],19:[function(require,module,exports){
var _typeof = require("../helpers/typeof");

var assertThisInitialized = require("./assertThisInitialized");

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return assertThisInitialized(self);
}

module.exports = _possibleConstructorReturn;
},{"../helpers/typeof":24,"./assertThisInitialized":3}],20:[function(require,module,exports){
function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf;
},{}],21:[function(require,module,exports){
var arrayWithHoles = require("./arrayWithHoles");

var iterableToArrayLimit = require("./iterableToArrayLimit");

var nonIterableRest = require("./nonIterableRest");

function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest();
}

module.exports = _slicedToArray;
},{"./arrayWithHoles":1,"./iterableToArrayLimit":16,"./nonIterableRest":17}],22:[function(require,module,exports){
var getPrototypeOf = require("./getPrototypeOf");

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

module.exports = _superPropBase;
},{"./getPrototypeOf":10}],23:[function(require,module,exports){
var arrayWithoutHoles = require("./arrayWithoutHoles");

var iterableToArray = require("./iterableToArray");

var nonIterableSpread = require("./nonIterableSpread");

function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();
}

module.exports = _toConsumableArray;
},{"./arrayWithoutHoles":2,"./iterableToArray":15,"./nonIterableSpread":18}],24:[function(require,module,exports){
function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}

module.exports = _typeof;
},{}],25:[function(require,module,exports){
var getPrototypeOf = require("./getPrototypeOf");

var setPrototypeOf = require("./setPrototypeOf");

var isNativeFunction = require("./isNativeFunction");

var construct = require("./construct");

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  module.exports = _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return construct(Class, arguments, getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

module.exports = _wrapNativeSuper;
},{"./construct":6,"./getPrototypeOf":10,"./isNativeFunction":14,"./setPrototypeOf":20}],26:[function(require,module,exports){
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
  typeof module === "object" ? module.exports : {}
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}

},{}],27:[function(require,module,exports){
module.exports = require("regenerator-runtime");

},{"regenerator-runtime":26}],28:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("./internal/Observable");
exports.Observable = Observable_1.Observable;
var ConnectableObservable_1 = require("./internal/observable/ConnectableObservable");
exports.ConnectableObservable = ConnectableObservable_1.ConnectableObservable;
var groupBy_1 = require("./internal/operators/groupBy");
exports.GroupedObservable = groupBy_1.GroupedObservable;
var observable_1 = require("./internal/symbol/observable");
exports.observable = observable_1.observable;
var Subject_1 = require("./internal/Subject");
exports.Subject = Subject_1.Subject;
var BehaviorSubject_1 = require("./internal/BehaviorSubject");
exports.BehaviorSubject = BehaviorSubject_1.BehaviorSubject;
var ReplaySubject_1 = require("./internal/ReplaySubject");
exports.ReplaySubject = ReplaySubject_1.ReplaySubject;
var AsyncSubject_1 = require("./internal/AsyncSubject");
exports.AsyncSubject = AsyncSubject_1.AsyncSubject;
var asap_1 = require("./internal/scheduler/asap");
exports.asap = asap_1.asap;
exports.asapScheduler = asap_1.asapScheduler;
var async_1 = require("./internal/scheduler/async");
exports.async = async_1.async;
exports.asyncScheduler = async_1.asyncScheduler;
var queue_1 = require("./internal/scheduler/queue");
exports.queue = queue_1.queue;
exports.queueScheduler = queue_1.queueScheduler;
var animationFrame_1 = require("./internal/scheduler/animationFrame");
exports.animationFrame = animationFrame_1.animationFrame;
exports.animationFrameScheduler = animationFrame_1.animationFrameScheduler;
var VirtualTimeScheduler_1 = require("./internal/scheduler/VirtualTimeScheduler");
exports.VirtualTimeScheduler = VirtualTimeScheduler_1.VirtualTimeScheduler;
exports.VirtualAction = VirtualTimeScheduler_1.VirtualAction;
var Scheduler_1 = require("./internal/Scheduler");
exports.Scheduler = Scheduler_1.Scheduler;
var Subscription_1 = require("./internal/Subscription");
exports.Subscription = Subscription_1.Subscription;
var Subscriber_1 = require("./internal/Subscriber");
exports.Subscriber = Subscriber_1.Subscriber;
var Notification_1 = require("./internal/Notification");
exports.Notification = Notification_1.Notification;
exports.NotificationKind = Notification_1.NotificationKind;
var pipe_1 = require("./internal/util/pipe");
exports.pipe = pipe_1.pipe;
var noop_1 = require("./internal/util/noop");
exports.noop = noop_1.noop;
var identity_1 = require("./internal/util/identity");
exports.identity = identity_1.identity;
var isObservable_1 = require("./internal/util/isObservable");
exports.isObservable = isObservable_1.isObservable;
var ArgumentOutOfRangeError_1 = require("./internal/util/ArgumentOutOfRangeError");
exports.ArgumentOutOfRangeError = ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
var EmptyError_1 = require("./internal/util/EmptyError");
exports.EmptyError = EmptyError_1.EmptyError;
var ObjectUnsubscribedError_1 = require("./internal/util/ObjectUnsubscribedError");
exports.ObjectUnsubscribedError = ObjectUnsubscribedError_1.ObjectUnsubscribedError;
var UnsubscriptionError_1 = require("./internal/util/UnsubscriptionError");
exports.UnsubscriptionError = UnsubscriptionError_1.UnsubscriptionError;
var TimeoutError_1 = require("./internal/util/TimeoutError");
exports.TimeoutError = TimeoutError_1.TimeoutError;
var bindCallback_1 = require("./internal/observable/bindCallback");
exports.bindCallback = bindCallback_1.bindCallback;
var bindNodeCallback_1 = require("./internal/observable/bindNodeCallback");
exports.bindNodeCallback = bindNodeCallback_1.bindNodeCallback;
var combineLatest_1 = require("./internal/observable/combineLatest");
exports.combineLatest = combineLatest_1.combineLatest;
var concat_1 = require("./internal/observable/concat");
exports.concat = concat_1.concat;
var defer_1 = require("./internal/observable/defer");
exports.defer = defer_1.defer;
var empty_1 = require("./internal/observable/empty");
exports.empty = empty_1.empty;
var forkJoin_1 = require("./internal/observable/forkJoin");
exports.forkJoin = forkJoin_1.forkJoin;
var from_1 = require("./internal/observable/from");
exports.from = from_1.from;
var fromEvent_1 = require("./internal/observable/fromEvent");
exports.fromEvent = fromEvent_1.fromEvent;
var fromEventPattern_1 = require("./internal/observable/fromEventPattern");
exports.fromEventPattern = fromEventPattern_1.fromEventPattern;
var generate_1 = require("./internal/observable/generate");
exports.generate = generate_1.generate;
var iif_1 = require("./internal/observable/iif");
exports.iif = iif_1.iif;
var interval_1 = require("./internal/observable/interval");
exports.interval = interval_1.interval;
var merge_1 = require("./internal/observable/merge");
exports.merge = merge_1.merge;
var never_1 = require("./internal/observable/never");
exports.never = never_1.never;
var of_1 = require("./internal/observable/of");
exports.of = of_1.of;
var onErrorResumeNext_1 = require("./internal/observable/onErrorResumeNext");
exports.onErrorResumeNext = onErrorResumeNext_1.onErrorResumeNext;
var pairs_1 = require("./internal/observable/pairs");
exports.pairs = pairs_1.pairs;
var partition_1 = require("./internal/observable/partition");
exports.partition = partition_1.partition;
var race_1 = require("./internal/observable/race");
exports.race = race_1.race;
var range_1 = require("./internal/observable/range");
exports.range = range_1.range;
var throwError_1 = require("./internal/observable/throwError");
exports.throwError = throwError_1.throwError;
var timer_1 = require("./internal/observable/timer");
exports.timer = timer_1.timer;
var using_1 = require("./internal/observable/using");
exports.using = using_1.using;
var zip_1 = require("./internal/observable/zip");
exports.zip = zip_1.zip;
var scheduled_1 = require("./internal/scheduled/scheduled");
exports.scheduled = scheduled_1.scheduled;
var empty_2 = require("./internal/observable/empty");
exports.EMPTY = empty_2.EMPTY;
var never_2 = require("./internal/observable/never");
exports.NEVER = never_2.NEVER;
var config_1 = require("./internal/config");
exports.config = config_1.config;

},{"./internal/AsyncSubject":29,"./internal/BehaviorSubject":30,"./internal/Notification":32,"./internal/Observable":33,"./internal/ReplaySubject":36,"./internal/Scheduler":37,"./internal/Subject":38,"./internal/Subscriber":40,"./internal/Subscription":41,"./internal/config":42,"./internal/observable/ConnectableObservable":44,"./internal/observable/bindCallback":46,"./internal/observable/bindNodeCallback":47,"./internal/observable/combineLatest":48,"./internal/observable/concat":49,"./internal/observable/defer":50,"./internal/observable/empty":51,"./internal/observable/forkJoin":52,"./internal/observable/from":53,"./internal/observable/fromEvent":55,"./internal/observable/fromEventPattern":56,"./internal/observable/generate":57,"./internal/observable/iif":58,"./internal/observable/interval":59,"./internal/observable/merge":60,"./internal/observable/never":61,"./internal/observable/of":62,"./internal/observable/onErrorResumeNext":63,"./internal/observable/pairs":64,"./internal/observable/partition":65,"./internal/observable/race":66,"./internal/observable/range":67,"./internal/observable/throwError":68,"./internal/observable/timer":69,"./internal/observable/using":70,"./internal/observable/zip":71,"./internal/operators/groupBy":107,"./internal/scheduled/scheduled":179,"./internal/scheduler/VirtualTimeScheduler":189,"./internal/scheduler/animationFrame":190,"./internal/scheduler/asap":191,"./internal/scheduler/async":192,"./internal/scheduler/queue":193,"./internal/symbol/observable":195,"./internal/util/ArgumentOutOfRangeError":197,"./internal/util/EmptyError":198,"./internal/util/ObjectUnsubscribedError":200,"./internal/util/TimeoutError":201,"./internal/util/UnsubscriptionError":202,"./internal/util/identity":205,"./internal/util/isObservable":214,"./internal/util/noop":217,"./internal/util/pipe":219}],29:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subject_1 = require("./Subject");
var Subscription_1 = require("./Subscription");
var AsyncSubject = (function (_super) {
    __extends(AsyncSubject, _super);
    function AsyncSubject() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.value = null;
        _this.hasNext = false;
        _this.hasCompleted = false;
        return _this;
    }
    AsyncSubject.prototype._subscribe = function (subscriber) {
        if (this.hasError) {
            subscriber.error(this.thrownError);
            return Subscription_1.Subscription.EMPTY;
        }
        else if (this.hasCompleted && this.hasNext) {
            subscriber.next(this.value);
            subscriber.complete();
            return Subscription_1.Subscription.EMPTY;
        }
        return _super.prototype._subscribe.call(this, subscriber);
    };
    AsyncSubject.prototype.next = function (value) {
        if (!this.hasCompleted) {
            this.value = value;
            this.hasNext = true;
        }
    };
    AsyncSubject.prototype.error = function (error) {
        if (!this.hasCompleted) {
            _super.prototype.error.call(this, error);
        }
    };
    AsyncSubject.prototype.complete = function () {
        this.hasCompleted = true;
        if (this.hasNext) {
            _super.prototype.next.call(this, this.value);
        }
        _super.prototype.complete.call(this);
    };
    return AsyncSubject;
}(Subject_1.Subject));
exports.AsyncSubject = AsyncSubject;

},{"./Subject":38,"./Subscription":41}],30:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subject_1 = require("./Subject");
var ObjectUnsubscribedError_1 = require("./util/ObjectUnsubscribedError");
var BehaviorSubject = (function (_super) {
    __extends(BehaviorSubject, _super);
    function BehaviorSubject(_value) {
        var _this = _super.call(this) || this;
        _this._value = _value;
        return _this;
    }
    Object.defineProperty(BehaviorSubject.prototype, "value", {
        get: function () {
            return this.getValue();
        },
        enumerable: true,
        configurable: true
    });
    BehaviorSubject.prototype._subscribe = function (subscriber) {
        var subscription = _super.prototype._subscribe.call(this, subscriber);
        if (subscription && !subscription.closed) {
            subscriber.next(this._value);
        }
        return subscription;
    };
    BehaviorSubject.prototype.getValue = function () {
        if (this.hasError) {
            throw this.thrownError;
        }
        else if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        else {
            return this._value;
        }
    };
    BehaviorSubject.prototype.next = function (value) {
        _super.prototype.next.call(this, this._value = value);
    };
    return BehaviorSubject;
}(Subject_1.Subject));
exports.BehaviorSubject = BehaviorSubject;

},{"./Subject":38,"./util/ObjectUnsubscribedError":200}],31:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("./Subscriber");
var InnerSubscriber = (function (_super) {
    __extends(InnerSubscriber, _super);
    function InnerSubscriber(parent, outerValue, outerIndex) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        _this.outerValue = outerValue;
        _this.outerIndex = outerIndex;
        _this.index = 0;
        return _this;
    }
    InnerSubscriber.prototype._next = function (value) {
        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
    };
    InnerSubscriber.prototype._error = function (error) {
        this.parent.notifyError(error, this);
        this.unsubscribe();
    };
    InnerSubscriber.prototype._complete = function () {
        this.parent.notifyComplete(this);
        this.unsubscribe();
    };
    return InnerSubscriber;
}(Subscriber_1.Subscriber));
exports.InnerSubscriber = InnerSubscriber;

},{"./Subscriber":40}],32:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var empty_1 = require("./observable/empty");
var of_1 = require("./observable/of");
var throwError_1 = require("./observable/throwError");
var NotificationKind;
(function (NotificationKind) {
    NotificationKind["NEXT"] = "N";
    NotificationKind["ERROR"] = "E";
    NotificationKind["COMPLETE"] = "C";
})(NotificationKind = exports.NotificationKind || (exports.NotificationKind = {}));
var Notification = (function () {
    function Notification(kind, value, error) {
        this.kind = kind;
        this.value = value;
        this.error = error;
        this.hasValue = kind === 'N';
    }
    Notification.prototype.observe = function (observer) {
        switch (this.kind) {
            case 'N':
                return observer.next && observer.next(this.value);
            case 'E':
                return observer.error && observer.error(this.error);
            case 'C':
                return observer.complete && observer.complete();
        }
    };
    Notification.prototype.do = function (next, error, complete) {
        var kind = this.kind;
        switch (kind) {
            case 'N':
                return next && next(this.value);
            case 'E':
                return error && error(this.error);
            case 'C':
                return complete && complete();
        }
    };
    Notification.prototype.accept = function (nextOrObserver, error, complete) {
        if (nextOrObserver && typeof nextOrObserver.next === 'function') {
            return this.observe(nextOrObserver);
        }
        else {
            return this.do(nextOrObserver, error, complete);
        }
    };
    Notification.prototype.toObservable = function () {
        var kind = this.kind;
        switch (kind) {
            case 'N':
                return of_1.of(this.value);
            case 'E':
                return throwError_1.throwError(this.error);
            case 'C':
                return empty_1.empty();
        }
        throw new Error('unexpected notification kind value');
    };
    Notification.createNext = function (value) {
        if (typeof value !== 'undefined') {
            return new Notification('N', value);
        }
        return Notification.undefinedValueNotification;
    };
    Notification.createError = function (err) {
        return new Notification('E', undefined, err);
    };
    Notification.createComplete = function () {
        return Notification.completeNotification;
    };
    Notification.completeNotification = new Notification('C');
    Notification.undefinedValueNotification = new Notification('N', undefined);
    return Notification;
}());
exports.Notification = Notification;

},{"./observable/empty":51,"./observable/of":62,"./observable/throwError":68}],33:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var canReportError_1 = require("./util/canReportError");
var toSubscriber_1 = require("./util/toSubscriber");
var observable_1 = require("./symbol/observable");
var pipe_1 = require("./util/pipe");
var config_1 = require("./config");
var Observable = (function () {
    function Observable(subscribe) {
        this._isScalar = false;
        if (subscribe) {
            this._subscribe = subscribe;
        }
    }
    Observable.prototype.lift = function (operator) {
        var observable = new Observable();
        observable.source = this;
        observable.operator = operator;
        return observable;
    };
    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
        var operator = this.operator;
        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);
        if (operator) {
            sink.add(operator.call(sink, this.source));
        }
        else {
            sink.add(this.source || (config_1.config.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable) ?
                this._subscribe(sink) :
                this._trySubscribe(sink));
        }
        if (config_1.config.useDeprecatedSynchronousErrorHandling) {
            if (sink.syncErrorThrowable) {
                sink.syncErrorThrowable = false;
                if (sink.syncErrorThrown) {
                    throw sink.syncErrorValue;
                }
            }
        }
        return sink;
    };
    Observable.prototype._trySubscribe = function (sink) {
        try {
            return this._subscribe(sink);
        }
        catch (err) {
            if (config_1.config.useDeprecatedSynchronousErrorHandling) {
                sink.syncErrorThrown = true;
                sink.syncErrorValue = err;
            }
            if (canReportError_1.canReportError(sink)) {
                sink.error(err);
            }
            else {
                console.warn(err);
            }
        }
    };
    Observable.prototype.forEach = function (next, promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function (resolve, reject) {
            var subscription;
            subscription = _this.subscribe(function (value) {
                try {
                    next(value);
                }
                catch (err) {
                    reject(err);
                    if (subscription) {
                        subscription.unsubscribe();
                    }
                }
            }, reject, resolve);
        });
    };
    Observable.prototype._subscribe = function (subscriber) {
        var source = this.source;
        return source && source.subscribe(subscriber);
    };
    Observable.prototype[observable_1.observable] = function () {
        return this;
    };
    Observable.prototype.pipe = function () {
        var operations = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            operations[_i] = arguments[_i];
        }
        if (operations.length === 0) {
            return this;
        }
        return pipe_1.pipeFromArray(operations)(this);
    };
    Observable.prototype.toPromise = function (promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function (resolve, reject) {
            var value;
            _this.subscribe(function (x) { return value = x; }, function (err) { return reject(err); }, function () { return resolve(value); });
        });
    };
    Observable.create = function (subscribe) {
        return new Observable(subscribe);
    };
    return Observable;
}());
exports.Observable = Observable;
function getPromiseCtor(promiseCtor) {
    if (!promiseCtor) {
        promiseCtor = config_1.config.Promise || Promise;
    }
    if (!promiseCtor) {
        throw new Error('no Promise impl found');
    }
    return promiseCtor;
}

},{"./config":42,"./symbol/observable":195,"./util/canReportError":203,"./util/pipe":219,"./util/toSubscriber":226}],34:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var config_1 = require("./config");
var hostReportError_1 = require("./util/hostReportError");
exports.empty = {
    closed: true,
    next: function (value) { },
    error: function (err) {
        if (config_1.config.useDeprecatedSynchronousErrorHandling) {
            throw err;
        }
        else {
            hostReportError_1.hostReportError(err);
        }
    },
    complete: function () { }
};

},{"./config":42,"./util/hostReportError":204}],35:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("./Subscriber");
var OuterSubscriber = (function (_super) {
    __extends(OuterSubscriber, _super);
    function OuterSubscriber() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    OuterSubscriber.prototype.notifyError = function (error, innerSub) {
        this.destination.error(error);
    };
    OuterSubscriber.prototype.notifyComplete = function (innerSub) {
        this.destination.complete();
    };
    return OuterSubscriber;
}(Subscriber_1.Subscriber));
exports.OuterSubscriber = OuterSubscriber;

},{"./Subscriber":40}],36:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subject_1 = require("./Subject");
var queue_1 = require("./scheduler/queue");
var Subscription_1 = require("./Subscription");
var observeOn_1 = require("./operators/observeOn");
var ObjectUnsubscribedError_1 = require("./util/ObjectUnsubscribedError");
var SubjectSubscription_1 = require("./SubjectSubscription");
var ReplaySubject = (function (_super) {
    __extends(ReplaySubject, _super);
    function ReplaySubject(bufferSize, windowTime, scheduler) {
        if (bufferSize === void 0) { bufferSize = Number.POSITIVE_INFINITY; }
        if (windowTime === void 0) { windowTime = Number.POSITIVE_INFINITY; }
        var _this = _super.call(this) || this;
        _this.scheduler = scheduler;
        _this._events = [];
        _this._infiniteTimeWindow = false;
        _this._bufferSize = bufferSize < 1 ? 1 : bufferSize;
        _this._windowTime = windowTime < 1 ? 1 : windowTime;
        if (windowTime === Number.POSITIVE_INFINITY) {
            _this._infiniteTimeWindow = true;
            _this.next = _this.nextInfiniteTimeWindow;
        }
        else {
            _this.next = _this.nextTimeWindow;
        }
        return _this;
    }
    ReplaySubject.prototype.nextInfiniteTimeWindow = function (value) {
        if (!this.isStopped) {
            var _events = this._events;
            _events.push(value);
            if (_events.length > this._bufferSize) {
                _events.shift();
            }
        }
        _super.prototype.next.call(this, value);
    };
    ReplaySubject.prototype.nextTimeWindow = function (value) {
        if (!this.isStopped) {
            this._events.push(new ReplayEvent(this._getNow(), value));
            this._trimBufferThenGetEvents();
        }
        _super.prototype.next.call(this, value);
    };
    ReplaySubject.prototype._subscribe = function (subscriber) {
        var _infiniteTimeWindow = this._infiniteTimeWindow;
        var _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();
        var scheduler = this.scheduler;
        var len = _events.length;
        var subscription;
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        else if (this.isStopped || this.hasError) {
            subscription = Subscription_1.Subscription.EMPTY;
        }
        else {
            this.observers.push(subscriber);
            subscription = new SubjectSubscription_1.SubjectSubscription(this, subscriber);
        }
        if (scheduler) {
            subscriber.add(subscriber = new observeOn_1.ObserveOnSubscriber(subscriber, scheduler));
        }
        if (_infiniteTimeWindow) {
            for (var i = 0; i < len && !subscriber.closed; i++) {
                subscriber.next(_events[i]);
            }
        }
        else {
            for (var i = 0; i < len && !subscriber.closed; i++) {
                subscriber.next(_events[i].value);
            }
        }
        if (this.hasError) {
            subscriber.error(this.thrownError);
        }
        else if (this.isStopped) {
            subscriber.complete();
        }
        return subscription;
    };
    ReplaySubject.prototype._getNow = function () {
        return (this.scheduler || queue_1.queue).now();
    };
    ReplaySubject.prototype._trimBufferThenGetEvents = function () {
        var now = this._getNow();
        var _bufferSize = this._bufferSize;
        var _windowTime = this._windowTime;
        var _events = this._events;
        var eventsCount = _events.length;
        var spliceCount = 0;
        while (spliceCount < eventsCount) {
            if ((now - _events[spliceCount].time) < _windowTime) {
                break;
            }
            spliceCount++;
        }
        if (eventsCount > _bufferSize) {
            spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
        }
        if (spliceCount > 0) {
            _events.splice(0, spliceCount);
        }
        return _events;
    };
    return ReplaySubject;
}(Subject_1.Subject));
exports.ReplaySubject = ReplaySubject;
var ReplayEvent = (function () {
    function ReplayEvent(time, value) {
        this.time = time;
        this.value = value;
    }
    return ReplayEvent;
}());

},{"./Subject":38,"./SubjectSubscription":39,"./Subscription":41,"./operators/observeOn":122,"./scheduler/queue":193,"./util/ObjectUnsubscribedError":200}],37:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Scheduler = (function () {
    function Scheduler(SchedulerAction, now) {
        if (now === void 0) { now = Scheduler.now; }
        this.SchedulerAction = SchedulerAction;
        this.now = now;
    }
    Scheduler.prototype.schedule = function (work, delay, state) {
        if (delay === void 0) { delay = 0; }
        return new this.SchedulerAction(this, work).schedule(state, delay);
    };
    Scheduler.now = function () { return Date.now(); };
    return Scheduler;
}());
exports.Scheduler = Scheduler;

},{}],38:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("./Observable");
var Subscriber_1 = require("./Subscriber");
var Subscription_1 = require("./Subscription");
var ObjectUnsubscribedError_1 = require("./util/ObjectUnsubscribedError");
var SubjectSubscription_1 = require("./SubjectSubscription");
var rxSubscriber_1 = require("../internal/symbol/rxSubscriber");
var SubjectSubscriber = (function (_super) {
    __extends(SubjectSubscriber, _super);
    function SubjectSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        return _this;
    }
    return SubjectSubscriber;
}(Subscriber_1.Subscriber));
exports.SubjectSubscriber = SubjectSubscriber;
var Subject = (function (_super) {
    __extends(Subject, _super);
    function Subject() {
        var _this = _super.call(this) || this;
        _this.observers = [];
        _this.closed = false;
        _this.isStopped = false;
        _this.hasError = false;
        _this.thrownError = null;
        return _this;
    }
    Subject.prototype[rxSubscriber_1.rxSubscriber] = function () {
        return new SubjectSubscriber(this);
    };
    Subject.prototype.lift = function (operator) {
        var subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
    };
    Subject.prototype.next = function (value) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        if (!this.isStopped) {
            var observers = this.observers;
            var len = observers.length;
            var copy = observers.slice();
            for (var i = 0; i < len; i++) {
                copy[i].next(value);
            }
        }
    };
    Subject.prototype.error = function (err) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        this.hasError = true;
        this.thrownError = err;
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].error(err);
        }
        this.observers.length = 0;
    };
    Subject.prototype.complete = function () {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].complete();
        }
        this.observers.length = 0;
    };
    Subject.prototype.unsubscribe = function () {
        this.isStopped = true;
        this.closed = true;
        this.observers = null;
    };
    Subject.prototype._trySubscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        else {
            return _super.prototype._trySubscribe.call(this, subscriber);
        }
    };
    Subject.prototype._subscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        else if (this.hasError) {
            subscriber.error(this.thrownError);
            return Subscription_1.Subscription.EMPTY;
        }
        else if (this.isStopped) {
            subscriber.complete();
            return Subscription_1.Subscription.EMPTY;
        }
        else {
            this.observers.push(subscriber);
            return new SubjectSubscription_1.SubjectSubscription(this, subscriber);
        }
    };
    Subject.prototype.asObservable = function () {
        var observable = new Observable_1.Observable();
        observable.source = this;
        return observable;
    };
    Subject.create = function (destination, source) {
        return new AnonymousSubject(destination, source);
    };
    return Subject;
}(Observable_1.Observable));
exports.Subject = Subject;
var AnonymousSubject = (function (_super) {
    __extends(AnonymousSubject, _super);
    function AnonymousSubject(destination, source) {
        var _this = _super.call(this) || this;
        _this.destination = destination;
        _this.source = source;
        return _this;
    }
    AnonymousSubject.prototype.next = function (value) {
        var destination = this.destination;
        if (destination && destination.next) {
            destination.next(value);
        }
    };
    AnonymousSubject.prototype.error = function (err) {
        var destination = this.destination;
        if (destination && destination.error) {
            this.destination.error(err);
        }
    };
    AnonymousSubject.prototype.complete = function () {
        var destination = this.destination;
        if (destination && destination.complete) {
            this.destination.complete();
        }
    };
    AnonymousSubject.prototype._subscribe = function (subscriber) {
        var source = this.source;
        if (source) {
            return this.source.subscribe(subscriber);
        }
        else {
            return Subscription_1.Subscription.EMPTY;
        }
    };
    return AnonymousSubject;
}(Subject));
exports.AnonymousSubject = AnonymousSubject;

},{"../internal/symbol/rxSubscriber":196,"./Observable":33,"./SubjectSubscription":39,"./Subscriber":40,"./Subscription":41,"./util/ObjectUnsubscribedError":200}],39:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscription_1 = require("./Subscription");
var SubjectSubscription = (function (_super) {
    __extends(SubjectSubscription, _super);
    function SubjectSubscription(subject, subscriber) {
        var _this = _super.call(this) || this;
        _this.subject = subject;
        _this.subscriber = subscriber;
        _this.closed = false;
        return _this;
    }
    SubjectSubscription.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.closed = true;
        var subject = this.subject;
        var observers = subject.observers;
        this.subject = null;
        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
            return;
        }
        var subscriberIndex = observers.indexOf(this.subscriber);
        if (subscriberIndex !== -1) {
            observers.splice(subscriberIndex, 1);
        }
    };
    return SubjectSubscription;
}(Subscription_1.Subscription));
exports.SubjectSubscription = SubjectSubscription;

},{"./Subscription":41}],40:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var isFunction_1 = require("./util/isFunction");
var Observer_1 = require("./Observer");
var Subscription_1 = require("./Subscription");
var rxSubscriber_1 = require("../internal/symbol/rxSubscriber");
var config_1 = require("./config");
var hostReportError_1 = require("./util/hostReportError");
var Subscriber = (function (_super) {
    __extends(Subscriber, _super);
    function Subscriber(destinationOrNext, error, complete) {
        var _this = _super.call(this) || this;
        _this.syncErrorValue = null;
        _this.syncErrorThrown = false;
        _this.syncErrorThrowable = false;
        _this.isStopped = false;
        switch (arguments.length) {
            case 0:
                _this.destination = Observer_1.empty;
                break;
            case 1:
                if (!destinationOrNext) {
                    _this.destination = Observer_1.empty;
                    break;
                }
                if (typeof destinationOrNext === 'object') {
                    if (destinationOrNext instanceof Subscriber) {
                        _this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;
                        _this.destination = destinationOrNext;
                        destinationOrNext.add(_this);
                    }
                    else {
                        _this.syncErrorThrowable = true;
                        _this.destination = new SafeSubscriber(_this, destinationOrNext);
                    }
                    break;
                }
            default:
                _this.syncErrorThrowable = true;
                _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);
                break;
        }
        return _this;
    }
    Subscriber.prototype[rxSubscriber_1.rxSubscriber] = function () { return this; };
    Subscriber.create = function (next, error, complete) {
        var subscriber = new Subscriber(next, error, complete);
        subscriber.syncErrorThrowable = false;
        return subscriber;
    };
    Subscriber.prototype.next = function (value) {
        if (!this.isStopped) {
            this._next(value);
        }
    };
    Subscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            this.isStopped = true;
            this._error(err);
        }
    };
    Subscriber.prototype.complete = function () {
        if (!this.isStopped) {
            this.isStopped = true;
            this._complete();
        }
    };
    Subscriber.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
    };
    Subscriber.prototype._next = function (value) {
        this.destination.next(value);
    };
    Subscriber.prototype._error = function (err) {
        this.destination.error(err);
        this.unsubscribe();
    };
    Subscriber.prototype._complete = function () {
        this.destination.complete();
        this.unsubscribe();
    };
    Subscriber.prototype._unsubscribeAndRecycle = function () {
        var _parentOrParents = this._parentOrParents;
        this._parentOrParents = null;
        this.unsubscribe();
        this.closed = false;
        this.isStopped = false;
        this._parentOrParents = _parentOrParents;
        return this;
    };
    return Subscriber;
}(Subscription_1.Subscription));
exports.Subscriber = Subscriber;
var SafeSubscriber = (function (_super) {
    __extends(SafeSubscriber, _super);
    function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
        var _this = _super.call(this) || this;
        _this._parentSubscriber = _parentSubscriber;
        var next;
        var context = _this;
        if (isFunction_1.isFunction(observerOrNext)) {
            next = observerOrNext;
        }
        else if (observerOrNext) {
            next = observerOrNext.next;
            error = observerOrNext.error;
            complete = observerOrNext.complete;
            if (observerOrNext !== Observer_1.empty) {
                context = Object.create(observerOrNext);
                if (isFunction_1.isFunction(context.unsubscribe)) {
                    _this.add(context.unsubscribe.bind(context));
                }
                context.unsubscribe = _this.unsubscribe.bind(_this);
            }
        }
        _this._context = context;
        _this._next = next;
        _this._error = error;
        _this._complete = complete;
        return _this;
    }
    SafeSubscriber.prototype.next = function (value) {
        if (!this.isStopped && this._next) {
            var _parentSubscriber = this._parentSubscriber;
            if (!config_1.config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                this.__tryOrUnsub(this._next, value);
            }
            else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            var useDeprecatedSynchronousErrorHandling = config_1.config.useDeprecatedSynchronousErrorHandling;
            if (this._error) {
                if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(this._error, err);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parentSubscriber, this._error, err);
                    this.unsubscribe();
                }
            }
            else if (!_parentSubscriber.syncErrorThrowable) {
                this.unsubscribe();
                if (useDeprecatedSynchronousErrorHandling) {
                    throw err;
                }
                hostReportError_1.hostReportError(err);
            }
            else {
                if (useDeprecatedSynchronousErrorHandling) {
                    _parentSubscriber.syncErrorValue = err;
                    _parentSubscriber.syncErrorThrown = true;
                }
                else {
                    hostReportError_1.hostReportError(err);
                }
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.complete = function () {
        var _this = this;
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            if (this._complete) {
                var wrappedComplete = function () { return _this._complete.call(_this._context); };
                if (!config_1.config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(wrappedComplete);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parentSubscriber, wrappedComplete);
                    this.unsubscribe();
                }
            }
            else {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            this.unsubscribe();
            if (config_1.config.useDeprecatedSynchronousErrorHandling) {
                throw err;
            }
            else {
                hostReportError_1.hostReportError(err);
            }
        }
    };
    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
        if (!config_1.config.useDeprecatedSynchronousErrorHandling) {
            throw new Error('bad call');
        }
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            if (config_1.config.useDeprecatedSynchronousErrorHandling) {
                parent.syncErrorValue = err;
                parent.syncErrorThrown = true;
                return true;
            }
            else {
                hostReportError_1.hostReportError(err);
                return true;
            }
        }
        return false;
    };
    SafeSubscriber.prototype._unsubscribe = function () {
        var _parentSubscriber = this._parentSubscriber;
        this._context = null;
        this._parentSubscriber = null;
        _parentSubscriber.unsubscribe();
    };
    return SafeSubscriber;
}(Subscriber));
exports.SafeSubscriber = SafeSubscriber;

},{"../internal/symbol/rxSubscriber":196,"./Observer":34,"./Subscription":41,"./config":42,"./util/hostReportError":204,"./util/isFunction":209}],41:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var isArray_1 = require("./util/isArray");
var isObject_1 = require("./util/isObject");
var isFunction_1 = require("./util/isFunction");
var UnsubscriptionError_1 = require("./util/UnsubscriptionError");
var Subscription = (function () {
    function Subscription(unsubscribe) {
        this.closed = false;
        this._parentOrParents = null;
        this._subscriptions = null;
        if (unsubscribe) {
            this._ctorUnsubscribe = true;
            this._unsubscribe = unsubscribe;
        }
    }
    Subscription.prototype.unsubscribe = function () {
        var errors;
        if (this.closed) {
            return;
        }
        var _a = this, _parentOrParents = _a._parentOrParents, _ctorUnsubscribe = _a._ctorUnsubscribe, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
        this.closed = true;
        this._parentOrParents = null;
        this._subscriptions = null;
        if (_parentOrParents instanceof Subscription) {
            _parentOrParents.remove(this);
        }
        else if (_parentOrParents !== null) {
            for (var index = 0; index < _parentOrParents.length; ++index) {
                var parent_1 = _parentOrParents[index];
                parent_1.remove(this);
            }
        }
        if (isFunction_1.isFunction(_unsubscribe)) {
            if (_ctorUnsubscribe) {
                this._unsubscribe = undefined;
            }
            try {
                _unsubscribe.call(this);
            }
            catch (e) {
                errors = e instanceof UnsubscriptionError_1.UnsubscriptionError ? flattenUnsubscriptionErrors(e.errors) : [e];
            }
        }
        if (isArray_1.isArray(_subscriptions)) {
            var index = -1;
            var len = _subscriptions.length;
            while (++index < len) {
                var sub = _subscriptions[index];
                if (isObject_1.isObject(sub)) {
                    try {
                        sub.unsubscribe();
                    }
                    catch (e) {
                        errors = errors || [];
                        if (e instanceof UnsubscriptionError_1.UnsubscriptionError) {
                            errors = errors.concat(flattenUnsubscriptionErrors(e.errors));
                        }
                        else {
                            errors.push(e);
                        }
                    }
                }
            }
        }
        if (errors) {
            throw new UnsubscriptionError_1.UnsubscriptionError(errors);
        }
    };
    Subscription.prototype.add = function (teardown) {
        var subscription = teardown;
        if (!teardown) {
            return Subscription.EMPTY;
        }
        switch (typeof teardown) {
            case 'function':
                subscription = new Subscription(teardown);
            case 'object':
                if (subscription === this || subscription.closed || typeof subscription.unsubscribe !== 'function') {
                    return subscription;
                }
                else if (this.closed) {
                    subscription.unsubscribe();
                    return subscription;
                }
                else if (!(subscription instanceof Subscription)) {
                    var tmp = subscription;
                    subscription = new Subscription();
                    subscription._subscriptions = [tmp];
                }
                break;
            default: {
                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
            }
        }
        var _parentOrParents = subscription._parentOrParents;
        if (_parentOrParents === null) {
            subscription._parentOrParents = this;
        }
        else if (_parentOrParents instanceof Subscription) {
            if (_parentOrParents === this) {
                return subscription;
            }
            subscription._parentOrParents = [_parentOrParents, this];
        }
        else if (_parentOrParents.indexOf(this) === -1) {
            _parentOrParents.push(this);
        }
        else {
            return subscription;
        }
        var subscriptions = this._subscriptions;
        if (subscriptions === null) {
            this._subscriptions = [subscription];
        }
        else {
            subscriptions.push(subscription);
        }
        return subscription;
    };
    Subscription.prototype.remove = function (subscription) {
        var subscriptions = this._subscriptions;
        if (subscriptions) {
            var subscriptionIndex = subscriptions.indexOf(subscription);
            if (subscriptionIndex !== -1) {
                subscriptions.splice(subscriptionIndex, 1);
            }
        }
    };
    Subscription.EMPTY = (function (empty) {
        empty.closed = true;
        return empty;
    }(new Subscription()));
    return Subscription;
}());
exports.Subscription = Subscription;
function flattenUnsubscriptionErrors(errors) {
    return errors.reduce(function (errs, err) { return errs.concat((err instanceof UnsubscriptionError_1.UnsubscriptionError) ? err.errors : err); }, []);
}

},{"./util/UnsubscriptionError":202,"./util/isArray":206,"./util/isFunction":209,"./util/isObject":213}],42:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _enable_super_gross_mode_that_will_cause_bad_things = false;
exports.config = {
    Promise: undefined,
    set useDeprecatedSynchronousErrorHandling(value) {
        if (value) {
            var error = new Error();
            console.warn('DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n' + error.stack);
        }
        else if (_enable_super_gross_mode_that_will_cause_bad_things) {
            console.log('RxJS: Back to a better error behavior. Thank you. <3');
        }
        _enable_super_gross_mode_that_will_cause_bad_things = value;
    },
    get useDeprecatedSynchronousErrorHandling() {
        return _enable_super_gross_mode_that_will_cause_bad_things;
    },
};

},{}],43:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("./Subscriber");
var Observable_1 = require("./Observable");
var subscribeTo_1 = require("./util/subscribeTo");
var SimpleInnerSubscriber = (function (_super) {
    __extends(SimpleInnerSubscriber, _super);
    function SimpleInnerSubscriber(parent) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        return _this;
    }
    SimpleInnerSubscriber.prototype._next = function (value) {
        this.parent.notifyNext(value);
    };
    SimpleInnerSubscriber.prototype._error = function (error) {
        this.parent.notifyError(error);
        this.unsubscribe();
    };
    SimpleInnerSubscriber.prototype._complete = function () {
        this.parent.notifyComplete();
        this.unsubscribe();
    };
    return SimpleInnerSubscriber;
}(Subscriber_1.Subscriber));
exports.SimpleInnerSubscriber = SimpleInnerSubscriber;
var ComplexInnerSubscriber = (function (_super) {
    __extends(ComplexInnerSubscriber, _super);
    function ComplexInnerSubscriber(parent, outerValue, outerIndex) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        _this.outerValue = outerValue;
        _this.outerIndex = outerIndex;
        return _this;
    }
    ComplexInnerSubscriber.prototype._next = function (value) {
        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this);
    };
    ComplexInnerSubscriber.prototype._error = function (error) {
        this.parent.notifyError(error);
        this.unsubscribe();
    };
    ComplexInnerSubscriber.prototype._complete = function () {
        this.parent.notifyComplete(this);
        this.unsubscribe();
    };
    return ComplexInnerSubscriber;
}(Subscriber_1.Subscriber));
exports.ComplexInnerSubscriber = ComplexInnerSubscriber;
var SimpleOuterSubscriber = (function (_super) {
    __extends(SimpleOuterSubscriber, _super);
    function SimpleOuterSubscriber() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    SimpleOuterSubscriber.prototype.notifyNext = function (innerValue) {
        this.destination.next(innerValue);
    };
    SimpleOuterSubscriber.prototype.notifyError = function (err) {
        this.destination.error(err);
    };
    SimpleOuterSubscriber.prototype.notifyComplete = function () {
        this.destination.complete();
    };
    return SimpleOuterSubscriber;
}(Subscriber_1.Subscriber));
exports.SimpleOuterSubscriber = SimpleOuterSubscriber;
var ComplexOuterSubscriber = (function (_super) {
    __extends(ComplexOuterSubscriber, _super);
    function ComplexOuterSubscriber() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ComplexOuterSubscriber.prototype.notifyNext = function (_outerValue, innerValue, _outerIndex, _innerSub) {
        this.destination.next(innerValue);
    };
    ComplexOuterSubscriber.prototype.notifyError = function (error) {
        this.destination.error(error);
    };
    ComplexOuterSubscriber.prototype.notifyComplete = function (_innerSub) {
        this.destination.complete();
    };
    return ComplexOuterSubscriber;
}(Subscriber_1.Subscriber));
exports.ComplexOuterSubscriber = ComplexOuterSubscriber;
function innerSubscribe(result, innerSubscriber) {
    if (innerSubscriber.closed) {
        return undefined;
    }
    if (result instanceof Observable_1.Observable) {
        return result.subscribe(innerSubscriber);
    }
    return subscribeTo_1.subscribeTo(result)(innerSubscriber);
}
exports.innerSubscribe = innerSubscribe;

},{"./Observable":33,"./Subscriber":40,"./util/subscribeTo":220}],44:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subject_1 = require("../Subject");
var Observable_1 = require("../Observable");
var Subscriber_1 = require("../Subscriber");
var Subscription_1 = require("../Subscription");
var refCount_1 = require("../operators/refCount");
var ConnectableObservable = (function (_super) {
    __extends(ConnectableObservable, _super);
    function ConnectableObservable(source, subjectFactory) {
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.subjectFactory = subjectFactory;
        _this._refCount = 0;
        _this._isComplete = false;
        return _this;
    }
    ConnectableObservable.prototype._subscribe = function (subscriber) {
        return this.getSubject().subscribe(subscriber);
    };
    ConnectableObservable.prototype.getSubject = function () {
        var subject = this._subject;
        if (!subject || subject.isStopped) {
            this._subject = this.subjectFactory();
        }
        return this._subject;
    };
    ConnectableObservable.prototype.connect = function () {
        var connection = this._connection;
        if (!connection) {
            this._isComplete = false;
            connection = this._connection = new Subscription_1.Subscription();
            connection.add(this.source
                .subscribe(new ConnectableSubscriber(this.getSubject(), this)));
            if (connection.closed) {
                this._connection = null;
                connection = Subscription_1.Subscription.EMPTY;
            }
        }
        return connection;
    };
    ConnectableObservable.prototype.refCount = function () {
        return refCount_1.refCount()(this);
    };
    return ConnectableObservable;
}(Observable_1.Observable));
exports.ConnectableObservable = ConnectableObservable;
exports.connectableObservableDescriptor = (function () {
    var connectableProto = ConnectableObservable.prototype;
    return {
        operator: { value: null },
        _refCount: { value: 0, writable: true },
        _subject: { value: null, writable: true },
        _connection: { value: null, writable: true },
        _subscribe: { value: connectableProto._subscribe },
        _isComplete: { value: connectableProto._isComplete, writable: true },
        getSubject: { value: connectableProto.getSubject },
        connect: { value: connectableProto.connect },
        refCount: { value: connectableProto.refCount }
    };
})();
var ConnectableSubscriber = (function (_super) {
    __extends(ConnectableSubscriber, _super);
    function ConnectableSubscriber(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
    }
    ConnectableSubscriber.prototype._error = function (err) {
        this._unsubscribe();
        _super.prototype._error.call(this, err);
    };
    ConnectableSubscriber.prototype._complete = function () {
        this.connectable._isComplete = true;
        this._unsubscribe();
        _super.prototype._complete.call(this);
    };
    ConnectableSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (connectable) {
            this.connectable = null;
            var connection = connectable._connection;
            connectable._refCount = 0;
            connectable._subject = null;
            connectable._connection = null;
            if (connection) {
                connection.unsubscribe();
            }
        }
    };
    return ConnectableSubscriber;
}(Subject_1.SubjectSubscriber));
var RefCountOperator = (function () {
    function RefCountOperator(connectable) {
        this.connectable = connectable;
    }
    RefCountOperator.prototype.call = function (subscriber, source) {
        var connectable = this.connectable;
        connectable._refCount++;
        var refCounter = new RefCountSubscriber(subscriber, connectable);
        var subscription = source.subscribe(refCounter);
        if (!refCounter.closed) {
            refCounter.connection = connectable.connect();
        }
        return subscription;
    };
    return RefCountOperator;
}());
var RefCountSubscriber = (function (_super) {
    __extends(RefCountSubscriber, _super);
    function RefCountSubscriber(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
    }
    RefCountSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (!connectable) {
            this.connection = null;
            return;
        }
        this.connectable = null;
        var refCount = connectable._refCount;
        if (refCount <= 0) {
            this.connection = null;
            return;
        }
        connectable._refCount = refCount - 1;
        if (refCount > 1) {
            this.connection = null;
            return;
        }
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) {
            sharedConnection.unsubscribe();
        }
    };
    return RefCountSubscriber;
}(Subscriber_1.Subscriber));

},{"../Observable":33,"../Subject":38,"../Subscriber":40,"../Subscription":41,"../operators/refCount":133}],45:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var asap_1 = require("../scheduler/asap");
var isNumeric_1 = require("../util/isNumeric");
var SubscribeOnObservable = (function (_super) {
    __extends(SubscribeOnObservable, _super);
    function SubscribeOnObservable(source, delayTime, scheduler) {
        if (delayTime === void 0) { delayTime = 0; }
        if (scheduler === void 0) { scheduler = asap_1.asap; }
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.delayTime = delayTime;
        _this.scheduler = scheduler;
        if (!isNumeric_1.isNumeric(delayTime) || delayTime < 0) {
            _this.delayTime = 0;
        }
        if (!scheduler || typeof scheduler.schedule !== 'function') {
            _this.scheduler = asap_1.asap;
        }
        return _this;
    }
    SubscribeOnObservable.create = function (source, delay, scheduler) {
        if (delay === void 0) { delay = 0; }
        if (scheduler === void 0) { scheduler = asap_1.asap; }
        return new SubscribeOnObservable(source, delay, scheduler);
    };
    SubscribeOnObservable.dispatch = function (arg) {
        var source = arg.source, subscriber = arg.subscriber;
        return this.add(source.subscribe(subscriber));
    };
    SubscribeOnObservable.prototype._subscribe = function (subscriber) {
        var delay = this.delayTime;
        var source = this.source;
        var scheduler = this.scheduler;
        return scheduler.schedule(SubscribeOnObservable.dispatch, delay, {
            source: source, subscriber: subscriber
        });
    };
    return SubscribeOnObservable;
}(Observable_1.Observable));
exports.SubscribeOnObservable = SubscribeOnObservable;

},{"../Observable":33,"../scheduler/asap":191,"../util/isNumeric":212}],46:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var AsyncSubject_1 = require("../AsyncSubject");
var map_1 = require("../operators/map");
var canReportError_1 = require("../util/canReportError");
var isArray_1 = require("../util/isArray");
var isScheduler_1 = require("../util/isScheduler");
function bindCallback(callbackFunc, resultSelector, scheduler) {
    if (resultSelector) {
        if (isScheduler_1.isScheduler(resultSelector)) {
            scheduler = resultSelector;
        }
        else {
            return function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return bindCallback(callbackFunc, scheduler).apply(void 0, args).pipe(map_1.map(function (args) { return isArray_1.isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));
            };
        }
    }
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var context = this;
        var subject;
        var params = {
            context: context,
            subject: subject,
            callbackFunc: callbackFunc,
            scheduler: scheduler,
        };
        return new Observable_1.Observable(function (subscriber) {
            if (!scheduler) {
                if (!subject) {
                    subject = new AsyncSubject_1.AsyncSubject();
                    var handler = function () {
                        var innerArgs = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            innerArgs[_i] = arguments[_i];
                        }
                        subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
                        subject.complete();
                    };
                    try {
                        callbackFunc.apply(context, args.concat([handler]));
                    }
                    catch (err) {
                        if (canReportError_1.canReportError(subject)) {
                            subject.error(err);
                        }
                        else {
                            console.warn(err);
                        }
                    }
                }
                return subject.subscribe(subscriber);
            }
            else {
                var state = {
                    args: args, subscriber: subscriber, params: params,
                };
                return scheduler.schedule(dispatch, 0, state);
            }
        });
    };
}
exports.bindCallback = bindCallback;
function dispatch(state) {
    var _this = this;
    var self = this;
    var args = state.args, subscriber = state.subscriber, params = state.params;
    var callbackFunc = params.callbackFunc, context = params.context, scheduler = params.scheduler;
    var subject = params.subject;
    if (!subject) {
        subject = params.subject = new AsyncSubject_1.AsyncSubject();
        var handler = function () {
            var innerArgs = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                innerArgs[_i] = arguments[_i];
            }
            var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;
            _this.add(scheduler.schedule(dispatchNext, 0, { value: value, subject: subject }));
        };
        try {
            callbackFunc.apply(context, args.concat([handler]));
        }
        catch (err) {
            subject.error(err);
        }
    }
    this.add(subject.subscribe(subscriber));
}
function dispatchNext(state) {
    var value = state.value, subject = state.subject;
    subject.next(value);
    subject.complete();
}
function dispatchError(state) {
    var err = state.err, subject = state.subject;
    subject.error(err);
}

},{"../AsyncSubject":29,"../Observable":33,"../operators/map":111,"../util/canReportError":203,"../util/isArray":206,"../util/isScheduler":216}],47:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var AsyncSubject_1 = require("../AsyncSubject");
var map_1 = require("../operators/map");
var canReportError_1 = require("../util/canReportError");
var isScheduler_1 = require("../util/isScheduler");
var isArray_1 = require("../util/isArray");
function bindNodeCallback(callbackFunc, resultSelector, scheduler) {
    if (resultSelector) {
        if (isScheduler_1.isScheduler(resultSelector)) {
            scheduler = resultSelector;
        }
        else {
            return function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return bindNodeCallback(callbackFunc, scheduler).apply(void 0, args).pipe(map_1.map(function (args) { return isArray_1.isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));
            };
        }
    }
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var params = {
            subject: undefined,
            args: args,
            callbackFunc: callbackFunc,
            scheduler: scheduler,
            context: this,
        };
        return new Observable_1.Observable(function (subscriber) {
            var context = params.context;
            var subject = params.subject;
            if (!scheduler) {
                if (!subject) {
                    subject = params.subject = new AsyncSubject_1.AsyncSubject();
                    var handler = function () {
                        var innerArgs = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            innerArgs[_i] = arguments[_i];
                        }
                        var err = innerArgs.shift();
                        if (err) {
                            subject.error(err);
                            return;
                        }
                        subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
                        subject.complete();
                    };
                    try {
                        callbackFunc.apply(context, args.concat([handler]));
                    }
                    catch (err) {
                        if (canReportError_1.canReportError(subject)) {
                            subject.error(err);
                        }
                        else {
                            console.warn(err);
                        }
                    }
                }
                return subject.subscribe(subscriber);
            }
            else {
                return scheduler.schedule(dispatch, 0, { params: params, subscriber: subscriber, context: context });
            }
        });
    };
}
exports.bindNodeCallback = bindNodeCallback;
function dispatch(state) {
    var _this = this;
    var params = state.params, subscriber = state.subscriber, context = state.context;
    var callbackFunc = params.callbackFunc, args = params.args, scheduler = params.scheduler;
    var subject = params.subject;
    if (!subject) {
        subject = params.subject = new AsyncSubject_1.AsyncSubject();
        var handler = function () {
            var innerArgs = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                innerArgs[_i] = arguments[_i];
            }
            var err = innerArgs.shift();
            if (err) {
                _this.add(scheduler.schedule(dispatchError, 0, { err: err, subject: subject }));
            }
            else {
                var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;
                _this.add(scheduler.schedule(dispatchNext, 0, { value: value, subject: subject }));
            }
        };
        try {
            callbackFunc.apply(context, args.concat([handler]));
        }
        catch (err) {
            this.add(scheduler.schedule(dispatchError, 0, { err: err, subject: subject }));
        }
    }
    this.add(subject.subscribe(subscriber));
}
function dispatchNext(arg) {
    var value = arg.value, subject = arg.subject;
    subject.next(value);
    subject.complete();
}
function dispatchError(arg) {
    var err = arg.err, subject = arg.subject;
    subject.error(err);
}

},{"../AsyncSubject":29,"../Observable":33,"../operators/map":111,"../util/canReportError":203,"../util/isArray":206,"../util/isScheduler":216}],48:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var isScheduler_1 = require("../util/isScheduler");
var isArray_1 = require("../util/isArray");
var OuterSubscriber_1 = require("../OuterSubscriber");
var subscribeToResult_1 = require("../util/subscribeToResult");
var fromArray_1 = require("./fromArray");
var NONE = {};
function combineLatest() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    var resultSelector = undefined;
    var scheduler = undefined;
    if (isScheduler_1.isScheduler(observables[observables.length - 1])) {
        scheduler = observables.pop();
    }
    if (typeof observables[observables.length - 1] === 'function') {
        resultSelector = observables.pop();
    }
    if (observables.length === 1 && isArray_1.isArray(observables[0])) {
        observables = observables[0];
    }
    return fromArray_1.fromArray(observables, scheduler).lift(new CombineLatestOperator(resultSelector));
}
exports.combineLatest = combineLatest;
var CombineLatestOperator = (function () {
    function CombineLatestOperator(resultSelector) {
        this.resultSelector = resultSelector;
    }
    CombineLatestOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CombineLatestSubscriber(subscriber, this.resultSelector));
    };
    return CombineLatestOperator;
}());
exports.CombineLatestOperator = CombineLatestOperator;
var CombineLatestSubscriber = (function (_super) {
    __extends(CombineLatestSubscriber, _super);
    function CombineLatestSubscriber(destination, resultSelector) {
        var _this = _super.call(this, destination) || this;
        _this.resultSelector = resultSelector;
        _this.active = 0;
        _this.values = [];
        _this.observables = [];
        return _this;
    }
    CombineLatestSubscriber.prototype._next = function (observable) {
        this.values.push(NONE);
        this.observables.push(observable);
    };
    CombineLatestSubscriber.prototype._complete = function () {
        var observables = this.observables;
        var len = observables.length;
        if (len === 0) {
            this.destination.complete();
        }
        else {
            this.active = len;
            this.toRespond = len;
            for (var i = 0; i < len; i++) {
                var observable = observables[i];
                this.add(subscribeToResult_1.subscribeToResult(this, observable, undefined, i));
            }
        }
    };
    CombineLatestSubscriber.prototype.notifyComplete = function (unused) {
        if ((this.active -= 1) === 0) {
            this.destination.complete();
        }
    };
    CombineLatestSubscriber.prototype.notifyNext = function (_outerValue, innerValue, outerIndex) {
        var values = this.values;
        var oldVal = values[outerIndex];
        var toRespond = !this.toRespond
            ? 0
            : oldVal === NONE ? --this.toRespond : this.toRespond;
        values[outerIndex] = innerValue;
        if (toRespond === 0) {
            if (this.resultSelector) {
                this._tryResultSelector(values);
            }
            else {
                this.destination.next(values.slice());
            }
        }
    };
    CombineLatestSubscriber.prototype._tryResultSelector = function (values) {
        var result;
        try {
            result = this.resultSelector.apply(this, values);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return CombineLatestSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
exports.CombineLatestSubscriber = CombineLatestSubscriber;

},{"../OuterSubscriber":35,"../util/isArray":206,"../util/isScheduler":216,"../util/subscribeToResult":225,"./fromArray":54}],49:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var of_1 = require("./of");
var concatAll_1 = require("../operators/concatAll");
function concat() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    return concatAll_1.concatAll()(of_1.of.apply(void 0, observables));
}
exports.concat = concat;

},{"../operators/concatAll":83,"./of":62}],50:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var from_1 = require("./from");
var empty_1 = require("./empty");
function defer(observableFactory) {
    return new Observable_1.Observable(function (subscriber) {
        var input;
        try {
            input = observableFactory();
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
        var source = input ? from_1.from(input) : empty_1.empty();
        return source.subscribe(subscriber);
    });
}
exports.defer = defer;

},{"../Observable":33,"./empty":51,"./from":53}],51:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
exports.EMPTY = new Observable_1.Observable(function (subscriber) { return subscriber.complete(); });
function empty(scheduler) {
    return scheduler ? emptyScheduled(scheduler) : exports.EMPTY;
}
exports.empty = empty;
function emptyScheduled(scheduler) {
    return new Observable_1.Observable(function (subscriber) { return scheduler.schedule(function () { return subscriber.complete(); }); });
}

},{"../Observable":33}],52:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var isArray_1 = require("../util/isArray");
var map_1 = require("../operators/map");
var isObject_1 = require("../util/isObject");
var from_1 = require("./from");
function forkJoin() {
    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
    }
    if (sources.length === 1) {
        var first_1 = sources[0];
        if (isArray_1.isArray(first_1)) {
            return forkJoinInternal(first_1, null);
        }
        if (isObject_1.isObject(first_1) && Object.getPrototypeOf(first_1) === Object.prototype) {
            var keys = Object.keys(first_1);
            return forkJoinInternal(keys.map(function (key) { return first_1[key]; }), keys);
        }
    }
    if (typeof sources[sources.length - 1] === 'function') {
        var resultSelector_1 = sources.pop();
        sources = (sources.length === 1 && isArray_1.isArray(sources[0])) ? sources[0] : sources;
        return forkJoinInternal(sources, null).pipe(map_1.map(function (args) { return resultSelector_1.apply(void 0, args); }));
    }
    return forkJoinInternal(sources, null);
}
exports.forkJoin = forkJoin;
function forkJoinInternal(sources, keys) {
    return new Observable_1.Observable(function (subscriber) {
        var len = sources.length;
        if (len === 0) {
            subscriber.complete();
            return;
        }
        var values = new Array(len);
        var completed = 0;
        var emitted = 0;
        var _loop_1 = function (i) {
            var source = from_1.from(sources[i]);
            var hasValue = false;
            subscriber.add(source.subscribe({
                next: function (value) {
                    if (!hasValue) {
                        hasValue = true;
                        emitted++;
                    }
                    values[i] = value;
                },
                error: function (err) { return subscriber.error(err); },
                complete: function () {
                    completed++;
                    if (completed === len || !hasValue) {
                        if (emitted === len) {
                            subscriber.next(keys ?
                                keys.reduce(function (result, key, i) { return (result[key] = values[i], result); }, {}) :
                                values);
                        }
                        subscriber.complete();
                    }
                }
            }));
        };
        for (var i = 0; i < len; i++) {
            _loop_1(i);
        }
    });
}

},{"../Observable":33,"../operators/map":111,"../util/isArray":206,"../util/isObject":213,"./from":53}],53:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var subscribeTo_1 = require("../util/subscribeTo");
var scheduled_1 = require("../scheduled/scheduled");
function from(input, scheduler) {
    if (!scheduler) {
        if (input instanceof Observable_1.Observable) {
            return input;
        }
        return new Observable_1.Observable(subscribeTo_1.subscribeTo(input));
    }
    else {
        return scheduled_1.scheduled(input, scheduler);
    }
}
exports.from = from;

},{"../Observable":33,"../scheduled/scheduled":179,"../util/subscribeTo":220}],54:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var subscribeToArray_1 = require("../util/subscribeToArray");
var scheduleArray_1 = require("../scheduled/scheduleArray");
function fromArray(input, scheduler) {
    if (!scheduler) {
        return new Observable_1.Observable(subscribeToArray_1.subscribeToArray(input));
    }
    else {
        return scheduleArray_1.scheduleArray(input, scheduler);
    }
}
exports.fromArray = fromArray;

},{"../Observable":33,"../scheduled/scheduleArray":175,"../util/subscribeToArray":221}],55:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var isArray_1 = require("../util/isArray");
var isFunction_1 = require("../util/isFunction");
var map_1 = require("../operators/map");
var toString = (function () { return Object.prototype.toString; })();
function fromEvent(target, eventName, options, resultSelector) {
    if (isFunction_1.isFunction(options)) {
        resultSelector = options;
        options = undefined;
    }
    if (resultSelector) {
        return fromEvent(target, eventName, options).pipe(map_1.map(function (args) { return isArray_1.isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));
    }
    return new Observable_1.Observable(function (subscriber) {
        function handler(e) {
            if (arguments.length > 1) {
                subscriber.next(Array.prototype.slice.call(arguments));
            }
            else {
                subscriber.next(e);
            }
        }
        setupSubscription(target, eventName, handler, subscriber, options);
    });
}
exports.fromEvent = fromEvent;
function setupSubscription(sourceObj, eventName, handler, subscriber, options) {
    var unsubscribe;
    if (isEventTarget(sourceObj)) {
        var source_1 = sourceObj;
        sourceObj.addEventListener(eventName, handler, options);
        unsubscribe = function () { return source_1.removeEventListener(eventName, handler, options); };
    }
    else if (isJQueryStyleEventEmitter(sourceObj)) {
        var source_2 = sourceObj;
        sourceObj.on(eventName, handler);
        unsubscribe = function () { return source_2.off(eventName, handler); };
    }
    else if (isNodeStyleEventEmitter(sourceObj)) {
        var source_3 = sourceObj;
        sourceObj.addListener(eventName, handler);
        unsubscribe = function () { return source_3.removeListener(eventName, handler); };
    }
    else if (sourceObj && sourceObj.length) {
        for (var i = 0, len = sourceObj.length; i < len; i++) {
            setupSubscription(sourceObj[i], eventName, handler, subscriber, options);
        }
    }
    else {
        throw new TypeError('Invalid event target');
    }
    subscriber.add(unsubscribe);
}
function isNodeStyleEventEmitter(sourceObj) {
    return sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';
}
function isJQueryStyleEventEmitter(sourceObj) {
    return sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';
}
function isEventTarget(sourceObj) {
    return sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';
}

},{"../Observable":33,"../operators/map":111,"../util/isArray":206,"../util/isFunction":209}],56:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var isArray_1 = require("../util/isArray");
var isFunction_1 = require("../util/isFunction");
var map_1 = require("../operators/map");
function fromEventPattern(addHandler, removeHandler, resultSelector) {
    if (resultSelector) {
        return fromEventPattern(addHandler, removeHandler).pipe(map_1.map(function (args) { return isArray_1.isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));
    }
    return new Observable_1.Observable(function (subscriber) {
        var handler = function () {
            var e = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                e[_i] = arguments[_i];
            }
            return subscriber.next(e.length === 1 ? e[0] : e);
        };
        var retValue;
        try {
            retValue = addHandler(handler);
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
        if (!isFunction_1.isFunction(removeHandler)) {
            return undefined;
        }
        return function () { return removeHandler(handler, retValue); };
    });
}
exports.fromEventPattern = fromEventPattern;

},{"../Observable":33,"../operators/map":111,"../util/isArray":206,"../util/isFunction":209}],57:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var identity_1 = require("../util/identity");
var isScheduler_1 = require("../util/isScheduler");
function generate(initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler) {
    var resultSelector;
    var initialState;
    if (arguments.length == 1) {
        var options = initialStateOrOptions;
        initialState = options.initialState;
        condition = options.condition;
        iterate = options.iterate;
        resultSelector = options.resultSelector || identity_1.identity;
        scheduler = options.scheduler;
    }
    else if (resultSelectorOrObservable === undefined || isScheduler_1.isScheduler(resultSelectorOrObservable)) {
        initialState = initialStateOrOptions;
        resultSelector = identity_1.identity;
        scheduler = resultSelectorOrObservable;
    }
    else {
        initialState = initialStateOrOptions;
        resultSelector = resultSelectorOrObservable;
    }
    return new Observable_1.Observable(function (subscriber) {
        var state = initialState;
        if (scheduler) {
            return scheduler.schedule(dispatch, 0, {
                subscriber: subscriber,
                iterate: iterate,
                condition: condition,
                resultSelector: resultSelector,
                state: state
            });
        }
        do {
            if (condition) {
                var conditionResult = void 0;
                try {
                    conditionResult = condition(state);
                }
                catch (err) {
                    subscriber.error(err);
                    return undefined;
                }
                if (!conditionResult) {
                    subscriber.complete();
                    break;
                }
            }
            var value = void 0;
            try {
                value = resultSelector(state);
            }
            catch (err) {
                subscriber.error(err);
                return undefined;
            }
            subscriber.next(value);
            if (subscriber.closed) {
                break;
            }
            try {
                state = iterate(state);
            }
            catch (err) {
                subscriber.error(err);
                return undefined;
            }
        } while (true);
        return undefined;
    });
}
exports.generate = generate;
function dispatch(state) {
    var subscriber = state.subscriber, condition = state.condition;
    if (subscriber.closed) {
        return undefined;
    }
    if (state.needIterate) {
        try {
            state.state = state.iterate(state.state);
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
    }
    else {
        state.needIterate = true;
    }
    if (condition) {
        var conditionResult = void 0;
        try {
            conditionResult = condition(state.state);
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
        if (!conditionResult) {
            subscriber.complete();
            return undefined;
        }
        if (subscriber.closed) {
            return undefined;
        }
    }
    var value;
    try {
        value = state.resultSelector(state.state);
    }
    catch (err) {
        subscriber.error(err);
        return undefined;
    }
    if (subscriber.closed) {
        return undefined;
    }
    subscriber.next(value);
    if (subscriber.closed) {
        return undefined;
    }
    return this.schedule(state);
}

},{"../Observable":33,"../util/identity":205,"../util/isScheduler":216}],58:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var defer_1 = require("./defer");
var empty_1 = require("./empty");
function iif(condition, trueResult, falseResult) {
    if (trueResult === void 0) { trueResult = empty_1.EMPTY; }
    if (falseResult === void 0) { falseResult = empty_1.EMPTY; }
    return defer_1.defer(function () { return condition() ? trueResult : falseResult; });
}
exports.iif = iif;

},{"./defer":50,"./empty":51}],59:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var async_1 = require("../scheduler/async");
var isNumeric_1 = require("../util/isNumeric");
function interval(period, scheduler) {
    if (period === void 0) { period = 0; }
    if (scheduler === void 0) { scheduler = async_1.async; }
    if (!isNumeric_1.isNumeric(period) || period < 0) {
        period = 0;
    }
    if (!scheduler || typeof scheduler.schedule !== 'function') {
        scheduler = async_1.async;
    }
    return new Observable_1.Observable(function (subscriber) {
        subscriber.add(scheduler.schedule(dispatch, period, { subscriber: subscriber, counter: 0, period: period }));
        return subscriber;
    });
}
exports.interval = interval;
function dispatch(state) {
    var subscriber = state.subscriber, counter = state.counter, period = state.period;
    subscriber.next(counter);
    this.schedule({ subscriber: subscriber, counter: counter + 1, period: period }, period);
}

},{"../Observable":33,"../scheduler/async":192,"../util/isNumeric":212}],60:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var isScheduler_1 = require("../util/isScheduler");
var mergeAll_1 = require("../operators/mergeAll");
var fromArray_1 = require("./fromArray");
function merge() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    var concurrent = Number.POSITIVE_INFINITY;
    var scheduler = null;
    var last = observables[observables.length - 1];
    if (isScheduler_1.isScheduler(last)) {
        scheduler = observables.pop();
        if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {
            concurrent = observables.pop();
        }
    }
    else if (typeof last === 'number') {
        concurrent = observables.pop();
    }
    if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable_1.Observable) {
        return observables[0];
    }
    return mergeAll_1.mergeAll(concurrent)(fromArray_1.fromArray(observables, scheduler));
}
exports.merge = merge;

},{"../Observable":33,"../operators/mergeAll":116,"../util/isScheduler":216,"./fromArray":54}],61:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var noop_1 = require("../util/noop");
exports.NEVER = new Observable_1.Observable(noop_1.noop);
function never() {
    return exports.NEVER;
}
exports.never = never;

},{"../Observable":33,"../util/noop":217}],62:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var isScheduler_1 = require("../util/isScheduler");
var fromArray_1 = require("./fromArray");
var scheduleArray_1 = require("../scheduled/scheduleArray");
function of() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var scheduler = args[args.length - 1];
    if (isScheduler_1.isScheduler(scheduler)) {
        args.pop();
        return scheduleArray_1.scheduleArray(args, scheduler);
    }
    else {
        return fromArray_1.fromArray(args);
    }
}
exports.of = of;

},{"../scheduled/scheduleArray":175,"../util/isScheduler":216,"./fromArray":54}],63:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var from_1 = require("./from");
var isArray_1 = require("../util/isArray");
var empty_1 = require("./empty");
function onErrorResumeNext() {
    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
    }
    if (sources.length === 0) {
        return empty_1.EMPTY;
    }
    var first = sources[0], remainder = sources.slice(1);
    if (sources.length === 1 && isArray_1.isArray(first)) {
        return onErrorResumeNext.apply(void 0, first);
    }
    return new Observable_1.Observable(function (subscriber) {
        var subNext = function () { return subscriber.add(onErrorResumeNext.apply(void 0, remainder).subscribe(subscriber)); };
        return from_1.from(first).subscribe({
            next: function (value) { subscriber.next(value); },
            error: subNext,
            complete: subNext,
        });
    });
}
exports.onErrorResumeNext = onErrorResumeNext;

},{"../Observable":33,"../util/isArray":206,"./empty":51,"./from":53}],64:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var Subscription_1 = require("../Subscription");
function pairs(obj, scheduler) {
    if (!scheduler) {
        return new Observable_1.Observable(function (subscriber) {
            var keys = Object.keys(obj);
            for (var i = 0; i < keys.length && !subscriber.closed; i++) {
                var key = keys[i];
                if (obj.hasOwnProperty(key)) {
                    subscriber.next([key, obj[key]]);
                }
            }
            subscriber.complete();
        });
    }
    else {
        return new Observable_1.Observable(function (subscriber) {
            var keys = Object.keys(obj);
            var subscription = new Subscription_1.Subscription();
            subscription.add(scheduler.schedule(dispatch, 0, { keys: keys, index: 0, subscriber: subscriber, subscription: subscription, obj: obj }));
            return subscription;
        });
    }
}
exports.pairs = pairs;
function dispatch(state) {
    var keys = state.keys, index = state.index, subscriber = state.subscriber, subscription = state.subscription, obj = state.obj;
    if (!subscriber.closed) {
        if (index < keys.length) {
            var key = keys[index];
            subscriber.next([key, obj[key]]);
            subscription.add(this.schedule({ keys: keys, index: index + 1, subscriber: subscriber, subscription: subscription, obj: obj }));
        }
        else {
            subscriber.complete();
        }
    }
}
exports.dispatch = dispatch;

},{"../Observable":33,"../Subscription":41}],65:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var not_1 = require("../util/not");
var subscribeTo_1 = require("../util/subscribeTo");
var filter_1 = require("../operators/filter");
var Observable_1 = require("../Observable");
function partition(source, predicate, thisArg) {
    return [
        filter_1.filter(predicate, thisArg)(new Observable_1.Observable(subscribeTo_1.subscribeTo(source))),
        filter_1.filter(not_1.not(predicate, thisArg))(new Observable_1.Observable(subscribeTo_1.subscribeTo(source)))
    ];
}
exports.partition = partition;

},{"../Observable":33,"../operators/filter":102,"../util/not":218,"../util/subscribeTo":220}],66:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var isArray_1 = require("../util/isArray");
var fromArray_1 = require("./fromArray");
var OuterSubscriber_1 = require("../OuterSubscriber");
var subscribeToResult_1 = require("../util/subscribeToResult");
function race() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    if (observables.length === 1) {
        if (isArray_1.isArray(observables[0])) {
            observables = observables[0];
        }
        else {
            return observables[0];
        }
    }
    return fromArray_1.fromArray(observables, undefined).lift(new RaceOperator());
}
exports.race = race;
var RaceOperator = (function () {
    function RaceOperator() {
    }
    RaceOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RaceSubscriber(subscriber));
    };
    return RaceOperator;
}());
exports.RaceOperator = RaceOperator;
var RaceSubscriber = (function (_super) {
    __extends(RaceSubscriber, _super);
    function RaceSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.hasFirst = false;
        _this.observables = [];
        _this.subscriptions = [];
        return _this;
    }
    RaceSubscriber.prototype._next = function (observable) {
        this.observables.push(observable);
    };
    RaceSubscriber.prototype._complete = function () {
        var observables = this.observables;
        var len = observables.length;
        if (len === 0) {
            this.destination.complete();
        }
        else {
            for (var i = 0; i < len && !this.hasFirst; i++) {
                var observable = observables[i];
                var subscription = subscribeToResult_1.subscribeToResult(this, observable, undefined, i);
                if (this.subscriptions) {
                    this.subscriptions.push(subscription);
                }
                this.add(subscription);
            }
            this.observables = null;
        }
    };
    RaceSubscriber.prototype.notifyNext = function (_outerValue, innerValue, outerIndex) {
        if (!this.hasFirst) {
            this.hasFirst = true;
            for (var i = 0; i < this.subscriptions.length; i++) {
                if (i !== outerIndex) {
                    var subscription = this.subscriptions[i];
                    subscription.unsubscribe();
                    this.remove(subscription);
                }
            }
            this.subscriptions = null;
        }
        this.destination.next(innerValue);
    };
    return RaceSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
exports.RaceSubscriber = RaceSubscriber;

},{"../OuterSubscriber":35,"../util/isArray":206,"../util/subscribeToResult":225,"./fromArray":54}],67:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
function range(start, count, scheduler) {
    if (start === void 0) { start = 0; }
    return new Observable_1.Observable(function (subscriber) {
        if (count === undefined) {
            count = start;
            start = 0;
        }
        var index = 0;
        var current = start;
        if (scheduler) {
            return scheduler.schedule(dispatch, 0, {
                index: index, count: count, start: start, subscriber: subscriber
            });
        }
        else {
            do {
                if (index++ >= count) {
                    subscriber.complete();
                    break;
                }
                subscriber.next(current++);
                if (subscriber.closed) {
                    break;
                }
            } while (true);
        }
        return undefined;
    });
}
exports.range = range;
function dispatch(state) {
    var start = state.start, index = state.index, count = state.count, subscriber = state.subscriber;
    if (index >= count) {
        subscriber.complete();
        return;
    }
    subscriber.next(start);
    if (subscriber.closed) {
        return;
    }
    state.index = index + 1;
    state.start = start + 1;
    this.schedule(state);
}
exports.dispatch = dispatch;

},{"../Observable":33}],68:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
function throwError(error, scheduler) {
    if (!scheduler) {
        return new Observable_1.Observable(function (subscriber) { return subscriber.error(error); });
    }
    else {
        return new Observable_1.Observable(function (subscriber) { return scheduler.schedule(dispatch, 0, { error: error, subscriber: subscriber }); });
    }
}
exports.throwError = throwError;
function dispatch(_a) {
    var error = _a.error, subscriber = _a.subscriber;
    subscriber.error(error);
}

},{"../Observable":33}],69:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var async_1 = require("../scheduler/async");
var isNumeric_1 = require("../util/isNumeric");
var isScheduler_1 = require("../util/isScheduler");
function timer(dueTime, periodOrScheduler, scheduler) {
    if (dueTime === void 0) { dueTime = 0; }
    var period = -1;
    if (isNumeric_1.isNumeric(periodOrScheduler)) {
        period = Number(periodOrScheduler) < 1 && 1 || Number(periodOrScheduler);
    }
    else if (isScheduler_1.isScheduler(periodOrScheduler)) {
        scheduler = periodOrScheduler;
    }
    if (!isScheduler_1.isScheduler(scheduler)) {
        scheduler = async_1.async;
    }
    return new Observable_1.Observable(function (subscriber) {
        var due = isNumeric_1.isNumeric(dueTime)
            ? dueTime
            : (+dueTime - scheduler.now());
        return scheduler.schedule(dispatch, due, {
            index: 0, period: period, subscriber: subscriber
        });
    });
}
exports.timer = timer;
function dispatch(state) {
    var index = state.index, period = state.period, subscriber = state.subscriber;
    subscriber.next(index);
    if (subscriber.closed) {
        return;
    }
    else if (period === -1) {
        return subscriber.complete();
    }
    state.index = index + 1;
    this.schedule(state, period);
}

},{"../Observable":33,"../scheduler/async":192,"../util/isNumeric":212,"../util/isScheduler":216}],70:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var from_1 = require("./from");
var empty_1 = require("./empty");
function using(resourceFactory, observableFactory) {
    return new Observable_1.Observable(function (subscriber) {
        var resource;
        try {
            resource = resourceFactory();
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
        var result;
        try {
            result = observableFactory(resource);
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
        var source = result ? from_1.from(result) : empty_1.EMPTY;
        var subscription = source.subscribe(subscriber);
        return function () {
            subscription.unsubscribe();
            if (resource) {
                resource.unsubscribe();
            }
        };
    });
}
exports.using = using;

},{"../Observable":33,"./empty":51,"./from":53}],71:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var fromArray_1 = require("./fromArray");
var isArray_1 = require("../util/isArray");
var Subscriber_1 = require("../Subscriber");
var iterator_1 = require("../../internal/symbol/iterator");
var innerSubscribe_1 = require("../innerSubscribe");
function zip() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    var resultSelector = observables[observables.length - 1];
    if (typeof resultSelector === 'function') {
        observables.pop();
    }
    return fromArray_1.fromArray(observables, undefined).lift(new ZipOperator(resultSelector));
}
exports.zip = zip;
var ZipOperator = (function () {
    function ZipOperator(resultSelector) {
        this.resultSelector = resultSelector;
    }
    ZipOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ZipSubscriber(subscriber, this.resultSelector));
    };
    return ZipOperator;
}());
exports.ZipOperator = ZipOperator;
var ZipSubscriber = (function (_super) {
    __extends(ZipSubscriber, _super);
    function ZipSubscriber(destination, resultSelector, values) {
        if (values === void 0) { values = Object.create(null); }
        var _this = _super.call(this, destination) || this;
        _this.resultSelector = resultSelector;
        _this.iterators = [];
        _this.active = 0;
        _this.resultSelector = (typeof resultSelector === 'function') ? resultSelector : undefined;
        return _this;
    }
    ZipSubscriber.prototype._next = function (value) {
        var iterators = this.iterators;
        if (isArray_1.isArray(value)) {
            iterators.push(new StaticArrayIterator(value));
        }
        else if (typeof value[iterator_1.iterator] === 'function') {
            iterators.push(new StaticIterator(value[iterator_1.iterator]()));
        }
        else {
            iterators.push(new ZipBufferIterator(this.destination, this, value));
        }
    };
    ZipSubscriber.prototype._complete = function () {
        var iterators = this.iterators;
        var len = iterators.length;
        this.unsubscribe();
        if (len === 0) {
            this.destination.complete();
            return;
        }
        this.active = len;
        for (var i = 0; i < len; i++) {
            var iterator = iterators[i];
            if (iterator.stillUnsubscribed) {
                var destination = this.destination;
                destination.add(iterator.subscribe());
            }
            else {
                this.active--;
            }
        }
    };
    ZipSubscriber.prototype.notifyInactive = function () {
        this.active--;
        if (this.active === 0) {
            this.destination.complete();
        }
    };
    ZipSubscriber.prototype.checkIterators = function () {
        var iterators = this.iterators;
        var len = iterators.length;
        var destination = this.destination;
        for (var i = 0; i < len; i++) {
            var iterator = iterators[i];
            if (typeof iterator.hasValue === 'function' && !iterator.hasValue()) {
                return;
            }
        }
        var shouldComplete = false;
        var args = [];
        for (var i = 0; i < len; i++) {
            var iterator = iterators[i];
            var result = iterator.next();
            if (iterator.hasCompleted()) {
                shouldComplete = true;
            }
            if (result.done) {
                destination.complete();
                return;
            }
            args.push(result.value);
        }
        if (this.resultSelector) {
            this._tryresultSelector(args);
        }
        else {
            destination.next(args);
        }
        if (shouldComplete) {
            destination.complete();
        }
    };
    ZipSubscriber.prototype._tryresultSelector = function (args) {
        var result;
        try {
            result = this.resultSelector.apply(this, args);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return ZipSubscriber;
}(Subscriber_1.Subscriber));
exports.ZipSubscriber = ZipSubscriber;
var StaticIterator = (function () {
    function StaticIterator(iterator) {
        this.iterator = iterator;
        this.nextResult = iterator.next();
    }
    StaticIterator.prototype.hasValue = function () {
        return true;
    };
    StaticIterator.prototype.next = function () {
        var result = this.nextResult;
        this.nextResult = this.iterator.next();
        return result;
    };
    StaticIterator.prototype.hasCompleted = function () {
        var nextResult = this.nextResult;
        return Boolean(nextResult && nextResult.done);
    };
    return StaticIterator;
}());
var StaticArrayIterator = (function () {
    function StaticArrayIterator(array) {
        this.array = array;
        this.index = 0;
        this.length = 0;
        this.length = array.length;
    }
    StaticArrayIterator.prototype[iterator_1.iterator] = function () {
        return this;
    };
    StaticArrayIterator.prototype.next = function (value) {
        var i = this.index++;
        var array = this.array;
        return i < this.length ? { value: array[i], done: false } : { value: null, done: true };
    };
    StaticArrayIterator.prototype.hasValue = function () {
        return this.array.length > this.index;
    };
    StaticArrayIterator.prototype.hasCompleted = function () {
        return this.array.length === this.index;
    };
    return StaticArrayIterator;
}());
var ZipBufferIterator = (function (_super) {
    __extends(ZipBufferIterator, _super);
    function ZipBufferIterator(destination, parent, observable) {
        var _this = _super.call(this, destination) || this;
        _this.parent = parent;
        _this.observable = observable;
        _this.stillUnsubscribed = true;
        _this.buffer = [];
        _this.isComplete = false;
        return _this;
    }
    ZipBufferIterator.prototype[iterator_1.iterator] = function () {
        return this;
    };
    ZipBufferIterator.prototype.next = function () {
        var buffer = this.buffer;
        if (buffer.length === 0 && this.isComplete) {
            return { value: null, done: true };
        }
        else {
            return { value: buffer.shift(), done: false };
        }
    };
    ZipBufferIterator.prototype.hasValue = function () {
        return this.buffer.length > 0;
    };
    ZipBufferIterator.prototype.hasCompleted = function () {
        return this.buffer.length === 0 && this.isComplete;
    };
    ZipBufferIterator.prototype.notifyComplete = function () {
        if (this.buffer.length > 0) {
            this.isComplete = true;
            this.parent.notifyInactive();
        }
        else {
            this.destination.complete();
        }
    };
    ZipBufferIterator.prototype.notifyNext = function (innerValue) {
        this.buffer.push(innerValue);
        this.parent.checkIterators();
    };
    ZipBufferIterator.prototype.subscribe = function () {
        return innerSubscribe_1.innerSubscribe(this.observable, new innerSubscribe_1.SimpleInnerSubscriber(this));
    };
    return ZipBufferIterator;
}(innerSubscribe_1.SimpleOuterSubscriber));

},{"../../internal/symbol/iterator":194,"../Subscriber":40,"../innerSubscribe":43,"../util/isArray":206,"./fromArray":54}],72:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var innerSubscribe_1 = require("../innerSubscribe");
function audit(durationSelector) {
    return function auditOperatorFunction(source) {
        return source.lift(new AuditOperator(durationSelector));
    };
}
exports.audit = audit;
var AuditOperator = (function () {
    function AuditOperator(durationSelector) {
        this.durationSelector = durationSelector;
    }
    AuditOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new AuditSubscriber(subscriber, this.durationSelector));
    };
    return AuditOperator;
}());
var AuditSubscriber = (function (_super) {
    __extends(AuditSubscriber, _super);
    function AuditSubscriber(destination, durationSelector) {
        var _this = _super.call(this, destination) || this;
        _this.durationSelector = durationSelector;
        _this.hasValue = false;
        return _this;
    }
    AuditSubscriber.prototype._next = function (value) {
        this.value = value;
        this.hasValue = true;
        if (!this.throttled) {
            var duration = void 0;
            try {
                var durationSelector = this.durationSelector;
                duration = durationSelector(value);
            }
            catch (err) {
                return this.destination.error(err);
            }
            var innerSubscription = innerSubscribe_1.innerSubscribe(duration, new innerSubscribe_1.SimpleInnerSubscriber(this));
            if (!innerSubscription || innerSubscription.closed) {
                this.clearThrottle();
            }
            else {
                this.add(this.throttled = innerSubscription);
            }
        }
    };
    AuditSubscriber.prototype.clearThrottle = function () {
        var _a = this, value = _a.value, hasValue = _a.hasValue, throttled = _a.throttled;
        if (throttled) {
            this.remove(throttled);
            this.throttled = undefined;
            throttled.unsubscribe();
        }
        if (hasValue) {
            this.value = undefined;
            this.hasValue = false;
            this.destination.next(value);
        }
    };
    AuditSubscriber.prototype.notifyNext = function () {
        this.clearThrottle();
    };
    AuditSubscriber.prototype.notifyComplete = function () {
        this.clearThrottle();
    };
    return AuditSubscriber;
}(innerSubscribe_1.SimpleOuterSubscriber));

},{"../innerSubscribe":43}],73:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var async_1 = require("../scheduler/async");
var audit_1 = require("./audit");
var timer_1 = require("../observable/timer");
function auditTime(duration, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return audit_1.audit(function () { return timer_1.timer(duration, scheduler); });
}
exports.auditTime = auditTime;

},{"../observable/timer":69,"../scheduler/async":192,"./audit":72}],74:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var innerSubscribe_1 = require("../innerSubscribe");
function buffer(closingNotifier) {
    return function bufferOperatorFunction(source) {
        return source.lift(new BufferOperator(closingNotifier));
    };
}
exports.buffer = buffer;
var BufferOperator = (function () {
    function BufferOperator(closingNotifier) {
        this.closingNotifier = closingNotifier;
    }
    BufferOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new BufferSubscriber(subscriber, this.closingNotifier));
    };
    return BufferOperator;
}());
var BufferSubscriber = (function (_super) {
    __extends(BufferSubscriber, _super);
    function BufferSubscriber(destination, closingNotifier) {
        var _this = _super.call(this, destination) || this;
        _this.buffer = [];
        _this.add(innerSubscribe_1.innerSubscribe(closingNotifier, new innerSubscribe_1.SimpleInnerSubscriber(_this)));
        return _this;
    }
    BufferSubscriber.prototype._next = function (value) {
        this.buffer.push(value);
    };
    BufferSubscriber.prototype.notifyNext = function () {
        var buffer = this.buffer;
        this.buffer = [];
        this.destination.next(buffer);
    };
    return BufferSubscriber;
}(innerSubscribe_1.SimpleOuterSubscriber));

},{"../innerSubscribe":43}],75:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function bufferCount(bufferSize, startBufferEvery) {
    if (startBufferEvery === void 0) { startBufferEvery = null; }
    return function bufferCountOperatorFunction(source) {
        return source.lift(new BufferCountOperator(bufferSize, startBufferEvery));
    };
}
exports.bufferCount = bufferCount;
var BufferCountOperator = (function () {
    function BufferCountOperator(bufferSize, startBufferEvery) {
        this.bufferSize = bufferSize;
        this.startBufferEvery = startBufferEvery;
        if (!startBufferEvery || bufferSize === startBufferEvery) {
            this.subscriberClass = BufferCountSubscriber;
        }
        else {
            this.subscriberClass = BufferSkipCountSubscriber;
        }
    }
    BufferCountOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new this.subscriberClass(subscriber, this.bufferSize, this.startBufferEvery));
    };
    return BufferCountOperator;
}());
var BufferCountSubscriber = (function (_super) {
    __extends(BufferCountSubscriber, _super);
    function BufferCountSubscriber(destination, bufferSize) {
        var _this = _super.call(this, destination) || this;
        _this.bufferSize = bufferSize;
        _this.buffer = [];
        return _this;
    }
    BufferCountSubscriber.prototype._next = function (value) {
        var buffer = this.buffer;
        buffer.push(value);
        if (buffer.length == this.bufferSize) {
            this.destination.next(buffer);
            this.buffer = [];
        }
    };
    BufferCountSubscriber.prototype._complete = function () {
        var buffer = this.buffer;
        if (buffer.length > 0) {
            this.destination.next(buffer);
        }
        _super.prototype._complete.call(this);
    };
    return BufferCountSubscriber;
}(Subscriber_1.Subscriber));
var BufferSkipCountSubscriber = (function (_super) {
    __extends(BufferSkipCountSubscriber, _super);
    function BufferSkipCountSubscriber(destination, bufferSize, startBufferEvery) {
        var _this = _super.call(this, destination) || this;
        _this.bufferSize = bufferSize;
        _this.startBufferEvery = startBufferEvery;
        _this.buffers = [];
        _this.count = 0;
        return _this;
    }
    BufferSkipCountSubscriber.prototype._next = function (value) {
        var _a = this, bufferSize = _a.bufferSize, startBufferEvery = _a.startBufferEvery, buffers = _a.buffers, count = _a.count;
        this.count++;
        if (count % startBufferEvery === 0) {
            buffers.push([]);
        }
        for (var i = buffers.length; i--;) {
            var buffer = buffers[i];
            buffer.push(value);
            if (buffer.length === bufferSize) {
                buffers.splice(i, 1);
                this.destination.next(buffer);
            }
        }
    };
    BufferSkipCountSubscriber.prototype._complete = function () {
        var _a = this, buffers = _a.buffers, destination = _a.destination;
        while (buffers.length > 0) {
            var buffer = buffers.shift();
            if (buffer.length > 0) {
                destination.next(buffer);
            }
        }
        _super.prototype._complete.call(this);
    };
    return BufferSkipCountSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":40}],76:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var async_1 = require("../scheduler/async");
var Subscriber_1 = require("../Subscriber");
var isScheduler_1 = require("../util/isScheduler");
function bufferTime(bufferTimeSpan) {
    var length = arguments.length;
    var scheduler = async_1.async;
    if (isScheduler_1.isScheduler(arguments[arguments.length - 1])) {
        scheduler = arguments[arguments.length - 1];
        length--;
    }
    var bufferCreationInterval = null;
    if (length >= 2) {
        bufferCreationInterval = arguments[1];
    }
    var maxBufferSize = Number.POSITIVE_INFINITY;
    if (length >= 3) {
        maxBufferSize = arguments[2];
    }
    return function bufferTimeOperatorFunction(source) {
        return source.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));
    };
}
exports.bufferTime = bufferTime;
var BufferTimeOperator = (function () {
    function BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
        this.bufferTimeSpan = bufferTimeSpan;
        this.bufferCreationInterval = bufferCreationInterval;
        this.maxBufferSize = maxBufferSize;
        this.scheduler = scheduler;
    }
    BufferTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));
    };
    return BufferTimeOperator;
}());
var Context = (function () {
    function Context() {
        this.buffer = [];
    }
    return Context;
}());
var BufferTimeSubscriber = (function (_super) {
    __extends(BufferTimeSubscriber, _super);
    function BufferTimeSubscriber(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.bufferTimeSpan = bufferTimeSpan;
        _this.bufferCreationInterval = bufferCreationInterval;
        _this.maxBufferSize = maxBufferSize;
        _this.scheduler = scheduler;
        _this.contexts = [];
        var context = _this.openContext();
        _this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;
        if (_this.timespanOnly) {
            var timeSpanOnlyState = { subscriber: _this, context: context, bufferTimeSpan: bufferTimeSpan };
            _this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
        }
        else {
            var closeState = { subscriber: _this, context: context };
            var creationState = { bufferTimeSpan: bufferTimeSpan, bufferCreationInterval: bufferCreationInterval, subscriber: _this, scheduler: scheduler };
            _this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));
            _this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));
        }
        return _this;
    }
    BufferTimeSubscriber.prototype._next = function (value) {
        var contexts = this.contexts;
        var len = contexts.length;
        var filledBufferContext;
        for (var i = 0; i < len; i++) {
            var context_1 = contexts[i];
            var buffer = context_1.buffer;
            buffer.push(value);
            if (buffer.length == this.maxBufferSize) {
                filledBufferContext = context_1;
            }
        }
        if (filledBufferContext) {
            this.onBufferFull(filledBufferContext);
        }
    };
    BufferTimeSubscriber.prototype._error = function (err) {
        this.contexts.length = 0;
        _super.prototype._error.call(this, err);
    };
    BufferTimeSubscriber.prototype._complete = function () {
        var _a = this, contexts = _a.contexts, destination = _a.destination;
        while (contexts.length > 0) {
            var context_2 = contexts.shift();
            destination.next(context_2.buffer);
        }
        _super.prototype._complete.call(this);
    };
    BufferTimeSubscriber.prototype._unsubscribe = function () {
        this.contexts = null;
    };
    BufferTimeSubscriber.prototype.onBufferFull = function (context) {
        this.closeContext(context);
        var closeAction = context.closeAction;
        closeAction.unsubscribe();
        this.remove(closeAction);
        if (!this.closed && this.timespanOnly) {
            context = this.openContext();
            var bufferTimeSpan = this.bufferTimeSpan;
            var timeSpanOnlyState = { subscriber: this, context: context, bufferTimeSpan: bufferTimeSpan };
            this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
        }
    };
    BufferTimeSubscriber.prototype.openContext = function () {
        var context = new Context();
        this.contexts.push(context);
        return context;
    };
    BufferTimeSubscriber.prototype.closeContext = function (context) {
        this.destination.next(context.buffer);
        var contexts = this.contexts;
        var spliceIndex = contexts ? contexts.indexOf(context) : -1;
        if (spliceIndex >= 0) {
            contexts.splice(contexts.indexOf(context), 1);
        }
    };
    return BufferTimeSubscriber;
}(Subscriber_1.Subscriber));
function dispatchBufferTimeSpanOnly(state) {
    var subscriber = state.subscriber;
    var prevContext = state.context;
    if (prevContext) {
        subscriber.closeContext(prevContext);
    }
    if (!subscriber.closed) {
        state.context = subscriber.openContext();
        state.context.closeAction = this.schedule(state, state.bufferTimeSpan);
    }
}
function dispatchBufferCreation(state) {
    var bufferCreationInterval = state.bufferCreationInterval, bufferTimeSpan = state.bufferTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler;
    var context = subscriber.openContext();
    var action = this;
    if (!subscriber.closed) {
        subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, { subscriber: subscriber, context: context }));
        action.schedule(state, bufferCreationInterval);
    }
}
function dispatchBufferClose(arg) {
    var subscriber = arg.subscriber, context = arg.context;
    subscriber.closeContext(context);
}

},{"../Subscriber":40,"../scheduler/async":192,"../util/isScheduler":216}],77:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscription_1 = require("../Subscription");
var subscribeToResult_1 = require("../util/subscribeToResult");
var OuterSubscriber_1 = require("../OuterSubscriber");
function bufferToggle(openings, closingSelector) {
    return function bufferToggleOperatorFunction(source) {
        return source.lift(new BufferToggleOperator(openings, closingSelector));
    };
}
exports.bufferToggle = bufferToggle;
var BufferToggleOperator = (function () {
    function BufferToggleOperator(openings, closingSelector) {
        this.openings = openings;
        this.closingSelector = closingSelector;
    }
    BufferToggleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new BufferToggleSubscriber(subscriber, this.openings, this.closingSelector));
    };
    return BufferToggleOperator;
}());
var BufferToggleSubscriber = (function (_super) {
    __extends(BufferToggleSubscriber, _super);
    function BufferToggleSubscriber(destination, openings, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.closingSelector = closingSelector;
        _this.contexts = [];
        _this.add(subscribeToResult_1.subscribeToResult(_this, openings));
        return _this;
    }
    BufferToggleSubscriber.prototype._next = function (value) {
        var contexts = this.contexts;
        var len = contexts.length;
        for (var i = 0; i < len; i++) {
            contexts[i].buffer.push(value);
        }
    };
    BufferToggleSubscriber.prototype._error = function (err) {
        var contexts = this.contexts;
        while (contexts.length > 0) {
            var context_1 = contexts.shift();
            context_1.subscription.unsubscribe();
            context_1.buffer = null;
            context_1.subscription = null;
        }
        this.contexts = null;
        _super.prototype._error.call(this, err);
    };
    BufferToggleSubscriber.prototype._complete = function () {
        var contexts = this.contexts;
        while (contexts.length > 0) {
            var context_2 = contexts.shift();
            this.destination.next(context_2.buffer);
            context_2.subscription.unsubscribe();
            context_2.buffer = null;
            context_2.subscription = null;
        }
        this.contexts = null;
        _super.prototype._complete.call(this);
    };
    BufferToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue) {
        outerValue ? this.closeBuffer(outerValue) : this.openBuffer(innerValue);
    };
    BufferToggleSubscriber.prototype.notifyComplete = function (innerSub) {
        this.closeBuffer(innerSub.context);
    };
    BufferToggleSubscriber.prototype.openBuffer = function (value) {
        try {
            var closingSelector = this.closingSelector;
            var closingNotifier = closingSelector.call(this, value);
            if (closingNotifier) {
                this.trySubscribe(closingNotifier);
            }
        }
        catch (err) {
            this._error(err);
        }
    };
    BufferToggleSubscriber.prototype.closeBuffer = function (context) {
        var contexts = this.contexts;
        if (contexts && context) {
            var buffer = context.buffer, subscription = context.subscription;
            this.destination.next(buffer);
            contexts.splice(contexts.indexOf(context), 1);
            this.remove(subscription);
            subscription.unsubscribe();
        }
    };
    BufferToggleSubscriber.prototype.trySubscribe = function (closingNotifier) {
        var contexts = this.contexts;
        var buffer = [];
        var subscription = new Subscription_1.Subscription();
        var context = { buffer: buffer, subscription: subscription };
        contexts.push(context);
        var innerSubscription = subscribeToResult_1.subscribeToResult(this, closingNotifier, context);
        if (!innerSubscription || innerSubscription.closed) {
            this.closeBuffer(context);
        }
        else {
            innerSubscription.context = context;
            this.add(innerSubscription);
            subscription.add(innerSubscription);
        }
    };
    return BufferToggleSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

},{"../OuterSubscriber":35,"../Subscription":41,"../util/subscribeToResult":225}],78:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscription_1 = require("../Subscription");
var innerSubscribe_1 = require("../innerSubscribe");
function bufferWhen(closingSelector) {
    return function (source) {
        return source.lift(new BufferWhenOperator(closingSelector));
    };
}
exports.bufferWhen = bufferWhen;
var BufferWhenOperator = (function () {
    function BufferWhenOperator(closingSelector) {
        this.closingSelector = closingSelector;
    }
    BufferWhenOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new BufferWhenSubscriber(subscriber, this.closingSelector));
    };
    return BufferWhenOperator;
}());
var BufferWhenSubscriber = (function (_super) {
    __extends(BufferWhenSubscriber, _super);
    function BufferWhenSubscriber(destination, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.closingSelector = closingSelector;
        _this.subscribing = false;
        _this.openBuffer();
        return _this;
    }
    BufferWhenSubscriber.prototype._next = function (value) {
        this.buffer.push(value);
    };
    BufferWhenSubscriber.prototype._complete = function () {
        var buffer = this.buffer;
        if (buffer) {
            this.destination.next(buffer);
        }
        _super.prototype._complete.call(this);
    };
    BufferWhenSubscriber.prototype._unsubscribe = function () {
        this.buffer = undefined;
        this.subscribing = false;
    };
    BufferWhenSubscriber.prototype.notifyNext = function () {
        this.openBuffer();
    };
    BufferWhenSubscriber.prototype.notifyComplete = function () {
        if (this.subscribing) {
            this.complete();
        }
        else {
            this.openBuffer();
        }
    };
    BufferWhenSubscriber.prototype.openBuffer = function () {
        var closingSubscription = this.closingSubscription;
        if (closingSubscription) {
            this.remove(closingSubscription);
            closingSubscription.unsubscribe();
        }
        var buffer = this.buffer;
        if (this.buffer) {
            this.destination.next(buffer);
        }
        this.buffer = [];
        var closingNotifier;
        try {
            var closingSelector = this.closingSelector;
            closingNotifier = closingSelector();
        }
        catch (err) {
            return this.error(err);
        }
        closingSubscription = new Subscription_1.Subscription();
        this.closingSubscription = closingSubscription;
        this.add(closingSubscription);
        this.subscribing = true;
        closingSubscription.add(innerSubscribe_1.innerSubscribe(closingNotifier, new innerSubscribe_1.SimpleInnerSubscriber(this)));
        this.subscribing = false;
    };
    return BufferWhenSubscriber;
}(innerSubscribe_1.SimpleOuterSubscriber));

},{"../Subscription":41,"../innerSubscribe":43}],79:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var innerSubscribe_1 = require("../innerSubscribe");
function catchError(selector) {
    return function catchErrorOperatorFunction(source) {
        var operator = new CatchOperator(selector);
        var caught = source.lift(operator);
        return (operator.caught = caught);
    };
}
exports.catchError = catchError;
var CatchOperator = (function () {
    function CatchOperator(selector) {
        this.selector = selector;
    }
    CatchOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));
    };
    return CatchOperator;
}());
var CatchSubscriber = (function (_super) {
    __extends(CatchSubscriber, _super);
    function CatchSubscriber(destination, selector, caught) {
        var _this = _super.call(this, destination) || this;
        _this.selector = selector;
        _this.caught = caught;
        return _this;
    }
    CatchSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var result = void 0;
            try {
                result = this.selector(err, this.caught);
            }
            catch (err2) {
                _super.prototype.error.call(this, err2);
                return;
            }
            this._unsubscribeAndRecycle();
            var innerSubscriber = new innerSubscribe_1.SimpleInnerSubscriber(this);
            this.add(innerSubscriber);
            var innerSubscription = innerSubscribe_1.innerSubscribe(result, innerSubscriber);
            if (innerSubscription !== innerSubscriber) {
                this.add(innerSubscription);
            }
        }
    };
    return CatchSubscriber;
}(innerSubscribe_1.SimpleOuterSubscriber));

},{"../innerSubscribe":43}],80:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var combineLatest_1 = require("../observable/combineLatest");
function combineAll(project) {
    return function (source) { return source.lift(new combineLatest_1.CombineLatestOperator(project)); };
}
exports.combineAll = combineAll;

},{"../observable/combineLatest":48}],81:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var isArray_1 = require("../util/isArray");
var combineLatest_1 = require("../observable/combineLatest");
var from_1 = require("../observable/from");
var none = {};
function combineLatest() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    var project = null;
    if (typeof observables[observables.length - 1] === 'function') {
        project = observables.pop();
    }
    if (observables.length === 1 && isArray_1.isArray(observables[0])) {
        observables = observables[0].slice();
    }
    return function (source) { return source.lift.call(from_1.from([source].concat(observables)), new combineLatest_1.CombineLatestOperator(project)); };
}
exports.combineLatest = combineLatest;

},{"../observable/combineLatest":48,"../observable/from":53,"../util/isArray":206}],82:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var concat_1 = require("../observable/concat");
function concat() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    return function (source) { return source.lift.call(concat_1.concat.apply(void 0, [source].concat(observables))); };
}
exports.concat = concat;

},{"../observable/concat":49}],83:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var mergeAll_1 = require("./mergeAll");
function concatAll() {
    return mergeAll_1.mergeAll(1);
}
exports.concatAll = concatAll;

},{"./mergeAll":116}],84:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var mergeMap_1 = require("./mergeMap");
function concatMap(project, resultSelector) {
    return mergeMap_1.mergeMap(project, resultSelector, 1);
}
exports.concatMap = concatMap;

},{"./mergeMap":117}],85:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var concatMap_1 = require("./concatMap");
function concatMapTo(innerObservable, resultSelector) {
    return concatMap_1.concatMap(function () { return innerObservable; }, resultSelector);
}
exports.concatMapTo = concatMapTo;

},{"./concatMap":84}],86:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function count(predicate) {
    return function (source) { return source.lift(new CountOperator(predicate, source)); };
}
exports.count = count;
var CountOperator = (function () {
    function CountOperator(predicate, source) {
        this.predicate = predicate;
        this.source = source;
    }
    CountOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CountSubscriber(subscriber, this.predicate, this.source));
    };
    return CountOperator;
}());
var CountSubscriber = (function (_super) {
    __extends(CountSubscriber, _super);
    function CountSubscriber(destination, predicate, source) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.source = source;
        _this.count = 0;
        _this.index = 0;
        return _this;
    }
    CountSubscriber.prototype._next = function (value) {
        if (this.predicate) {
            this._tryPredicate(value);
        }
        else {
            this.count++;
        }
    };
    CountSubscriber.prototype._tryPredicate = function (value) {
        var result;
        try {
            result = this.predicate(value, this.index++, this.source);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) {
            this.count++;
        }
    };
    CountSubscriber.prototype._complete = function () {
        this.destination.next(this.count);
        this.destination.complete();
    };
    return CountSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":40}],87:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var innerSubscribe_1 = require("../innerSubscribe");
function debounce(durationSelector) {
    return function (source) { return source.lift(new DebounceOperator(durationSelector)); };
}
exports.debounce = debounce;
var DebounceOperator = (function () {
    function DebounceOperator(durationSelector) {
        this.durationSelector = durationSelector;
    }
    DebounceOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DebounceSubscriber(subscriber, this.durationSelector));
    };
    return DebounceOperator;
}());
var DebounceSubscriber = (function (_super) {
    __extends(DebounceSubscriber, _super);
    function DebounceSubscriber(destination, durationSelector) {
        var _this = _super.call(this, destination) || this;
        _this.durationSelector = durationSelector;
        _this.hasValue = false;
        return _this;
    }
    DebounceSubscriber.prototype._next = function (value) {
        try {
            var result = this.durationSelector.call(this, value);
            if (result) {
                this._tryNext(value, result);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    DebounceSubscriber.prototype._complete = function () {
        this.emitValue();
        this.destination.complete();
    };
    DebounceSubscriber.prototype._tryNext = function (value, duration) {
        var subscription = this.durationSubscription;
        this.value = value;
        this.hasValue = true;
        if (subscription) {
            subscription.unsubscribe();
            this.remove(subscription);
        }
        subscription = innerSubscribe_1.innerSubscribe(duration, new innerSubscribe_1.SimpleInnerSubscriber(this));
        if (subscription && !subscription.closed) {
            this.add(this.durationSubscription = subscription);
        }
    };
    DebounceSubscriber.prototype.notifyNext = function () {
        this.emitValue();
    };
    DebounceSubscriber.prototype.notifyComplete = function () {
        this.emitValue();
    };
    DebounceSubscriber.prototype.emitValue = function () {
        if (this.hasValue) {
            var value = this.value;
            var subscription = this.durationSubscription;
            if (subscription) {
                this.durationSubscription = undefined;
                subscription.unsubscribe();
                this.remove(subscription);
            }
            this.value = undefined;
            this.hasValue = false;
            _super.prototype._next.call(this, value);
        }
    };
    return DebounceSubscriber;
}(innerSubscribe_1.SimpleOuterSubscriber));

},{"../innerSubscribe":43}],88:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
var async_1 = require("../scheduler/async");
function debounceTime(dueTime, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return function (source) { return source.lift(new DebounceTimeOperator(dueTime, scheduler)); };
}
exports.debounceTime = debounceTime;
var DebounceTimeOperator = (function () {
    function DebounceTimeOperator(dueTime, scheduler) {
        this.dueTime = dueTime;
        this.scheduler = scheduler;
    }
    DebounceTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));
    };
    return DebounceTimeOperator;
}());
var DebounceTimeSubscriber = (function (_super) {
    __extends(DebounceTimeSubscriber, _super);
    function DebounceTimeSubscriber(destination, dueTime, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.dueTime = dueTime;
        _this.scheduler = scheduler;
        _this.debouncedSubscription = null;
        _this.lastValue = null;
        _this.hasValue = false;
        return _this;
    }
    DebounceTimeSubscriber.prototype._next = function (value) {
        this.clearDebounce();
        this.lastValue = value;
        this.hasValue = true;
        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));
    };
    DebounceTimeSubscriber.prototype._complete = function () {
        this.debouncedNext();
        this.destination.complete();
    };
    DebounceTimeSubscriber.prototype.debouncedNext = function () {
        this.clearDebounce();
        if (this.hasValue) {
            var lastValue = this.lastValue;
            this.lastValue = null;
            this.hasValue = false;
            this.destination.next(lastValue);
        }
    };
    DebounceTimeSubscriber.prototype.clearDebounce = function () {
        var debouncedSubscription = this.debouncedSubscription;
        if (debouncedSubscription !== null) {
            this.remove(debouncedSubscription);
            debouncedSubscription.unsubscribe();
            this.debouncedSubscription = null;
        }
    };
    return DebounceTimeSubscriber;
}(Subscriber_1.Subscriber));
function dispatchNext(subscriber) {
    subscriber.debouncedNext();
}

},{"../Subscriber":40,"../scheduler/async":192}],89:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function defaultIfEmpty(defaultValue) {
    if (defaultValue === void 0) { defaultValue = null; }
    return function (source) { return source.lift(new DefaultIfEmptyOperator(defaultValue)); };
}
exports.defaultIfEmpty = defaultIfEmpty;
var DefaultIfEmptyOperator = (function () {
    function DefaultIfEmptyOperator(defaultValue) {
        this.defaultValue = defaultValue;
    }
    DefaultIfEmptyOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DefaultIfEmptySubscriber(subscriber, this.defaultValue));
    };
    return DefaultIfEmptyOperator;
}());
var DefaultIfEmptySubscriber = (function (_super) {
    __extends(DefaultIfEmptySubscriber, _super);
    function DefaultIfEmptySubscriber(destination, defaultValue) {
        var _this = _super.call(this, destination) || this;
        _this.defaultValue = defaultValue;
        _this.isEmpty = true;
        return _this;
    }
    DefaultIfEmptySubscriber.prototype._next = function (value) {
        this.isEmpty = false;
        this.destination.next(value);
    };
    DefaultIfEmptySubscriber.prototype._complete = function () {
        if (this.isEmpty) {
            this.destination.next(this.defaultValue);
        }
        this.destination.complete();
    };
    return DefaultIfEmptySubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":40}],90:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var async_1 = require("../scheduler/async");
var isDate_1 = require("../util/isDate");
var Subscriber_1 = require("../Subscriber");
var Notification_1 = require("../Notification");
function delay(delay, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    var absoluteDelay = isDate_1.isDate(delay);
    var delayFor = absoluteDelay ? (+delay - scheduler.now()) : Math.abs(delay);
    return function (source) { return source.lift(new DelayOperator(delayFor, scheduler)); };
}
exports.delay = delay;
var DelayOperator = (function () {
    function DelayOperator(delay, scheduler) {
        this.delay = delay;
        this.scheduler = scheduler;
    }
    DelayOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));
    };
    return DelayOperator;
}());
var DelaySubscriber = (function (_super) {
    __extends(DelaySubscriber, _super);
    function DelaySubscriber(destination, delay, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.delay = delay;
        _this.scheduler = scheduler;
        _this.queue = [];
        _this.active = false;
        _this.errored = false;
        return _this;
    }
    DelaySubscriber.dispatch = function (state) {
        var source = state.source;
        var queue = source.queue;
        var scheduler = state.scheduler;
        var destination = state.destination;
        while (queue.length > 0 && (queue[0].time - scheduler.now()) <= 0) {
            queue.shift().notification.observe(destination);
        }
        if (queue.length > 0) {
            var delay_1 = Math.max(0, queue[0].time - scheduler.now());
            this.schedule(state, delay_1);
        }
        else {
            this.unsubscribe();
            source.active = false;
        }
    };
    DelaySubscriber.prototype._schedule = function (scheduler) {
        this.active = true;
        var destination = this.destination;
        destination.add(scheduler.schedule(DelaySubscriber.dispatch, this.delay, {
            source: this, destination: this.destination, scheduler: scheduler
        }));
    };
    DelaySubscriber.prototype.scheduleNotification = function (notification) {
        if (this.errored === true) {
            return;
        }
        var scheduler = this.scheduler;
        var message = new DelayMessage(scheduler.now() + this.delay, notification);
        this.queue.push(message);
        if (this.active === false) {
            this._schedule(scheduler);
        }
    };
    DelaySubscriber.prototype._next = function (value) {
        this.scheduleNotification(Notification_1.Notification.createNext(value));
    };
    DelaySubscriber.prototype._error = function (err) {
        this.errored = true;
        this.queue = [];
        this.destination.error(err);
        this.unsubscribe();
    };
    DelaySubscriber.prototype._complete = function () {
        this.scheduleNotification(Notification_1.Notification.createComplete());
        this.unsubscribe();
    };
    return DelaySubscriber;
}(Subscriber_1.Subscriber));
var DelayMessage = (function () {
    function DelayMessage(time, notification) {
        this.time = time;
        this.notification = notification;
    }
    return DelayMessage;
}());

},{"../Notification":32,"../Subscriber":40,"../scheduler/async":192,"../util/isDate":208}],91:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
var Observable_1 = require("../Observable");
var OuterSubscriber_1 = require("../OuterSubscriber");
var subscribeToResult_1 = require("../util/subscribeToResult");
function delayWhen(delayDurationSelector, subscriptionDelay) {
    if (subscriptionDelay) {
        return function (source) {
            return new SubscriptionDelayObservable(source, subscriptionDelay)
                .lift(new DelayWhenOperator(delayDurationSelector));
        };
    }
    return function (source) { return source.lift(new DelayWhenOperator(delayDurationSelector)); };
}
exports.delayWhen = delayWhen;
var DelayWhenOperator = (function () {
    function DelayWhenOperator(delayDurationSelector) {
        this.delayDurationSelector = delayDurationSelector;
    }
    DelayWhenOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DelayWhenSubscriber(subscriber, this.delayDurationSelector));
    };
    return DelayWhenOperator;
}());
var DelayWhenSubscriber = (function (_super) {
    __extends(DelayWhenSubscriber, _super);
    function DelayWhenSubscriber(destination, delayDurationSelector) {
        var _this = _super.call(this, destination) || this;
        _this.delayDurationSelector = delayDurationSelector;
        _this.completed = false;
        _this.delayNotifierSubscriptions = [];
        _this.index = 0;
        return _this;
    }
    DelayWhenSubscriber.prototype.notifyNext = function (outerValue, _innerValue, _outerIndex, _innerIndex, innerSub) {
        this.destination.next(outerValue);
        this.removeSubscription(innerSub);
        this.tryComplete();
    };
    DelayWhenSubscriber.prototype.notifyError = function (error, innerSub) {
        this._error(error);
    };
    DelayWhenSubscriber.prototype.notifyComplete = function (innerSub) {
        var value = this.removeSubscription(innerSub);
        if (value) {
            this.destination.next(value);
        }
        this.tryComplete();
    };
    DelayWhenSubscriber.prototype._next = function (value) {
        var index = this.index++;
        try {
            var delayNotifier = this.delayDurationSelector(value, index);
            if (delayNotifier) {
                this.tryDelay(delayNotifier, value);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    DelayWhenSubscriber.prototype._complete = function () {
        this.completed = true;
        this.tryComplete();
        this.unsubscribe();
    };
    DelayWhenSubscriber.prototype.removeSubscription = function (subscription) {
        subscription.unsubscribe();
        var subscriptionIdx = this.delayNotifierSubscriptions.indexOf(subscription);
        if (subscriptionIdx !== -1) {
            this.delayNotifierSubscriptions.splice(subscriptionIdx, 1);
        }
        return subscription.outerValue;
    };
    DelayWhenSubscriber.prototype.tryDelay = function (delayNotifier, value) {
        var notifierSubscription = subscribeToResult_1.subscribeToResult(this, delayNotifier, value);
        if (notifierSubscription && !notifierSubscription.closed) {
            var destination = this.destination;
            destination.add(notifierSubscription);
            this.delayNotifierSubscriptions.push(notifierSubscription);
        }
    };
    DelayWhenSubscriber.prototype.tryComplete = function () {
        if (this.completed && this.delayNotifierSubscriptions.length === 0) {
            this.destination.complete();
        }
    };
    return DelayWhenSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
var SubscriptionDelayObservable = (function (_super) {
    __extends(SubscriptionDelayObservable, _super);
    function SubscriptionDelayObservable(source, subscriptionDelay) {
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.subscriptionDelay = subscriptionDelay;
        return _this;
    }
    SubscriptionDelayObservable.prototype._subscribe = function (subscriber) {
        this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(subscriber, this.source));
    };
    return SubscriptionDelayObservable;
}(Observable_1.Observable));
var SubscriptionDelaySubscriber = (function (_super) {
    __extends(SubscriptionDelaySubscriber, _super);
    function SubscriptionDelaySubscriber(parent, source) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        _this.source = source;
        _this.sourceSubscribed = false;
        return _this;
    }
    SubscriptionDelaySubscriber.prototype._next = function (unused) {
        this.subscribeToSource();
    };
    SubscriptionDelaySubscriber.prototype._error = function (err) {
        this.unsubscribe();
        this.parent.error(err);
    };
    SubscriptionDelaySubscriber.prototype._complete = function () {
        this.unsubscribe();
        this.subscribeToSource();
    };
    SubscriptionDelaySubscriber.prototype.subscribeToSource = function () {
        if (!this.sourceSubscribed) {
            this.sourceSubscribed = true;
            this.unsubscribe();
            this.source.subscribe(this.parent);
        }
    };
    return SubscriptionDelaySubscriber;
}(Subscriber_1.Subscriber));

},{"../Observable":33,"../OuterSubscriber":35,"../Subscriber":40,"../util/subscribeToResult":225}],92:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function dematerialize() {
    return function dematerializeOperatorFunction(source) {
        return source.lift(new DeMaterializeOperator());
    };
}
exports.dematerialize = dematerialize;
var DeMaterializeOperator = (function () {
    function DeMaterializeOperator() {
    }
    DeMaterializeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DeMaterializeSubscriber(subscriber));
    };
    return DeMaterializeOperator;
}());
var DeMaterializeSubscriber = (function (_super) {
    __extends(DeMaterializeSubscriber, _super);
    function DeMaterializeSubscriber(destination) {
        return _super.call(this, destination) || this;
    }
    DeMaterializeSubscriber.prototype._next = function (value) {
        value.observe(this.destination);
    };
    return DeMaterializeSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":40}],93:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var innerSubscribe_1 = require("../innerSubscribe");
function distinct(keySelector, flushes) {
    return function (source) { return source.lift(new DistinctOperator(keySelector, flushes)); };
}
exports.distinct = distinct;
var DistinctOperator = (function () {
    function DistinctOperator(keySelector, flushes) {
        this.keySelector = keySelector;
        this.flushes = flushes;
    }
    DistinctOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DistinctSubscriber(subscriber, this.keySelector, this.flushes));
    };
    return DistinctOperator;
}());
var DistinctSubscriber = (function (_super) {
    __extends(DistinctSubscriber, _super);
    function DistinctSubscriber(destination, keySelector, flushes) {
        var _this = _super.call(this, destination) || this;
        _this.keySelector = keySelector;
        _this.values = new Set();
        if (flushes) {
            _this.add(innerSubscribe_1.innerSubscribe(flushes, new innerSubscribe_1.SimpleInnerSubscriber(_this)));
        }
        return _this;
    }
    DistinctSubscriber.prototype.notifyNext = function () {
        this.values.clear();
    };
    DistinctSubscriber.prototype.notifyError = function (error) {
        this._error(error);
    };
    DistinctSubscriber.prototype._next = function (value) {
        if (this.keySelector) {
            this._useKeySelector(value);
        }
        else {
            this._finalizeNext(value, value);
        }
    };
    DistinctSubscriber.prototype._useKeySelector = function (value) {
        var key;
        var destination = this.destination;
        try {
            key = this.keySelector(value);
        }
        catch (err) {
            destination.error(err);
            return;
        }
        this._finalizeNext(key, value);
    };
    DistinctSubscriber.prototype._finalizeNext = function (key, value) {
        var values = this.values;
        if (!values.has(key)) {
            values.add(key);
            this.destination.next(value);
        }
    };
    return DistinctSubscriber;
}(innerSubscribe_1.SimpleOuterSubscriber));
exports.DistinctSubscriber = DistinctSubscriber;

},{"../innerSubscribe":43}],94:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function distinctUntilChanged(compare, keySelector) {
    return function (source) { return source.lift(new DistinctUntilChangedOperator(compare, keySelector)); };
}
exports.distinctUntilChanged = distinctUntilChanged;
var DistinctUntilChangedOperator = (function () {
    function DistinctUntilChangedOperator(compare, keySelector) {
        this.compare = compare;
        this.keySelector = keySelector;
    }
    DistinctUntilChangedOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
    };
    return DistinctUntilChangedOperator;
}());
var DistinctUntilChangedSubscriber = (function (_super) {
    __extends(DistinctUntilChangedSubscriber, _super);
    function DistinctUntilChangedSubscriber(destination, compare, keySelector) {
        var _this = _super.call(this, destination) || this;
        _this.keySelector = keySelector;
        _this.hasKey = false;
        if (typeof compare === 'function') {
            _this.compare = compare;
        }
        return _this;
    }
    DistinctUntilChangedSubscriber.prototype.compare = function (x, y) {
        return x === y;
    };
    DistinctUntilChangedSubscriber.prototype._next = function (value) {
        var key;
        try {
            var keySelector = this.keySelector;
            key = keySelector ? keySelector(value) : value;
        }
        catch (err) {
            return this.destination.error(err);
        }
        var result = false;
        if (this.hasKey) {
            try {
                var compare = this.compare;
                result = compare(this.key, key);
            }
            catch (err) {
                return this.destination.error(err);
            }
        }
        else {
            this.hasKey = true;
        }
        if (!result) {
            this.key = key;
            this.destination.next(value);
        }
    };
    return DistinctUntilChangedSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":40}],95:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var distinctUntilChanged_1 = require("./distinctUntilChanged");
function distinctUntilKeyChanged(key, compare) {
    return distinctUntilChanged_1.distinctUntilChanged(function (x, y) { return compare ? compare(x[key], y[key]) : x[key] === y[key]; });
}
exports.distinctUntilKeyChanged = distinctUntilKeyChanged;

},{"./distinctUntilChanged":94}],96:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ArgumentOutOfRangeError_1 = require("../util/ArgumentOutOfRangeError");
var filter_1 = require("./filter");
var throwIfEmpty_1 = require("./throwIfEmpty");
var defaultIfEmpty_1 = require("./defaultIfEmpty");
var take_1 = require("./take");
function elementAt(index, defaultValue) {
    if (index < 0) {
        throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError();
    }
    var hasDefaultValue = arguments.length >= 2;
    return function (source) { return source.pipe(filter_1.filter(function (v, i) { return i === index; }), take_1.take(1), hasDefaultValue
        ? defaultIfEmpty_1.defaultIfEmpty(defaultValue)
        : throwIfEmpty_1.throwIfEmpty(function () { return new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError(); })); };
}
exports.elementAt = elementAt;

},{"../util/ArgumentOutOfRangeError":197,"./defaultIfEmpty":89,"./filter":102,"./take":154,"./throwIfEmpty":161}],97:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var concat_1 = require("../observable/concat");
var of_1 = require("../observable/of");
function endWith() {
    var array = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        array[_i] = arguments[_i];
    }
    return function (source) { return concat_1.concat(source, of_1.of.apply(void 0, array)); };
}
exports.endWith = endWith;

},{"../observable/concat":49,"../observable/of":62}],98:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function every(predicate, thisArg) {
    return function (source) { return source.lift(new EveryOperator(predicate, thisArg, source)); };
}
exports.every = every;
var EveryOperator = (function () {
    function EveryOperator(predicate, thisArg, source) {
        this.predicate = predicate;
        this.thisArg = thisArg;
        this.source = source;
    }
    EveryOperator.prototype.call = function (observer, source) {
        return source.subscribe(new EverySubscriber(observer, this.predicate, this.thisArg, this.source));
    };
    return EveryOperator;
}());
var EverySubscriber = (function (_super) {
    __extends(EverySubscriber, _super);
    function EverySubscriber(destination, predicate, thisArg, source) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.thisArg = thisArg;
        _this.source = source;
        _this.index = 0;
        _this.thisArg = thisArg || _this;
        return _this;
    }
    EverySubscriber.prototype.notifyComplete = function (everyValueMatch) {
        this.destination.next(everyValueMatch);
        this.destination.complete();
    };
    EverySubscriber.prototype._next = function (value) {
        var result = false;
        try {
            result = this.predicate.call(this.thisArg, value, this.index++, this.source);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (!result) {
            this.notifyComplete(false);
        }
    };
    EverySubscriber.prototype._complete = function () {
        this.notifyComplete(true);
    };
    return EverySubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":40}],99:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var innerSubscribe_1 = require("../innerSubscribe");
function exhaust() {
    return function (source) { return source.lift(new SwitchFirstOperator()); };
}
exports.exhaust = exhaust;
var SwitchFirstOperator = (function () {
    function SwitchFirstOperator() {
    }
    SwitchFirstOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SwitchFirstSubscriber(subscriber));
    };
    return SwitchFirstOperator;
}());
var SwitchFirstSubscriber = (function (_super) {
    __extends(SwitchFirstSubscriber, _super);
    function SwitchFirstSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.hasCompleted = false;
        _this.hasSubscription = false;
        return _this;
    }
    SwitchFirstSubscriber.prototype._next = function (value) {
        if (!this.hasSubscription) {
            this.hasSubscription = true;
            this.add(innerSubscribe_1.innerSubscribe(value, new innerSubscribe_1.SimpleInnerSubscriber(this)));
        }
    };
    SwitchFirstSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (!this.hasSubscription) {
            this.destination.complete();
        }
    };
    SwitchFirstSubscriber.prototype.notifyComplete = function () {
        this.hasSubscription = false;
        if (this.hasCompleted) {
            this.destination.complete();
        }
    };
    return SwitchFirstSubscriber;
}(innerSubscribe_1.SimpleOuterSubscriber));

},{"../innerSubscribe":43}],100:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var map_1 = require("./map");
var from_1 = require("../observable/from");
var innerSubscribe_1 = require("../innerSubscribe");
function exhaustMap(project, resultSelector) {
    if (resultSelector) {
        return function (source) { return source.pipe(exhaustMap(function (a, i) { return from_1.from(project(a, i)).pipe(map_1.map(function (b, ii) { return resultSelector(a, b, i, ii); })); })); };
    }
    return function (source) {
        return source.lift(new ExhaustMapOperator(project));
    };
}
exports.exhaustMap = exhaustMap;
var ExhaustMapOperator = (function () {
    function ExhaustMapOperator(project) {
        this.project = project;
    }
    ExhaustMapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ExhaustMapSubscriber(subscriber, this.project));
    };
    return ExhaustMapOperator;
}());
var ExhaustMapSubscriber = (function (_super) {
    __extends(ExhaustMapSubscriber, _super);
    function ExhaustMapSubscriber(destination, project) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.hasSubscription = false;
        _this.hasCompleted = false;
        _this.index = 0;
        return _this;
    }
    ExhaustMapSubscriber.prototype._next = function (value) {
        if (!this.hasSubscription) {
            this.tryNext(value);
        }
    };
    ExhaustMapSubscriber.prototype.tryNext = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.hasSubscription = true;
        this._innerSub(result);
    };
    ExhaustMapSubscriber.prototype._innerSub = function (result) {
        var innerSubscriber = new innerSubscribe_1.SimpleInnerSubscriber(this);
        var destination = this.destination;
        destination.add(innerSubscriber);
        var innerSubscription = innerSubscribe_1.innerSubscribe(result, innerSubscriber);
        if (innerSubscription !== innerSubscriber) {
            destination.add(innerSubscription);
        }
    };
    ExhaustMapSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (!this.hasSubscription) {
            this.destination.complete();
        }
        this.unsubscribe();
    };
    ExhaustMapSubscriber.prototype.notifyNext = function (innerValue) {
        this.destination.next(innerValue);
    };
    ExhaustMapSubscriber.prototype.notifyError = function (err) {
        this.destination.error(err);
    };
    ExhaustMapSubscriber.prototype.notifyComplete = function () {
        this.hasSubscription = false;
        if (this.hasCompleted) {
            this.destination.complete();
        }
    };
    return ExhaustMapSubscriber;
}(innerSubscribe_1.SimpleOuterSubscriber));

},{"../innerSubscribe":43,"../observable/from":53,"./map":111}],101:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var innerSubscribe_1 = require("../innerSubscribe");
function expand(project, concurrent, scheduler) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;
    return function (source) { return source.lift(new ExpandOperator(project, concurrent, scheduler)); };
}
exports.expand = expand;
var ExpandOperator = (function () {
    function ExpandOperator(project, concurrent, scheduler) {
        this.project = project;
        this.concurrent = concurrent;
        this.scheduler = scheduler;
    }
    ExpandOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler));
    };
    return ExpandOperator;
}());
exports.ExpandOperator = ExpandOperator;
var ExpandSubscriber = (function (_super) {
    __extends(ExpandSubscriber, _super);
    function ExpandSubscriber(destination, project, concurrent, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.concurrent = concurrent;
        _this.scheduler = scheduler;
        _this.index = 0;
        _this.active = 0;
        _this.hasCompleted = false;
        if (concurrent < Number.POSITIVE_INFINITY) {
            _this.buffer = [];
        }
        return _this;
    }
    ExpandSubscriber.dispatch = function (arg) {
        var subscriber = arg.subscriber, result = arg.result, value = arg.value, index = arg.index;
        subscriber.subscribeToProjection(result, value, index);
    };
    ExpandSubscriber.prototype._next = function (value) {
        var destination = this.destination;
        if (destination.closed) {
            this._complete();
            return;
        }
        var index = this.index++;
        if (this.active < this.concurrent) {
            destination.next(value);
            try {
                var project = this.project;
                var result = project(value, index);
                if (!this.scheduler) {
                    this.subscribeToProjection(result, value, index);
                }
                else {
                    var state = { subscriber: this, result: result, value: value, index: index };
                    var destination_1 = this.destination;
                    destination_1.add(this.scheduler.schedule(ExpandSubscriber.dispatch, 0, state));
                }
            }
            catch (e) {
                destination.error(e);
            }
        }
        else {
            this.buffer.push(value);
        }
    };
    ExpandSubscriber.prototype.subscribeToProjection = function (result, value, index) {
        this.active++;
        var destination = this.destination;
        destination.add(innerSubscribe_1.innerSubscribe(result, new innerSubscribe_1.SimpleInnerSubscriber(this)));
    };
    ExpandSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.hasCompleted && this.active === 0) {
            this.destination.complete();
        }
        this.unsubscribe();
    };
    ExpandSubscriber.prototype.notifyNext = function (innerValue) {
        this._next(innerValue);
    };
    ExpandSubscriber.prototype.notifyComplete = function () {
        var buffer = this.buffer;
        this.active--;
        if (buffer && buffer.length > 0) {
            this._next(buffer.shift());
        }
        if (this.hasCompleted && this.active === 0) {
            this.destination.complete();
        }
    };
    return ExpandSubscriber;
}(innerSubscribe_1.SimpleOuterSubscriber));
exports.ExpandSubscriber = ExpandSubscriber;

},{"../innerSubscribe":43}],102:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function filter(predicate, thisArg) {
    return function filterOperatorFunction(source) {
        return source.lift(new FilterOperator(predicate, thisArg));
    };
}
exports.filter = filter;
var FilterOperator = (function () {
    function FilterOperator(predicate, thisArg) {
        this.predicate = predicate;
        this.thisArg = thisArg;
    }
    FilterOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
    };
    return FilterOperator;
}());
var FilterSubscriber = (function (_super) {
    __extends(FilterSubscriber, _super);
    function FilterSubscriber(destination, predicate, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.thisArg = thisArg;
        _this.count = 0;
        return _this;
    }
    FilterSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.predicate.call(this.thisArg, value, this.count++);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) {
            this.destination.next(value);
        }
    };
    return FilterSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":40}],103:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
var Subscription_1 = require("../Subscription");
function finalize(callback) {
    return function (source) { return source.lift(new FinallyOperator(callback)); };
}
exports.finalize = finalize;
var FinallyOperator = (function () {
    function FinallyOperator(callback) {
        this.callback = callback;
    }
    FinallyOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new FinallySubscriber(subscriber, this.callback));
    };
    return FinallyOperator;
}());
var FinallySubscriber = (function (_super) {
    __extends(FinallySubscriber, _super);
    function FinallySubscriber(destination, callback) {
        var _this = _super.call(this, destination) || this;
        _this.add(new Subscription_1.Subscription(callback));
        return _this;
    }
    return FinallySubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":40,"../Subscription":41}],104:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function find(predicate, thisArg) {
    if (typeof predicate !== 'function') {
        throw new TypeError('predicate is not a function');
    }
    return function (source) { return source.lift(new FindValueOperator(predicate, source, false, thisArg)); };
}
exports.find = find;
var FindValueOperator = (function () {
    function FindValueOperator(predicate, source, yieldIndex, thisArg) {
        this.predicate = predicate;
        this.source = source;
        this.yieldIndex = yieldIndex;
        this.thisArg = thisArg;
    }
    FindValueOperator.prototype.call = function (observer, source) {
        return source.subscribe(new FindValueSubscriber(observer, this.predicate, this.source, this.yieldIndex, this.thisArg));
    };
    return FindValueOperator;
}());
exports.FindValueOperator = FindValueOperator;
var FindValueSubscriber = (function (_super) {
    __extends(FindValueSubscriber, _super);
    function FindValueSubscriber(destination, predicate, source, yieldIndex, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.source = source;
        _this.yieldIndex = yieldIndex;
        _this.thisArg = thisArg;
        _this.index = 0;
        return _this;
    }
    FindValueSubscriber.prototype.notifyComplete = function (value) {
        var destination = this.destination;
        destination.next(value);
        destination.complete();
        this.unsubscribe();
    };
    FindValueSubscriber.prototype._next = function (value) {
        var _a = this, predicate = _a.predicate, thisArg = _a.thisArg;
        var index = this.index++;
        try {
            var result = predicate.call(thisArg || this, value, index, this.source);
            if (result) {
                this.notifyComplete(this.yieldIndex ? index : value);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    FindValueSubscriber.prototype._complete = function () {
        this.notifyComplete(this.yieldIndex ? -1 : undefined);
    };
    return FindValueSubscriber;
}(Subscriber_1.Subscriber));
exports.FindValueSubscriber = FindValueSubscriber;

},{"../Subscriber":40}],105:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var find_1 = require("../operators/find");
function findIndex(predicate, thisArg) {
    return function (source) { return source.lift(new find_1.FindValueOperator(predicate, source, true, thisArg)); };
}
exports.findIndex = findIndex;

},{"../operators/find":104}],106:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var EmptyError_1 = require("../util/EmptyError");
var filter_1 = require("./filter");
var take_1 = require("./take");
var defaultIfEmpty_1 = require("./defaultIfEmpty");
var throwIfEmpty_1 = require("./throwIfEmpty");
var identity_1 = require("../util/identity");
function first(predicate, defaultValue) {
    var hasDefaultValue = arguments.length >= 2;
    return function (source) { return source.pipe(predicate ? filter_1.filter(function (v, i) { return predicate(v, i, source); }) : identity_1.identity, take_1.take(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function () { return new EmptyError_1.EmptyError(); })); };
}
exports.first = first;

},{"../util/EmptyError":198,"../util/identity":205,"./defaultIfEmpty":89,"./filter":102,"./take":154,"./throwIfEmpty":161}],107:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
var Subscription_1 = require("../Subscription");
var Observable_1 = require("../Observable");
var Subject_1 = require("../Subject");
function groupBy(keySelector, elementSelector, durationSelector, subjectSelector) {
    return function (source) {
        return source.lift(new GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector));
    };
}
exports.groupBy = groupBy;
var GroupByOperator = (function () {
    function GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector) {
        this.keySelector = keySelector;
        this.elementSelector = elementSelector;
        this.durationSelector = durationSelector;
        this.subjectSelector = subjectSelector;
    }
    GroupByOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new GroupBySubscriber(subscriber, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));
    };
    return GroupByOperator;
}());
var GroupBySubscriber = (function (_super) {
    __extends(GroupBySubscriber, _super);
    function GroupBySubscriber(destination, keySelector, elementSelector, durationSelector, subjectSelector) {
        var _this = _super.call(this, destination) || this;
        _this.keySelector = keySelector;
        _this.elementSelector = elementSelector;
        _this.durationSelector = durationSelector;
        _this.subjectSelector = subjectSelector;
        _this.groups = null;
        _this.attemptedToUnsubscribe = false;
        _this.count = 0;
        return _this;
    }
    GroupBySubscriber.prototype._next = function (value) {
        var key;
        try {
            key = this.keySelector(value);
        }
        catch (err) {
            this.error(err);
            return;
        }
        this._group(value, key);
    };
    GroupBySubscriber.prototype._group = function (value, key) {
        var groups = this.groups;
        if (!groups) {
            groups = this.groups = new Map();
        }
        var group = groups.get(key);
        var element;
        if (this.elementSelector) {
            try {
                element = this.elementSelector(value);
            }
            catch (err) {
                this.error(err);
            }
        }
        else {
            element = value;
        }
        if (!group) {
            group = (this.subjectSelector ? this.subjectSelector() : new Subject_1.Subject());
            groups.set(key, group);
            var groupedObservable = new GroupedObservable(key, group, this);
            this.destination.next(groupedObservable);
            if (this.durationSelector) {
                var duration = void 0;
                try {
                    duration = this.durationSelector(new GroupedObservable(key, group));
                }
                catch (err) {
                    this.error(err);
                    return;
                }
                this.add(duration.subscribe(new GroupDurationSubscriber(key, group, this)));
            }
        }
        if (!group.closed) {
            group.next(element);
        }
    };
    GroupBySubscriber.prototype._error = function (err) {
        var groups = this.groups;
        if (groups) {
            groups.forEach(function (group, key) {
                group.error(err);
            });
            groups.clear();
        }
        this.destination.error(err);
    };
    GroupBySubscriber.prototype._complete = function () {
        var groups = this.groups;
        if (groups) {
            groups.forEach(function (group, key) {
                group.complete();
            });
            groups.clear();
        }
        this.destination.complete();
    };
    GroupBySubscriber.prototype.removeGroup = function (key) {
        this.groups.delete(key);
    };
    GroupBySubscriber.prototype.unsubscribe = function () {
        if (!this.closed) {
            this.attemptedToUnsubscribe = true;
            if (this.count === 0) {
                _super.prototype.unsubscribe.call(this);
            }
        }
    };
    return GroupBySubscriber;
}(Subscriber_1.Subscriber));
var GroupDurationSubscriber = (function (_super) {
    __extends(GroupDurationSubscriber, _super);
    function GroupDurationSubscriber(key, group, parent) {
        var _this = _super.call(this, group) || this;
        _this.key = key;
        _this.group = group;
        _this.parent = parent;
        return _this;
    }
    GroupDurationSubscriber.prototype._next = function (value) {
        this.complete();
    };
    GroupDurationSubscriber.prototype._unsubscribe = function () {
        var _a = this, parent = _a.parent, key = _a.key;
        this.key = this.parent = null;
        if (parent) {
            parent.removeGroup(key);
        }
    };
    return GroupDurationSubscriber;
}(Subscriber_1.Subscriber));
var GroupedObservable = (function (_super) {
    __extends(GroupedObservable, _super);
    function GroupedObservable(key, groupSubject, refCountSubscription) {
        var _this = _super.call(this) || this;
        _this.key = key;
        _this.groupSubject = groupSubject;
        _this.refCountSubscription = refCountSubscription;
        return _this;
    }
    GroupedObservable.prototype._subscribe = function (subscriber) {
        var subscription = new Subscription_1.Subscription();
        var _a = this, refCountSubscription = _a.refCountSubscription, groupSubject = _a.groupSubject;
        if (refCountSubscription && !refCountSubscription.closed) {
            subscription.add(new InnerRefCountSubscription(refCountSubscription));
        }
        subscription.add(groupSubject.subscribe(subscriber));
        return subscription;
    };
    return GroupedObservable;
}(Observable_1.Observable));
exports.GroupedObservable = GroupedObservable;
var InnerRefCountSubscription = (function (_super) {
    __extends(InnerRefCountSubscription, _super);
    function InnerRefCountSubscription(parent) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        parent.count++;
        return _this;
    }
    InnerRefCountSubscription.prototype.unsubscribe = function () {
        var parent = this.parent;
        if (!parent.closed && !this.closed) {
            _super.prototype.unsubscribe.call(this);
            parent.count -= 1;
            if (parent.count === 0 && parent.attemptedToUnsubscribe) {
                parent.unsubscribe();
            }
        }
    };
    return InnerRefCountSubscription;
}(Subscription_1.Subscription));

},{"../Observable":33,"../Subject":38,"../Subscriber":40,"../Subscription":41}],108:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function ignoreElements() {
    return function ignoreElementsOperatorFunction(source) {
        return source.lift(new IgnoreElementsOperator());
    };
}
exports.ignoreElements = ignoreElements;
var IgnoreElementsOperator = (function () {
    function IgnoreElementsOperator() {
    }
    IgnoreElementsOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new IgnoreElementsSubscriber(subscriber));
    };
    return IgnoreElementsOperator;
}());
var IgnoreElementsSubscriber = (function (_super) {
    __extends(IgnoreElementsSubscriber, _super);
    function IgnoreElementsSubscriber() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    IgnoreElementsSubscriber.prototype._next = function (unused) {
    };
    return IgnoreElementsSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":40}],109:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function isEmpty() {
    return function (source) { return source.lift(new IsEmptyOperator()); };
}
exports.isEmpty = isEmpty;
var IsEmptyOperator = (function () {
    function IsEmptyOperator() {
    }
    IsEmptyOperator.prototype.call = function (observer, source) {
        return source.subscribe(new IsEmptySubscriber(observer));
    };
    return IsEmptyOperator;
}());
var IsEmptySubscriber = (function (_super) {
    __extends(IsEmptySubscriber, _super);
    function IsEmptySubscriber(destination) {
        return _super.call(this, destination) || this;
    }
    IsEmptySubscriber.prototype.notifyComplete = function (isEmpty) {
        var destination = this.destination;
        destination.next(isEmpty);
        destination.complete();
    };
    IsEmptySubscriber.prototype._next = function (value) {
        this.notifyComplete(false);
    };
    IsEmptySubscriber.prototype._complete = function () {
        this.notifyComplete(true);
    };
    return IsEmptySubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":40}],110:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var EmptyError_1 = require("../util/EmptyError");
var filter_1 = require("./filter");
var takeLast_1 = require("./takeLast");
var throwIfEmpty_1 = require("./throwIfEmpty");
var defaultIfEmpty_1 = require("./defaultIfEmpty");
var identity_1 = require("../util/identity");
function last(predicate, defaultValue) {
    var hasDefaultValue = arguments.length >= 2;
    return function (source) { return source.pipe(predicate ? filter_1.filter(function (v, i) { return predicate(v, i, source); }) : identity_1.identity, takeLast_1.takeLast(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function () { return new EmptyError_1.EmptyError(); })); };
}
exports.last = last;

},{"../util/EmptyError":198,"../util/identity":205,"./defaultIfEmpty":89,"./filter":102,"./takeLast":155,"./throwIfEmpty":161}],111:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function map(project, thisArg) {
    return function mapOperation(source) {
        if (typeof project !== 'function') {
            throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
        }
        return source.lift(new MapOperator(project, thisArg));
    };
}
exports.map = map;
var MapOperator = (function () {
    function MapOperator(project, thisArg) {
        this.project = project;
        this.thisArg = thisArg;
    }
    MapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
    };
    return MapOperator;
}());
exports.MapOperator = MapOperator;
var MapSubscriber = (function (_super) {
    __extends(MapSubscriber, _super);
    function MapSubscriber(destination, project, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.count = 0;
        _this.thisArg = thisArg || _this;
        return _this;
    }
    MapSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.project.call(this.thisArg, value, this.count++);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return MapSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":40}],112:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function mapTo(value) {
    return function (source) { return source.lift(new MapToOperator(value)); };
}
exports.mapTo = mapTo;
var MapToOperator = (function () {
    function MapToOperator(value) {
        this.value = value;
    }
    MapToOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MapToSubscriber(subscriber, this.value));
    };
    return MapToOperator;
}());
var MapToSubscriber = (function (_super) {
    __extends(MapToSubscriber, _super);
    function MapToSubscriber(destination, value) {
        var _this = _super.call(this, destination) || this;
        _this.value = value;
        return _this;
    }
    MapToSubscriber.prototype._next = function (x) {
        this.destination.next(this.value);
    };
    return MapToSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":40}],113:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
var Notification_1 = require("../Notification");
function materialize() {
    return function materializeOperatorFunction(source) {
        return source.lift(new MaterializeOperator());
    };
}
exports.materialize = materialize;
var MaterializeOperator = (function () {
    function MaterializeOperator() {
    }
    MaterializeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MaterializeSubscriber(subscriber));
    };
    return MaterializeOperator;
}());
var MaterializeSubscriber = (function (_super) {
    __extends(MaterializeSubscriber, _super);
    function MaterializeSubscriber(destination) {
        return _super.call(this, destination) || this;
    }
    MaterializeSubscriber.prototype._next = function (value) {
        this.destination.next(Notification_1.Notification.createNext(value));
    };
    MaterializeSubscriber.prototype._error = function (err) {
        var destination = this.destination;
        destination.next(Notification_1.Notification.createError(err));
        destination.complete();
    };
    MaterializeSubscriber.prototype._complete = function () {
        var destination = this.destination;
        destination.next(Notification_1.Notification.createComplete());
        destination.complete();
    };
    return MaterializeSubscriber;
}(Subscriber_1.Subscriber));

},{"../Notification":32,"../Subscriber":40}],114:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var reduce_1 = require("./reduce");
function max(comparer) {
    var max = (typeof comparer === 'function')
        ? function (x, y) { return comparer(x, y) > 0 ? x : y; }
        : function (x, y) { return x > y ? x : y; };
    return reduce_1.reduce(max);
}
exports.max = max;

},{"./reduce":132}],115:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var merge_1 = require("../observable/merge");
function merge() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    return function (source) { return source.lift.call(merge_1.merge.apply(void 0, [source].concat(observables))); };
}
exports.merge = merge;

},{"../observable/merge":60}],116:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var mergeMap_1 = require("./mergeMap");
var identity_1 = require("../util/identity");
function mergeAll(concurrent) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    return mergeMap_1.mergeMap(identity_1.identity, concurrent);
}
exports.mergeAll = mergeAll;

},{"../util/identity":205,"./mergeMap":117}],117:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var map_1 = require("./map");
var from_1 = require("../observable/from");
var innerSubscribe_1 = require("../innerSubscribe");
function mergeMap(project, resultSelector, concurrent) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    if (typeof resultSelector === 'function') {
        return function (source) { return source.pipe(mergeMap(function (a, i) { return from_1.from(project(a, i)).pipe(map_1.map(function (b, ii) { return resultSelector(a, b, i, ii); })); }, concurrent)); };
    }
    else if (typeof resultSelector === 'number') {
        concurrent = resultSelector;
    }
    return function (source) { return source.lift(new MergeMapOperator(project, concurrent)); };
}
exports.mergeMap = mergeMap;
var MergeMapOperator = (function () {
    function MergeMapOperator(project, concurrent) {
        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
        this.project = project;
        this.concurrent = concurrent;
    }
    MergeMapOperator.prototype.call = function (observer, source) {
        return source.subscribe(new MergeMapSubscriber(observer, this.project, this.concurrent));
    };
    return MergeMapOperator;
}());
exports.MergeMapOperator = MergeMapOperator;
var MergeMapSubscriber = (function (_super) {
    __extends(MergeMapSubscriber, _super);
    function MergeMapSubscriber(destination, project, concurrent) {
        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.concurrent = concurrent;
        _this.hasCompleted = false;
        _this.buffer = [];
        _this.active = 0;
        _this.index = 0;
        return _this;
    }
    MergeMapSubscriber.prototype._next = function (value) {
        if (this.active < this.concurrent) {
            this._tryNext(value);
        }
        else {
            this.buffer.push(value);
        }
    };
    MergeMapSubscriber.prototype._tryNext = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.active++;
        this._innerSub(result);
    };
    MergeMapSubscriber.prototype._innerSub = function (ish) {
        var innerSubscriber = new innerSubscribe_1.SimpleInnerSubscriber(this);
        var destination = this.destination;
        destination.add(innerSubscriber);
        var innerSubscription = innerSubscribe_1.innerSubscribe(ish, innerSubscriber);
        if (innerSubscription !== innerSubscriber) {
            destination.add(innerSubscription);
        }
    };
    MergeMapSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            this.destination.complete();
        }
        this.unsubscribe();
    };
    MergeMapSubscriber.prototype.notifyNext = function (innerValue) {
        this.destination.next(innerValue);
    };
    MergeMapSubscriber.prototype.notifyComplete = function () {
        var buffer = this.buffer;
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        }
        else if (this.active === 0 && this.hasCompleted) {
            this.destination.complete();
        }
    };
    return MergeMapSubscriber;
}(innerSubscribe_1.SimpleOuterSubscriber));
exports.MergeMapSubscriber = MergeMapSubscriber;
exports.flatMap = mergeMap;

},{"../innerSubscribe":43,"../observable/from":53,"./map":111}],118:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var mergeMap_1 = require("./mergeMap");
function mergeMapTo(innerObservable, resultSelector, concurrent) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    if (typeof resultSelector === 'function') {
        return mergeMap_1.mergeMap(function () { return innerObservable; }, resultSelector, concurrent);
    }
    if (typeof resultSelector === 'number') {
        concurrent = resultSelector;
    }
    return mergeMap_1.mergeMap(function () { return innerObservable; }, concurrent);
}
exports.mergeMapTo = mergeMapTo;

},{"./mergeMap":117}],119:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var innerSubscribe_1 = require("../innerSubscribe");
function mergeScan(accumulator, seed, concurrent) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    return function (source) { return source.lift(new MergeScanOperator(accumulator, seed, concurrent)); };
}
exports.mergeScan = mergeScan;
var MergeScanOperator = (function () {
    function MergeScanOperator(accumulator, seed, concurrent) {
        this.accumulator = accumulator;
        this.seed = seed;
        this.concurrent = concurrent;
    }
    MergeScanOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MergeScanSubscriber(subscriber, this.accumulator, this.seed, this.concurrent));
    };
    return MergeScanOperator;
}());
exports.MergeScanOperator = MergeScanOperator;
var MergeScanSubscriber = (function (_super) {
    __extends(MergeScanSubscriber, _super);
    function MergeScanSubscriber(destination, accumulator, acc, concurrent) {
        var _this = _super.call(this, destination) || this;
        _this.accumulator = accumulator;
        _this.acc = acc;
        _this.concurrent = concurrent;
        _this.hasValue = false;
        _this.hasCompleted = false;
        _this.buffer = [];
        _this.active = 0;
        _this.index = 0;
        return _this;
    }
    MergeScanSubscriber.prototype._next = function (value) {
        if (this.active < this.concurrent) {
            var index = this.index++;
            var destination = this.destination;
            var ish = void 0;
            try {
                var accumulator = this.accumulator;
                ish = accumulator(this.acc, value, index);
            }
            catch (e) {
                return destination.error(e);
            }
            this.active++;
            this._innerSub(ish);
        }
        else {
            this.buffer.push(value);
        }
    };
    MergeScanSubscriber.prototype._innerSub = function (ish) {
        var innerSubscriber = new innerSubscribe_1.SimpleInnerSubscriber(this);
        var destination = this.destination;
        destination.add(innerSubscriber);
        var innerSubscription = innerSubscribe_1.innerSubscribe(ish, innerSubscriber);
        if (innerSubscription !== innerSubscriber) {
            destination.add(innerSubscription);
        }
    };
    MergeScanSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            if (this.hasValue === false) {
                this.destination.next(this.acc);
            }
            this.destination.complete();
        }
        this.unsubscribe();
    };
    MergeScanSubscriber.prototype.notifyNext = function (innerValue) {
        var destination = this.destination;
        this.acc = innerValue;
        this.hasValue = true;
        destination.next(innerValue);
    };
    MergeScanSubscriber.prototype.notifyComplete = function () {
        var buffer = this.buffer;
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        }
        else if (this.active === 0 && this.hasCompleted) {
            if (this.hasValue === false) {
                this.destination.next(this.acc);
            }
            this.destination.complete();
        }
    };
    return MergeScanSubscriber;
}(innerSubscribe_1.SimpleOuterSubscriber));
exports.MergeScanSubscriber = MergeScanSubscriber;

},{"../innerSubscribe":43}],120:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var reduce_1 = require("./reduce");
function min(comparer) {
    var min = (typeof comparer === 'function')
        ? function (x, y) { return comparer(x, y) < 0 ? x : y; }
        : function (x, y) { return x < y ? x : y; };
    return reduce_1.reduce(min);
}
exports.min = min;

},{"./reduce":132}],121:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ConnectableObservable_1 = require("../observable/ConnectableObservable");
function multicast(subjectOrSubjectFactory, selector) {
    return function multicastOperatorFunction(source) {
        var subjectFactory;
        if (typeof subjectOrSubjectFactory === 'function') {
            subjectFactory = subjectOrSubjectFactory;
        }
        else {
            subjectFactory = function subjectFactory() {
                return subjectOrSubjectFactory;
            };
        }
        if (typeof selector === 'function') {
            return source.lift(new MulticastOperator(subjectFactory, selector));
        }
        var connectable = Object.create(source, ConnectableObservable_1.connectableObservableDescriptor);
        connectable.source = source;
        connectable.subjectFactory = subjectFactory;
        return connectable;
    };
}
exports.multicast = multicast;
var MulticastOperator = (function () {
    function MulticastOperator(subjectFactory, selector) {
        this.subjectFactory = subjectFactory;
        this.selector = selector;
    }
    MulticastOperator.prototype.call = function (subscriber, source) {
        var selector = this.selector;
        var subject = this.subjectFactory();
        var subscription = selector(subject).subscribe(subscriber);
        subscription.add(source.subscribe(subject));
        return subscription;
    };
    return MulticastOperator;
}());
exports.MulticastOperator = MulticastOperator;

},{"../observable/ConnectableObservable":44}],122:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
var Notification_1 = require("../Notification");
function observeOn(scheduler, delay) {
    if (delay === void 0) { delay = 0; }
    return function observeOnOperatorFunction(source) {
        return source.lift(new ObserveOnOperator(scheduler, delay));
    };
}
exports.observeOn = observeOn;
var ObserveOnOperator = (function () {
    function ObserveOnOperator(scheduler, delay) {
        if (delay === void 0) { delay = 0; }
        this.scheduler = scheduler;
        this.delay = delay;
    }
    ObserveOnOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));
    };
    return ObserveOnOperator;
}());
exports.ObserveOnOperator = ObserveOnOperator;
var ObserveOnSubscriber = (function (_super) {
    __extends(ObserveOnSubscriber, _super);
    function ObserveOnSubscriber(destination, scheduler, delay) {
        if (delay === void 0) { delay = 0; }
        var _this = _super.call(this, destination) || this;
        _this.scheduler = scheduler;
        _this.delay = delay;
        return _this;
    }
    ObserveOnSubscriber.dispatch = function (arg) {
        var notification = arg.notification, destination = arg.destination;
        notification.observe(destination);
        this.unsubscribe();
    };
    ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {
        var destination = this.destination;
        destination.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
    };
    ObserveOnSubscriber.prototype._next = function (value) {
        this.scheduleMessage(Notification_1.Notification.createNext(value));
    };
    ObserveOnSubscriber.prototype._error = function (err) {
        this.scheduleMessage(Notification_1.Notification.createError(err));
        this.unsubscribe();
    };
    ObserveOnSubscriber.prototype._complete = function () {
        this.scheduleMessage(Notification_1.Notification.createComplete());
        this.unsubscribe();
    };
    return ObserveOnSubscriber;
}(Subscriber_1.Subscriber));
exports.ObserveOnSubscriber = ObserveOnSubscriber;
var ObserveOnMessage = (function () {
    function ObserveOnMessage(notification, destination) {
        this.notification = notification;
        this.destination = destination;
    }
    return ObserveOnMessage;
}());
exports.ObserveOnMessage = ObserveOnMessage;

},{"../Notification":32,"../Subscriber":40}],123:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var from_1 = require("../observable/from");
var isArray_1 = require("../util/isArray");
var innerSubscribe_1 = require("../innerSubscribe");
function onErrorResumeNext() {
    var nextSources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        nextSources[_i] = arguments[_i];
    }
    if (nextSources.length === 1 && isArray_1.isArray(nextSources[0])) {
        nextSources = nextSources[0];
    }
    return function (source) { return source.lift(new OnErrorResumeNextOperator(nextSources)); };
}
exports.onErrorResumeNext = onErrorResumeNext;
function onErrorResumeNextStatic() {
    var nextSources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        nextSources[_i] = arguments[_i];
    }
    var source = undefined;
    if (nextSources.length === 1 && isArray_1.isArray(nextSources[0])) {
        nextSources = nextSources[0];
    }
    source = nextSources.shift();
    return from_1.from(source).lift(new OnErrorResumeNextOperator(nextSources));
}
exports.onErrorResumeNextStatic = onErrorResumeNextStatic;
var OnErrorResumeNextOperator = (function () {
    function OnErrorResumeNextOperator(nextSources) {
        this.nextSources = nextSources;
    }
    OnErrorResumeNextOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new OnErrorResumeNextSubscriber(subscriber, this.nextSources));
    };
    return OnErrorResumeNextOperator;
}());
var OnErrorResumeNextSubscriber = (function (_super) {
    __extends(OnErrorResumeNextSubscriber, _super);
    function OnErrorResumeNextSubscriber(destination, nextSources) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.nextSources = nextSources;
        return _this;
    }
    OnErrorResumeNextSubscriber.prototype.notifyError = function () {
        this.subscribeToNextSource();
    };
    OnErrorResumeNextSubscriber.prototype.notifyComplete = function () {
        this.subscribeToNextSource();
    };
    OnErrorResumeNextSubscriber.prototype._error = function (err) {
        this.subscribeToNextSource();
        this.unsubscribe();
    };
    OnErrorResumeNextSubscriber.prototype._complete = function () {
        this.subscribeToNextSource();
        this.unsubscribe();
    };
    OnErrorResumeNextSubscriber.prototype.subscribeToNextSource = function () {
        var next = this.nextSources.shift();
        if (!!next) {
            var innerSubscriber = new innerSubscribe_1.SimpleInnerSubscriber(this);
            var destination = this.destination;
            destination.add(innerSubscriber);
            var innerSubscription = innerSubscribe_1.innerSubscribe(next, innerSubscriber);
            if (innerSubscription !== innerSubscriber) {
                destination.add(innerSubscription);
            }
        }
        else {
            this.destination.complete();
        }
    };
    return OnErrorResumeNextSubscriber;
}(innerSubscribe_1.SimpleOuterSubscriber));

},{"../innerSubscribe":43,"../observable/from":53,"../util/isArray":206}],124:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function pairwise() {
    return function (source) { return source.lift(new PairwiseOperator()); };
}
exports.pairwise = pairwise;
var PairwiseOperator = (function () {
    function PairwiseOperator() {
    }
    PairwiseOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new PairwiseSubscriber(subscriber));
    };
    return PairwiseOperator;
}());
var PairwiseSubscriber = (function (_super) {
    __extends(PairwiseSubscriber, _super);
    function PairwiseSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.hasPrev = false;
        return _this;
    }
    PairwiseSubscriber.prototype._next = function (value) {
        var pair;
        if (this.hasPrev) {
            pair = [this.prev, value];
        }
        else {
            this.hasPrev = true;
        }
        this.prev = value;
        if (pair) {
            this.destination.next(pair);
        }
    };
    return PairwiseSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":40}],125:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var not_1 = require("../util/not");
var filter_1 = require("./filter");
function partition(predicate, thisArg) {
    return function (source) { return [
        filter_1.filter(predicate, thisArg)(source),
        filter_1.filter(not_1.not(predicate, thisArg))(source)
    ]; };
}
exports.partition = partition;

},{"../util/not":218,"./filter":102}],126:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var map_1 = require("./map");
function pluck() {
    var properties = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        properties[_i] = arguments[_i];
    }
    var length = properties.length;
    if (length === 0) {
        throw new Error('list of properties cannot be empty.');
    }
    return function (source) { return map_1.map(plucker(properties, length))(source); };
}
exports.pluck = pluck;
function plucker(props, length) {
    var mapper = function (x) {
        var currentProp = x;
        for (var i = 0; i < length; i++) {
            var p = currentProp != null ? currentProp[props[i]] : undefined;
            if (p !== void 0) {
                currentProp = p;
            }
            else {
                return undefined;
            }
        }
        return currentProp;
    };
    return mapper;
}

},{"./map":111}],127:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Subject_1 = require("../Subject");
var multicast_1 = require("./multicast");
function publish(selector) {
    return selector ?
        multicast_1.multicast(function () { return new Subject_1.Subject(); }, selector) :
        multicast_1.multicast(new Subject_1.Subject());
}
exports.publish = publish;

},{"../Subject":38,"./multicast":121}],128:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var BehaviorSubject_1 = require("../BehaviorSubject");
var multicast_1 = require("./multicast");
function publishBehavior(value) {
    return function (source) { return multicast_1.multicast(new BehaviorSubject_1.BehaviorSubject(value))(source); };
}
exports.publishBehavior = publishBehavior;

},{"../BehaviorSubject":30,"./multicast":121}],129:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var AsyncSubject_1 = require("../AsyncSubject");
var multicast_1 = require("./multicast");
function publishLast() {
    return function (source) { return multicast_1.multicast(new AsyncSubject_1.AsyncSubject())(source); };
}
exports.publishLast = publishLast;

},{"../AsyncSubject":29,"./multicast":121}],130:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ReplaySubject_1 = require("../ReplaySubject");
var multicast_1 = require("./multicast");
function publishReplay(bufferSize, windowTime, selectorOrScheduler, scheduler) {
    if (selectorOrScheduler && typeof selectorOrScheduler !== 'function') {
        scheduler = selectorOrScheduler;
    }
    var selector = typeof selectorOrScheduler === 'function' ? selectorOrScheduler : undefined;
    var subject = new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, scheduler);
    return function (source) { return multicast_1.multicast(function () { return subject; }, selector)(source); };
}
exports.publishReplay = publishReplay;

},{"../ReplaySubject":36,"./multicast":121}],131:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var isArray_1 = require("../util/isArray");
var race_1 = require("../observable/race");
function race() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    return function raceOperatorFunction(source) {
        if (observables.length === 1 && isArray_1.isArray(observables[0])) {
            observables = observables[0];
        }
        return source.lift.call(race_1.race.apply(void 0, [source].concat(observables)));
    };
}
exports.race = race;

},{"../observable/race":66,"../util/isArray":206}],132:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var scan_1 = require("./scan");
var takeLast_1 = require("./takeLast");
var defaultIfEmpty_1 = require("./defaultIfEmpty");
var pipe_1 = require("../util/pipe");
function reduce(accumulator, seed) {
    if (arguments.length >= 2) {
        return function reduceOperatorFunctionWithSeed(source) {
            return pipe_1.pipe(scan_1.scan(accumulator, seed), takeLast_1.takeLast(1), defaultIfEmpty_1.defaultIfEmpty(seed))(source);
        };
    }
    return function reduceOperatorFunction(source) {
        return pipe_1.pipe(scan_1.scan(function (acc, value, index) { return accumulator(acc, value, index + 1); }), takeLast_1.takeLast(1))(source);
    };
}
exports.reduce = reduce;

},{"../util/pipe":219,"./defaultIfEmpty":89,"./scan":140,"./takeLast":155}],133:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function refCount() {
    return function refCountOperatorFunction(source) {
        return source.lift(new RefCountOperator(source));
    };
}
exports.refCount = refCount;
var RefCountOperator = (function () {
    function RefCountOperator(connectable) {
        this.connectable = connectable;
    }
    RefCountOperator.prototype.call = function (subscriber, source) {
        var connectable = this.connectable;
        connectable._refCount++;
        var refCounter = new RefCountSubscriber(subscriber, connectable);
        var subscription = source.subscribe(refCounter);
        if (!refCounter.closed) {
            refCounter.connection = connectable.connect();
        }
        return subscription;
    };
    return RefCountOperator;
}());
var RefCountSubscriber = (function (_super) {
    __extends(RefCountSubscriber, _super);
    function RefCountSubscriber(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
    }
    RefCountSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (!connectable) {
            this.connection = null;
            return;
        }
        this.connectable = null;
        var refCount = connectable._refCount;
        if (refCount <= 0) {
            this.connection = null;
            return;
        }
        connectable._refCount = refCount - 1;
        if (refCount > 1) {
            this.connection = null;
            return;
        }
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) {
            sharedConnection.unsubscribe();
        }
    };
    return RefCountSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":40}],134:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
var empty_1 = require("../observable/empty");
function repeat(count) {
    if (count === void 0) { count = -1; }
    return function (source) {
        if (count === 0) {
            return empty_1.empty();
        }
        else if (count < 0) {
            return source.lift(new RepeatOperator(-1, source));
        }
        else {
            return source.lift(new RepeatOperator(count - 1, source));
        }
    };
}
exports.repeat = repeat;
var RepeatOperator = (function () {
    function RepeatOperator(count, source) {
        this.count = count;
        this.source = source;
    }
    RepeatOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RepeatSubscriber(subscriber, this.count, this.source));
    };
    return RepeatOperator;
}());
var RepeatSubscriber = (function (_super) {
    __extends(RepeatSubscriber, _super);
    function RepeatSubscriber(destination, count, source) {
        var _this = _super.call(this, destination) || this;
        _this.count = count;
        _this.source = source;
        return _this;
    }
    RepeatSubscriber.prototype.complete = function () {
        if (!this.isStopped) {
            var _a = this, source = _a.source, count = _a.count;
            if (count === 0) {
                return _super.prototype.complete.call(this);
            }
            else if (count > -1) {
                this.count = count - 1;
            }
            source.subscribe(this._unsubscribeAndRecycle());
        }
    };
    return RepeatSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":40,"../observable/empty":51}],135:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subject_1 = require("../Subject");
var innerSubscribe_1 = require("../innerSubscribe");
function repeatWhen(notifier) {
    return function (source) { return source.lift(new RepeatWhenOperator(notifier)); };
}
exports.repeatWhen = repeatWhen;
var RepeatWhenOperator = (function () {
    function RepeatWhenOperator(notifier) {
        this.notifier = notifier;
    }
    RepeatWhenOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RepeatWhenSubscriber(subscriber, this.notifier, source));
    };
    return RepeatWhenOperator;
}());
var RepeatWhenSubscriber = (function (_super) {
    __extends(RepeatWhenSubscriber, _super);
    function RepeatWhenSubscriber(destination, notifier, source) {
        var _this = _super.call(this, destination) || this;
        _this.notifier = notifier;
        _this.source = source;
        _this.sourceIsBeingSubscribedTo = true;
        return _this;
    }
    RepeatWhenSubscriber.prototype.notifyNext = function () {
        this.sourceIsBeingSubscribedTo = true;
        this.source.subscribe(this);
    };
    RepeatWhenSubscriber.prototype.notifyComplete = function () {
        if (this.sourceIsBeingSubscribedTo === false) {
            return _super.prototype.complete.call(this);
        }
    };
    RepeatWhenSubscriber.prototype.complete = function () {
        this.sourceIsBeingSubscribedTo = false;
        if (!this.isStopped) {
            if (!this.retries) {
                this.subscribeToRetries();
            }
            if (!this.retriesSubscription || this.retriesSubscription.closed) {
                return _super.prototype.complete.call(this);
            }
            this._unsubscribeAndRecycle();
            this.notifications.next(undefined);
        }
    };
    RepeatWhenSubscriber.prototype._unsubscribe = function () {
        var _a = this, notifications = _a.notifications, retriesSubscription = _a.retriesSubscription;
        if (notifications) {
            notifications.unsubscribe();
            this.notifications = undefined;
        }
        if (retriesSubscription) {
            retriesSubscription.unsubscribe();
            this.retriesSubscription = undefined;
        }
        this.retries = undefined;
    };
    RepeatWhenSubscriber.prototype._unsubscribeAndRecycle = function () {
        var _unsubscribe = this._unsubscribe;
        this._unsubscribe = null;
        _super.prototype._unsubscribeAndRecycle.call(this);
        this._unsubscribe = _unsubscribe;
        return this;
    };
    RepeatWhenSubscriber.prototype.subscribeToRetries = function () {
        this.notifications = new Subject_1.Subject();
        var retries;
        try {
            var notifier = this.notifier;
            retries = notifier(this.notifications);
        }
        catch (e) {
            return _super.prototype.complete.call(this);
        }
        this.retries = retries;
        this.retriesSubscription = innerSubscribe_1.innerSubscribe(retries, new innerSubscribe_1.SimpleInnerSubscriber(this));
    };
    return RepeatWhenSubscriber;
}(innerSubscribe_1.SimpleOuterSubscriber));

},{"../Subject":38,"../innerSubscribe":43}],136:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function retry(count) {
    if (count === void 0) { count = -1; }
    return function (source) { return source.lift(new RetryOperator(count, source)); };
}
exports.retry = retry;
var RetryOperator = (function () {
    function RetryOperator(count, source) {
        this.count = count;
        this.source = source;
    }
    RetryOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RetrySubscriber(subscriber, this.count, this.source));
    };
    return RetryOperator;
}());
var RetrySubscriber = (function (_super) {
    __extends(RetrySubscriber, _super);
    function RetrySubscriber(destination, count, source) {
        var _this = _super.call(this, destination) || this;
        _this.count = count;
        _this.source = source;
        return _this;
    }
    RetrySubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var _a = this, source = _a.source, count = _a.count;
            if (count === 0) {
                return _super.prototype.error.call(this, err);
            }
            else if (count > -1) {
                this.count = count - 1;
            }
            source.subscribe(this._unsubscribeAndRecycle());
        }
    };
    return RetrySubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":40}],137:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subject_1 = require("../Subject");
var innerSubscribe_1 = require("../innerSubscribe");
function retryWhen(notifier) {
    return function (source) { return source.lift(new RetryWhenOperator(notifier, source)); };
}
exports.retryWhen = retryWhen;
var RetryWhenOperator = (function () {
    function RetryWhenOperator(notifier, source) {
        this.notifier = notifier;
        this.source = source;
    }
    RetryWhenOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RetryWhenSubscriber(subscriber, this.notifier, this.source));
    };
    return RetryWhenOperator;
}());
var RetryWhenSubscriber = (function (_super) {
    __extends(RetryWhenSubscriber, _super);
    function RetryWhenSubscriber(destination, notifier, source) {
        var _this = _super.call(this, destination) || this;
        _this.notifier = notifier;
        _this.source = source;
        return _this;
    }
    RetryWhenSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var errors = this.errors;
            var retries = this.retries;
            var retriesSubscription = this.retriesSubscription;
            if (!retries) {
                errors = new Subject_1.Subject();
                try {
                    var notifier = this.notifier;
                    retries = notifier(errors);
                }
                catch (e) {
                    return _super.prototype.error.call(this, e);
                }
                retriesSubscription = innerSubscribe_1.innerSubscribe(retries, new innerSubscribe_1.SimpleInnerSubscriber(this));
            }
            else {
                this.errors = undefined;
                this.retriesSubscription = undefined;
            }
            this._unsubscribeAndRecycle();
            this.errors = errors;
            this.retries = retries;
            this.retriesSubscription = retriesSubscription;
            errors.next(err);
        }
    };
    RetryWhenSubscriber.prototype._unsubscribe = function () {
        var _a = this, errors = _a.errors, retriesSubscription = _a.retriesSubscription;
        if (errors) {
            errors.unsubscribe();
            this.errors = undefined;
        }
        if (retriesSubscription) {
            retriesSubscription.unsubscribe();
            this.retriesSubscription = undefined;
        }
        this.retries = undefined;
    };
    RetryWhenSubscriber.prototype.notifyNext = function () {
        var _unsubscribe = this._unsubscribe;
        this._unsubscribe = null;
        this._unsubscribeAndRecycle();
        this._unsubscribe = _unsubscribe;
        this.source.subscribe(this);
    };
    return RetryWhenSubscriber;
}(innerSubscribe_1.SimpleOuterSubscriber));

},{"../Subject":38,"../innerSubscribe":43}],138:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var innerSubscribe_1 = require("../innerSubscribe");
function sample(notifier) {
    return function (source) { return source.lift(new SampleOperator(notifier)); };
}
exports.sample = sample;
var SampleOperator = (function () {
    function SampleOperator(notifier) {
        this.notifier = notifier;
    }
    SampleOperator.prototype.call = function (subscriber, source) {
        var sampleSubscriber = new SampleSubscriber(subscriber);
        var subscription = source.subscribe(sampleSubscriber);
        subscription.add(innerSubscribe_1.innerSubscribe(this.notifier, new innerSubscribe_1.SimpleInnerSubscriber(sampleSubscriber)));
        return subscription;
    };
    return SampleOperator;
}());
var SampleSubscriber = (function (_super) {
    __extends(SampleSubscriber, _super);
    function SampleSubscriber() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.hasValue = false;
        return _this;
    }
    SampleSubscriber.prototype._next = function (value) {
        this.value = value;
        this.hasValue = true;
    };
    SampleSubscriber.prototype.notifyNext = function () {
        this.emitValue();
    };
    SampleSubscriber.prototype.notifyComplete = function () {
        this.emitValue();
    };
    SampleSubscriber.prototype.emitValue = function () {
        if (this.hasValue) {
            this.hasValue = false;
            this.destination.next(this.value);
        }
    };
    return SampleSubscriber;
}(innerSubscribe_1.SimpleOuterSubscriber));

},{"../innerSubscribe":43}],139:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
var async_1 = require("../scheduler/async");
function sampleTime(period, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return function (source) { return source.lift(new SampleTimeOperator(period, scheduler)); };
}
exports.sampleTime = sampleTime;
var SampleTimeOperator = (function () {
    function SampleTimeOperator(period, scheduler) {
        this.period = period;
        this.scheduler = scheduler;
    }
    SampleTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SampleTimeSubscriber(subscriber, this.period, this.scheduler));
    };
    return SampleTimeOperator;
}());
var SampleTimeSubscriber = (function (_super) {
    __extends(SampleTimeSubscriber, _super);
    function SampleTimeSubscriber(destination, period, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.period = period;
        _this.scheduler = scheduler;
        _this.hasValue = false;
        _this.add(scheduler.schedule(dispatchNotification, period, { subscriber: _this, period: period }));
        return _this;
    }
    SampleTimeSubscriber.prototype._next = function (value) {
        this.lastValue = value;
        this.hasValue = true;
    };
    SampleTimeSubscriber.prototype.notifyNext = function () {
        if (this.hasValue) {
            this.hasValue = false;
            this.destination.next(this.lastValue);
        }
    };
    return SampleTimeSubscriber;
}(Subscriber_1.Subscriber));
function dispatchNotification(state) {
    var subscriber = state.subscriber, period = state.period;
    subscriber.notifyNext();
    this.schedule(state, period);
}

},{"../Subscriber":40,"../scheduler/async":192}],140:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function scan(accumulator, seed) {
    var hasSeed = false;
    if (arguments.length >= 2) {
        hasSeed = true;
    }
    return function scanOperatorFunction(source) {
        return source.lift(new ScanOperator(accumulator, seed, hasSeed));
    };
}
exports.scan = scan;
var ScanOperator = (function () {
    function ScanOperator(accumulator, seed, hasSeed) {
        if (hasSeed === void 0) { hasSeed = false; }
        this.accumulator = accumulator;
        this.seed = seed;
        this.hasSeed = hasSeed;
    }
    ScanOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));
    };
    return ScanOperator;
}());
var ScanSubscriber = (function (_super) {
    __extends(ScanSubscriber, _super);
    function ScanSubscriber(destination, accumulator, _seed, hasSeed) {
        var _this = _super.call(this, destination) || this;
        _this.accumulator = accumulator;
        _this._seed = _seed;
        _this.hasSeed = hasSeed;
        _this.index = 0;
        return _this;
    }
    Object.defineProperty(ScanSubscriber.prototype, "seed", {
        get: function () {
            return this._seed;
        },
        set: function (value) {
            this.hasSeed = true;
            this._seed = value;
        },
        enumerable: true,
        configurable: true
    });
    ScanSubscriber.prototype._next = function (value) {
        if (!this.hasSeed) {
            this.seed = value;
            this.destination.next(value);
        }
        else {
            return this._tryNext(value);
        }
    };
    ScanSubscriber.prototype._tryNext = function (value) {
        var index = this.index++;
        var result;
        try {
            result = this.accumulator(this.seed, value, index);
        }
        catch (err) {
            this.destination.error(err);
        }
        this.seed = result;
        this.destination.next(result);
    };
    return ScanSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":40}],141:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function sequenceEqual(compareTo, comparator) {
    return function (source) { return source.lift(new SequenceEqualOperator(compareTo, comparator)); };
}
exports.sequenceEqual = sequenceEqual;
var SequenceEqualOperator = (function () {
    function SequenceEqualOperator(compareTo, comparator) {
        this.compareTo = compareTo;
        this.comparator = comparator;
    }
    SequenceEqualOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SequenceEqualSubscriber(subscriber, this.compareTo, this.comparator));
    };
    return SequenceEqualOperator;
}());
exports.SequenceEqualOperator = SequenceEqualOperator;
var SequenceEqualSubscriber = (function (_super) {
    __extends(SequenceEqualSubscriber, _super);
    function SequenceEqualSubscriber(destination, compareTo, comparator) {
        var _this = _super.call(this, destination) || this;
        _this.compareTo = compareTo;
        _this.comparator = comparator;
        _this._a = [];
        _this._b = [];
        _this._oneComplete = false;
        _this.destination.add(compareTo.subscribe(new SequenceEqualCompareToSubscriber(destination, _this)));
        return _this;
    }
    SequenceEqualSubscriber.prototype._next = function (value) {
        if (this._oneComplete && this._b.length === 0) {
            this.emit(false);
        }
        else {
            this._a.push(value);
            this.checkValues();
        }
    };
    SequenceEqualSubscriber.prototype._complete = function () {
        if (this._oneComplete) {
            this.emit(this._a.length === 0 && this._b.length === 0);
        }
        else {
            this._oneComplete = true;
        }
        this.unsubscribe();
    };
    SequenceEqualSubscriber.prototype.checkValues = function () {
        var _c = this, _a = _c._a, _b = _c._b, comparator = _c.comparator;
        while (_a.length > 0 && _b.length > 0) {
            var a = _a.shift();
            var b = _b.shift();
            var areEqual = false;
            try {
                areEqual = comparator ? comparator(a, b) : a === b;
            }
            catch (e) {
                this.destination.error(e);
            }
            if (!areEqual) {
                this.emit(false);
            }
        }
    };
    SequenceEqualSubscriber.prototype.emit = function (value) {
        var destination = this.destination;
        destination.next(value);
        destination.complete();
    };
    SequenceEqualSubscriber.prototype.nextB = function (value) {
        if (this._oneComplete && this._a.length === 0) {
            this.emit(false);
        }
        else {
            this._b.push(value);
            this.checkValues();
        }
    };
    SequenceEqualSubscriber.prototype.completeB = function () {
        if (this._oneComplete) {
            this.emit(this._a.length === 0 && this._b.length === 0);
        }
        else {
            this._oneComplete = true;
        }
    };
    return SequenceEqualSubscriber;
}(Subscriber_1.Subscriber));
exports.SequenceEqualSubscriber = SequenceEqualSubscriber;
var SequenceEqualCompareToSubscriber = (function (_super) {
    __extends(SequenceEqualCompareToSubscriber, _super);
    function SequenceEqualCompareToSubscriber(destination, parent) {
        var _this = _super.call(this, destination) || this;
        _this.parent = parent;
        return _this;
    }
    SequenceEqualCompareToSubscriber.prototype._next = function (value) {
        this.parent.nextB(value);
    };
    SequenceEqualCompareToSubscriber.prototype._error = function (err) {
        this.parent.error(err);
        this.unsubscribe();
    };
    SequenceEqualCompareToSubscriber.prototype._complete = function () {
        this.parent.completeB();
        this.unsubscribe();
    };
    return SequenceEqualCompareToSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":40}],142:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var multicast_1 = require("./multicast");
var refCount_1 = require("./refCount");
var Subject_1 = require("../Subject");
function shareSubjectFactory() {
    return new Subject_1.Subject();
}
function share() {
    return function (source) { return refCount_1.refCount()(multicast_1.multicast(shareSubjectFactory)(source)); };
}
exports.share = share;

},{"../Subject":38,"./multicast":121,"./refCount":133}],143:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ReplaySubject_1 = require("../ReplaySubject");
function shareReplay(configOrBufferSize, windowTime, scheduler) {
    var config;
    if (configOrBufferSize && typeof configOrBufferSize === 'object') {
        config = configOrBufferSize;
    }
    else {
        config = {
            bufferSize: configOrBufferSize,
            windowTime: windowTime,
            refCount: false,
            scheduler: scheduler
        };
    }
    return function (source) { return source.lift(shareReplayOperator(config)); };
}
exports.shareReplay = shareReplay;
function shareReplayOperator(_a) {
    var _b = _a.bufferSize, bufferSize = _b === void 0 ? Number.POSITIVE_INFINITY : _b, _c = _a.windowTime, windowTime = _c === void 0 ? Number.POSITIVE_INFINITY : _c, useRefCount = _a.refCount, scheduler = _a.scheduler;
    var subject;
    var refCount = 0;
    var subscription;
    var hasError = false;
    var isComplete = false;
    return function shareReplayOperation(source) {
        refCount++;
        var innerSub;
        if (!subject || hasError) {
            hasError = false;
            subject = new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, scheduler);
            innerSub = subject.subscribe(this);
            subscription = source.subscribe({
                next: function (value) { subject.next(value); },
                error: function (err) {
                    hasError = true;
                    subject.error(err);
                },
                complete: function () {
                    isComplete = true;
                    subscription = undefined;
                    subject.complete();
                },
            });
        }
        else {
            innerSub = subject.subscribe(this);
        }
        this.add(function () {
            refCount--;
            innerSub.unsubscribe();
            if (subscription && !isComplete && useRefCount && refCount === 0) {
                subscription.unsubscribe();
                subscription = undefined;
                subject = undefined;
            }
        });
    };
}

},{"../ReplaySubject":36}],144:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
var EmptyError_1 = require("../util/EmptyError");
function single(predicate) {
    return function (source) { return source.lift(new SingleOperator(predicate, source)); };
}
exports.single = single;
var SingleOperator = (function () {
    function SingleOperator(predicate, source) {
        this.predicate = predicate;
        this.source = source;
    }
    SingleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SingleSubscriber(subscriber, this.predicate, this.source));
    };
    return SingleOperator;
}());
var SingleSubscriber = (function (_super) {
    __extends(SingleSubscriber, _super);
    function SingleSubscriber(destination, predicate, source) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.source = source;
        _this.seenValue = false;
        _this.index = 0;
        return _this;
    }
    SingleSubscriber.prototype.applySingleValue = function (value) {
        if (this.seenValue) {
            this.destination.error('Sequence contains more than one element');
        }
        else {
            this.seenValue = true;
            this.singleValue = value;
        }
    };
    SingleSubscriber.prototype._next = function (value) {
        var index = this.index++;
        if (this.predicate) {
            this.tryNext(value, index);
        }
        else {
            this.applySingleValue(value);
        }
    };
    SingleSubscriber.prototype.tryNext = function (value, index) {
        try {
            if (this.predicate(value, index, this.source)) {
                this.applySingleValue(value);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    SingleSubscriber.prototype._complete = function () {
        var destination = this.destination;
        if (this.index > 0) {
            destination.next(this.seenValue ? this.singleValue : undefined);
            destination.complete();
        }
        else {
            destination.error(new EmptyError_1.EmptyError);
        }
    };
    return SingleSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":40,"../util/EmptyError":198}],145:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function skip(count) {
    return function (source) { return source.lift(new SkipOperator(count)); };
}
exports.skip = skip;
var SkipOperator = (function () {
    function SkipOperator(total) {
        this.total = total;
    }
    SkipOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SkipSubscriber(subscriber, this.total));
    };
    return SkipOperator;
}());
var SkipSubscriber = (function (_super) {
    __extends(SkipSubscriber, _super);
    function SkipSubscriber(destination, total) {
        var _this = _super.call(this, destination) || this;
        _this.total = total;
        _this.count = 0;
        return _this;
    }
    SkipSubscriber.prototype._next = function (x) {
        if (++this.count > this.total) {
            this.destination.next(x);
        }
    };
    return SkipSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":40}],146:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
var ArgumentOutOfRangeError_1 = require("../util/ArgumentOutOfRangeError");
function skipLast(count) {
    return function (source) { return source.lift(new SkipLastOperator(count)); };
}
exports.skipLast = skipLast;
var SkipLastOperator = (function () {
    function SkipLastOperator(_skipCount) {
        this._skipCount = _skipCount;
        if (this._skipCount < 0) {
            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
        }
    }
    SkipLastOperator.prototype.call = function (subscriber, source) {
        if (this._skipCount === 0) {
            return source.subscribe(new Subscriber_1.Subscriber(subscriber));
        }
        else {
            return source.subscribe(new SkipLastSubscriber(subscriber, this._skipCount));
        }
    };
    return SkipLastOperator;
}());
var SkipLastSubscriber = (function (_super) {
    __extends(SkipLastSubscriber, _super);
    function SkipLastSubscriber(destination, _skipCount) {
        var _this = _super.call(this, destination) || this;
        _this._skipCount = _skipCount;
        _this._count = 0;
        _this._ring = new Array(_skipCount);
        return _this;
    }
    SkipLastSubscriber.prototype._next = function (value) {
        var skipCount = this._skipCount;
        var count = this._count++;
        if (count < skipCount) {
            this._ring[count] = value;
        }
        else {
            var currentIndex = count % skipCount;
            var ring = this._ring;
            var oldValue = ring[currentIndex];
            ring[currentIndex] = value;
            this.destination.next(oldValue);
        }
    };
    return SkipLastSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":40,"../util/ArgumentOutOfRangeError":197}],147:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var innerSubscribe_1 = require("../innerSubscribe");
function skipUntil(notifier) {
    return function (source) { return source.lift(new SkipUntilOperator(notifier)); };
}
exports.skipUntil = skipUntil;
var SkipUntilOperator = (function () {
    function SkipUntilOperator(notifier) {
        this.notifier = notifier;
    }
    SkipUntilOperator.prototype.call = function (destination, source) {
        return source.subscribe(new SkipUntilSubscriber(destination, this.notifier));
    };
    return SkipUntilOperator;
}());
var SkipUntilSubscriber = (function (_super) {
    __extends(SkipUntilSubscriber, _super);
    function SkipUntilSubscriber(destination, notifier) {
        var _this = _super.call(this, destination) || this;
        _this.hasValue = false;
        var innerSubscriber = new innerSubscribe_1.SimpleInnerSubscriber(_this);
        _this.add(innerSubscriber);
        _this.innerSubscription = innerSubscriber;
        var innerSubscription = innerSubscribe_1.innerSubscribe(notifier, innerSubscriber);
        if (innerSubscription !== innerSubscriber) {
            _this.add(innerSubscription);
            _this.innerSubscription = innerSubscription;
        }
        return _this;
    }
    SkipUntilSubscriber.prototype._next = function (value) {
        if (this.hasValue) {
            _super.prototype._next.call(this, value);
        }
    };
    SkipUntilSubscriber.prototype.notifyNext = function () {
        this.hasValue = true;
        if (this.innerSubscription) {
            this.innerSubscription.unsubscribe();
        }
    };
    SkipUntilSubscriber.prototype.notifyComplete = function () {
    };
    return SkipUntilSubscriber;
}(innerSubscribe_1.SimpleOuterSubscriber));

},{"../innerSubscribe":43}],148:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function skipWhile(predicate) {
    return function (source) { return source.lift(new SkipWhileOperator(predicate)); };
}
exports.skipWhile = skipWhile;
var SkipWhileOperator = (function () {
    function SkipWhileOperator(predicate) {
        this.predicate = predicate;
    }
    SkipWhileOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SkipWhileSubscriber(subscriber, this.predicate));
    };
    return SkipWhileOperator;
}());
var SkipWhileSubscriber = (function (_super) {
    __extends(SkipWhileSubscriber, _super);
    function SkipWhileSubscriber(destination, predicate) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.skipping = true;
        _this.index = 0;
        return _this;
    }
    SkipWhileSubscriber.prototype._next = function (value) {
        var destination = this.destination;
        if (this.skipping) {
            this.tryCallPredicate(value);
        }
        if (!this.skipping) {
            destination.next(value);
        }
    };
    SkipWhileSubscriber.prototype.tryCallPredicate = function (value) {
        try {
            var result = this.predicate(value, this.index++);
            this.skipping = Boolean(result);
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    return SkipWhileSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":40}],149:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var concat_1 = require("../observable/concat");
var isScheduler_1 = require("../util/isScheduler");
function startWith() {
    var array = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        array[_i] = arguments[_i];
    }
    var scheduler = array[array.length - 1];
    if (isScheduler_1.isScheduler(scheduler)) {
        array.pop();
        return function (source) { return concat_1.concat(array, source, scheduler); };
    }
    else {
        return function (source) { return concat_1.concat(array, source); };
    }
}
exports.startWith = startWith;

},{"../observable/concat":49,"../util/isScheduler":216}],150:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var SubscribeOnObservable_1 = require("../observable/SubscribeOnObservable");
function subscribeOn(scheduler, delay) {
    if (delay === void 0) { delay = 0; }
    return function subscribeOnOperatorFunction(source) {
        return source.lift(new SubscribeOnOperator(scheduler, delay));
    };
}
exports.subscribeOn = subscribeOn;
var SubscribeOnOperator = (function () {
    function SubscribeOnOperator(scheduler, delay) {
        this.scheduler = scheduler;
        this.delay = delay;
    }
    SubscribeOnOperator.prototype.call = function (subscriber, source) {
        return new SubscribeOnObservable_1.SubscribeOnObservable(source, this.delay, this.scheduler).subscribe(subscriber);
    };
    return SubscribeOnOperator;
}());

},{"../observable/SubscribeOnObservable":45}],151:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var switchMap_1 = require("./switchMap");
var identity_1 = require("../util/identity");
function switchAll() {
    return switchMap_1.switchMap(identity_1.identity);
}
exports.switchAll = switchAll;

},{"../util/identity":205,"./switchMap":152}],152:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var map_1 = require("./map");
var from_1 = require("../observable/from");
var innerSubscribe_1 = require("../innerSubscribe");
function switchMap(project, resultSelector) {
    if (typeof resultSelector === 'function') {
        return function (source) { return source.pipe(switchMap(function (a, i) { return from_1.from(project(a, i)).pipe(map_1.map(function (b, ii) { return resultSelector(a, b, i, ii); })); })); };
    }
    return function (source) { return source.lift(new SwitchMapOperator(project)); };
}
exports.switchMap = switchMap;
var SwitchMapOperator = (function () {
    function SwitchMapOperator(project) {
        this.project = project;
    }
    SwitchMapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SwitchMapSubscriber(subscriber, this.project));
    };
    return SwitchMapOperator;
}());
var SwitchMapSubscriber = (function (_super) {
    __extends(SwitchMapSubscriber, _super);
    function SwitchMapSubscriber(destination, project) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.index = 0;
        return _this;
    }
    SwitchMapSubscriber.prototype._next = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        }
        catch (error) {
            this.destination.error(error);
            return;
        }
        this._innerSub(result);
    };
    SwitchMapSubscriber.prototype._innerSub = function (result) {
        var innerSubscription = this.innerSubscription;
        if (innerSubscription) {
            innerSubscription.unsubscribe();
        }
        var innerSubscriber = new innerSubscribe_1.SimpleInnerSubscriber(this);
        var destination = this.destination;
        destination.add(innerSubscriber);
        this.innerSubscription = innerSubscribe_1.innerSubscribe(result, innerSubscriber);
        if (this.innerSubscription !== innerSubscriber) {
            destination.add(this.innerSubscription);
        }
    };
    SwitchMapSubscriber.prototype._complete = function () {
        var innerSubscription = this.innerSubscription;
        if (!innerSubscription || innerSubscription.closed) {
            _super.prototype._complete.call(this);
        }
        this.unsubscribe();
    };
    SwitchMapSubscriber.prototype._unsubscribe = function () {
        this.innerSubscription = undefined;
    };
    SwitchMapSubscriber.prototype.notifyComplete = function () {
        this.innerSubscription = undefined;
        if (this.isStopped) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapSubscriber.prototype.notifyNext = function (innerValue) {
        this.destination.next(innerValue);
    };
    return SwitchMapSubscriber;
}(innerSubscribe_1.SimpleOuterSubscriber));

},{"../innerSubscribe":43,"../observable/from":53,"./map":111}],153:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var switchMap_1 = require("./switchMap");
function switchMapTo(innerObservable, resultSelector) {
    return resultSelector ? switchMap_1.switchMap(function () { return innerObservable; }, resultSelector) : switchMap_1.switchMap(function () { return innerObservable; });
}
exports.switchMapTo = switchMapTo;

},{"./switchMap":152}],154:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
var ArgumentOutOfRangeError_1 = require("../util/ArgumentOutOfRangeError");
var empty_1 = require("../observable/empty");
function take(count) {
    return function (source) {
        if (count === 0) {
            return empty_1.empty();
        }
        else {
            return source.lift(new TakeOperator(count));
        }
    };
}
exports.take = take;
var TakeOperator = (function () {
    function TakeOperator(total) {
        this.total = total;
        if (this.total < 0) {
            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
        }
    }
    TakeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeSubscriber(subscriber, this.total));
    };
    return TakeOperator;
}());
var TakeSubscriber = (function (_super) {
    __extends(TakeSubscriber, _super);
    function TakeSubscriber(destination, total) {
        var _this = _super.call(this, destination) || this;
        _this.total = total;
        _this.count = 0;
        return _this;
    }
    TakeSubscriber.prototype._next = function (value) {
        var total = this.total;
        var count = ++this.count;
        if (count <= total) {
            this.destination.next(value);
            if (count === total) {
                this.destination.complete();
                this.unsubscribe();
            }
        }
    };
    return TakeSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":40,"../observable/empty":51,"../util/ArgumentOutOfRangeError":197}],155:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
var ArgumentOutOfRangeError_1 = require("../util/ArgumentOutOfRangeError");
var empty_1 = require("../observable/empty");
function takeLast(count) {
    return function takeLastOperatorFunction(source) {
        if (count === 0) {
            return empty_1.empty();
        }
        else {
            return source.lift(new TakeLastOperator(count));
        }
    };
}
exports.takeLast = takeLast;
var TakeLastOperator = (function () {
    function TakeLastOperator(total) {
        this.total = total;
        if (this.total < 0) {
            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
        }
    }
    TakeLastOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeLastSubscriber(subscriber, this.total));
    };
    return TakeLastOperator;
}());
var TakeLastSubscriber = (function (_super) {
    __extends(TakeLastSubscriber, _super);
    function TakeLastSubscriber(destination, total) {
        var _this = _super.call(this, destination) || this;
        _this.total = total;
        _this.ring = new Array();
        _this.count = 0;
        return _this;
    }
    TakeLastSubscriber.prototype._next = function (value) {
        var ring = this.ring;
        var total = this.total;
        var count = this.count++;
        if (ring.length < total) {
            ring.push(value);
        }
        else {
            var index = count % total;
            ring[index] = value;
        }
    };
    TakeLastSubscriber.prototype._complete = function () {
        var destination = this.destination;
        var count = this.count;
        if (count > 0) {
            var total = this.count >= this.total ? this.total : this.count;
            var ring = this.ring;
            for (var i = 0; i < total; i++) {
                var idx = (count++) % total;
                destination.next(ring[idx]);
            }
        }
        destination.complete();
    };
    return TakeLastSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":40,"../observable/empty":51,"../util/ArgumentOutOfRangeError":197}],156:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var innerSubscribe_1 = require("../innerSubscribe");
function takeUntil(notifier) {
    return function (source) { return source.lift(new TakeUntilOperator(notifier)); };
}
exports.takeUntil = takeUntil;
var TakeUntilOperator = (function () {
    function TakeUntilOperator(notifier) {
        this.notifier = notifier;
    }
    TakeUntilOperator.prototype.call = function (subscriber, source) {
        var takeUntilSubscriber = new TakeUntilSubscriber(subscriber);
        var notifierSubscription = innerSubscribe_1.innerSubscribe(this.notifier, new innerSubscribe_1.SimpleInnerSubscriber(takeUntilSubscriber));
        if (notifierSubscription && !takeUntilSubscriber.seenValue) {
            takeUntilSubscriber.add(notifierSubscription);
            return source.subscribe(takeUntilSubscriber);
        }
        return takeUntilSubscriber;
    };
    return TakeUntilOperator;
}());
var TakeUntilSubscriber = (function (_super) {
    __extends(TakeUntilSubscriber, _super);
    function TakeUntilSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.seenValue = false;
        return _this;
    }
    TakeUntilSubscriber.prototype.notifyNext = function () {
        this.seenValue = true;
        this.complete();
    };
    TakeUntilSubscriber.prototype.notifyComplete = function () {
    };
    return TakeUntilSubscriber;
}(innerSubscribe_1.SimpleOuterSubscriber));

},{"../innerSubscribe":43}],157:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function takeWhile(predicate, inclusive) {
    if (inclusive === void 0) { inclusive = false; }
    return function (source) {
        return source.lift(new TakeWhileOperator(predicate, inclusive));
    };
}
exports.takeWhile = takeWhile;
var TakeWhileOperator = (function () {
    function TakeWhileOperator(predicate, inclusive) {
        this.predicate = predicate;
        this.inclusive = inclusive;
    }
    TakeWhileOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeWhileSubscriber(subscriber, this.predicate, this.inclusive));
    };
    return TakeWhileOperator;
}());
var TakeWhileSubscriber = (function (_super) {
    __extends(TakeWhileSubscriber, _super);
    function TakeWhileSubscriber(destination, predicate, inclusive) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.inclusive = inclusive;
        _this.index = 0;
        return _this;
    }
    TakeWhileSubscriber.prototype._next = function (value) {
        var destination = this.destination;
        var result;
        try {
            result = this.predicate(value, this.index++);
        }
        catch (err) {
            destination.error(err);
            return;
        }
        this.nextOrComplete(value, result);
    };
    TakeWhileSubscriber.prototype.nextOrComplete = function (value, predicateResult) {
        var destination = this.destination;
        if (Boolean(predicateResult)) {
            destination.next(value);
        }
        else {
            if (this.inclusive) {
                destination.next(value);
            }
            destination.complete();
        }
    };
    return TakeWhileSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":40}],158:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
var noop_1 = require("../util/noop");
var isFunction_1 = require("../util/isFunction");
function tap(nextOrObserver, error, complete) {
    return function tapOperatorFunction(source) {
        return source.lift(new DoOperator(nextOrObserver, error, complete));
    };
}
exports.tap = tap;
var DoOperator = (function () {
    function DoOperator(nextOrObserver, error, complete) {
        this.nextOrObserver = nextOrObserver;
        this.error = error;
        this.complete = complete;
    }
    DoOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TapSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
    };
    return DoOperator;
}());
var TapSubscriber = (function (_super) {
    __extends(TapSubscriber, _super);
    function TapSubscriber(destination, observerOrNext, error, complete) {
        var _this = _super.call(this, destination) || this;
        _this._tapNext = noop_1.noop;
        _this._tapError = noop_1.noop;
        _this._tapComplete = noop_1.noop;
        _this._tapError = error || noop_1.noop;
        _this._tapComplete = complete || noop_1.noop;
        if (isFunction_1.isFunction(observerOrNext)) {
            _this._context = _this;
            _this._tapNext = observerOrNext;
        }
        else if (observerOrNext) {
            _this._context = observerOrNext;
            _this._tapNext = observerOrNext.next || noop_1.noop;
            _this._tapError = observerOrNext.error || noop_1.noop;
            _this._tapComplete = observerOrNext.complete || noop_1.noop;
        }
        return _this;
    }
    TapSubscriber.prototype._next = function (value) {
        try {
            this._tapNext.call(this._context, value);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(value);
    };
    TapSubscriber.prototype._error = function (err) {
        try {
            this._tapError.call(this._context, err);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.error(err);
    };
    TapSubscriber.prototype._complete = function () {
        try {
            this._tapComplete.call(this._context);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        return this.destination.complete();
    };
    return TapSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subscriber":40,"../util/isFunction":209,"../util/noop":217}],159:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var innerSubscribe_1 = require("../innerSubscribe");
exports.defaultThrottleConfig = {
    leading: true,
    trailing: false
};
function throttle(durationSelector, config) {
    if (config === void 0) { config = exports.defaultThrottleConfig; }
    return function (source) { return source.lift(new ThrottleOperator(durationSelector, !!config.leading, !!config.trailing)); };
}
exports.throttle = throttle;
var ThrottleOperator = (function () {
    function ThrottleOperator(durationSelector, leading, trailing) {
        this.durationSelector = durationSelector;
        this.leading = leading;
        this.trailing = trailing;
    }
    ThrottleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ThrottleSubscriber(subscriber, this.durationSelector, this.leading, this.trailing));
    };
    return ThrottleOperator;
}());
var ThrottleSubscriber = (function (_super) {
    __extends(ThrottleSubscriber, _super);
    function ThrottleSubscriber(destination, durationSelector, _leading, _trailing) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.durationSelector = durationSelector;
        _this._leading = _leading;
        _this._trailing = _trailing;
        _this._hasValue = false;
        return _this;
    }
    ThrottleSubscriber.prototype._next = function (value) {
        this._hasValue = true;
        this._sendValue = value;
        if (!this._throttled) {
            if (this._leading) {
                this.send();
            }
            else {
                this.throttle(value);
            }
        }
    };
    ThrottleSubscriber.prototype.send = function () {
        var _a = this, _hasValue = _a._hasValue, _sendValue = _a._sendValue;
        if (_hasValue) {
            this.destination.next(_sendValue);
            this.throttle(_sendValue);
        }
        this._hasValue = false;
        this._sendValue = undefined;
    };
    ThrottleSubscriber.prototype.throttle = function (value) {
        var duration = this.tryDurationSelector(value);
        if (!!duration) {
            this.add(this._throttled = innerSubscribe_1.innerSubscribe(duration, new innerSubscribe_1.SimpleInnerSubscriber(this)));
        }
    };
    ThrottleSubscriber.prototype.tryDurationSelector = function (value) {
        try {
            return this.durationSelector(value);
        }
        catch (err) {
            this.destination.error(err);
            return null;
        }
    };
    ThrottleSubscriber.prototype.throttlingDone = function () {
        var _a = this, _throttled = _a._throttled, _trailing = _a._trailing;
        if (_throttled) {
            _throttled.unsubscribe();
        }
        this._throttled = undefined;
        if (_trailing) {
            this.send();
        }
    };
    ThrottleSubscriber.prototype.notifyNext = function () {
        this.throttlingDone();
    };
    ThrottleSubscriber.prototype.notifyComplete = function () {
        this.throttlingDone();
    };
    return ThrottleSubscriber;
}(innerSubscribe_1.SimpleOuterSubscriber));

},{"../innerSubscribe":43}],160:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
var async_1 = require("../scheduler/async");
var throttle_1 = require("./throttle");
function throttleTime(duration, scheduler, config) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    if (config === void 0) { config = throttle_1.defaultThrottleConfig; }
    return function (source) { return source.lift(new ThrottleTimeOperator(duration, scheduler, config.leading, config.trailing)); };
}
exports.throttleTime = throttleTime;
var ThrottleTimeOperator = (function () {
    function ThrottleTimeOperator(duration, scheduler, leading, trailing) {
        this.duration = duration;
        this.scheduler = scheduler;
        this.leading = leading;
        this.trailing = trailing;
    }
    ThrottleTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler, this.leading, this.trailing));
    };
    return ThrottleTimeOperator;
}());
var ThrottleTimeSubscriber = (function (_super) {
    __extends(ThrottleTimeSubscriber, _super);
    function ThrottleTimeSubscriber(destination, duration, scheduler, leading, trailing) {
        var _this = _super.call(this, destination) || this;
        _this.duration = duration;
        _this.scheduler = scheduler;
        _this.leading = leading;
        _this.trailing = trailing;
        _this._hasTrailingValue = false;
        _this._trailingValue = null;
        return _this;
    }
    ThrottleTimeSubscriber.prototype._next = function (value) {
        if (this.throttled) {
            if (this.trailing) {
                this._trailingValue = value;
                this._hasTrailingValue = true;
            }
        }
        else {
            this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.duration, { subscriber: this }));
            if (this.leading) {
                this.destination.next(value);
            }
            else if (this.trailing) {
                this._trailingValue = value;
                this._hasTrailingValue = true;
            }
        }
    };
    ThrottleTimeSubscriber.prototype._complete = function () {
        if (this._hasTrailingValue) {
            this.destination.next(this._trailingValue);
            this.destination.complete();
        }
        else {
            this.destination.complete();
        }
    };
    ThrottleTimeSubscriber.prototype.clearThrottle = function () {
        var throttled = this.throttled;
        if (throttled) {
            if (this.trailing && this._hasTrailingValue) {
                this.destination.next(this._trailingValue);
                this._trailingValue = null;
                this._hasTrailingValue = false;
            }
            throttled.unsubscribe();
            this.remove(throttled);
            this.throttled = null;
        }
    };
    return ThrottleTimeSubscriber;
}(Subscriber_1.Subscriber));
function dispatchNext(arg) {
    var subscriber = arg.subscriber;
    subscriber.clearThrottle();
}

},{"../Subscriber":40,"../scheduler/async":192,"./throttle":159}],161:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var EmptyError_1 = require("../util/EmptyError");
var Subscriber_1 = require("../Subscriber");
function throwIfEmpty(errorFactory) {
    if (errorFactory === void 0) { errorFactory = defaultErrorFactory; }
    return function (source) {
        return source.lift(new ThrowIfEmptyOperator(errorFactory));
    };
}
exports.throwIfEmpty = throwIfEmpty;
var ThrowIfEmptyOperator = (function () {
    function ThrowIfEmptyOperator(errorFactory) {
        this.errorFactory = errorFactory;
    }
    ThrowIfEmptyOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ThrowIfEmptySubscriber(subscriber, this.errorFactory));
    };
    return ThrowIfEmptyOperator;
}());
var ThrowIfEmptySubscriber = (function (_super) {
    __extends(ThrowIfEmptySubscriber, _super);
    function ThrowIfEmptySubscriber(destination, errorFactory) {
        var _this = _super.call(this, destination) || this;
        _this.errorFactory = errorFactory;
        _this.hasValue = false;
        return _this;
    }
    ThrowIfEmptySubscriber.prototype._next = function (value) {
        this.hasValue = true;
        this.destination.next(value);
    };
    ThrowIfEmptySubscriber.prototype._complete = function () {
        if (!this.hasValue) {
            var err = void 0;
            try {
                err = this.errorFactory();
            }
            catch (e) {
                err = e;
            }
            this.destination.error(err);
        }
        else {
            return this.destination.complete();
        }
    };
    return ThrowIfEmptySubscriber;
}(Subscriber_1.Subscriber));
function defaultErrorFactory() {
    return new EmptyError_1.EmptyError();
}

},{"../Subscriber":40,"../util/EmptyError":198}],162:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var async_1 = require("../scheduler/async");
var scan_1 = require("./scan");
var defer_1 = require("../observable/defer");
var map_1 = require("./map");
function timeInterval(scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return function (source) { return defer_1.defer(function () {
        return source.pipe(scan_1.scan(function (_a, value) {
            var current = _a.current;
            return ({ value: value, current: scheduler.now(), last: current });
        }, { current: scheduler.now(), value: undefined, last: undefined }), map_1.map(function (_a) {
            var current = _a.current, last = _a.last, value = _a.value;
            return new TimeInterval(value, current - last);
        }));
    }); };
}
exports.timeInterval = timeInterval;
var TimeInterval = (function () {
    function TimeInterval(value, interval) {
        this.value = value;
        this.interval = interval;
    }
    return TimeInterval;
}());
exports.TimeInterval = TimeInterval;

},{"../observable/defer":50,"../scheduler/async":192,"./map":111,"./scan":140}],163:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var async_1 = require("../scheduler/async");
var TimeoutError_1 = require("../util/TimeoutError");
var timeoutWith_1 = require("./timeoutWith");
var throwError_1 = require("../observable/throwError");
function timeout(due, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return timeoutWith_1.timeoutWith(due, throwError_1.throwError(new TimeoutError_1.TimeoutError()), scheduler);
}
exports.timeout = timeout;

},{"../observable/throwError":68,"../scheduler/async":192,"../util/TimeoutError":201,"./timeoutWith":164}],164:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var async_1 = require("../scheduler/async");
var isDate_1 = require("../util/isDate");
var innerSubscribe_1 = require("../innerSubscribe");
function timeoutWith(due, withObservable, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return function (source) {
        var absoluteTimeout = isDate_1.isDate(due);
        var waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(due);
        return source.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));
    };
}
exports.timeoutWith = timeoutWith;
var TimeoutWithOperator = (function () {
    function TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler) {
        this.waitFor = waitFor;
        this.absoluteTimeout = absoluteTimeout;
        this.withObservable = withObservable;
        this.scheduler = scheduler;
    }
    TimeoutWithOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));
    };
    return TimeoutWithOperator;
}());
var TimeoutWithSubscriber = (function (_super) {
    __extends(TimeoutWithSubscriber, _super);
    function TimeoutWithSubscriber(destination, absoluteTimeout, waitFor, withObservable, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.absoluteTimeout = absoluteTimeout;
        _this.waitFor = waitFor;
        _this.withObservable = withObservable;
        _this.scheduler = scheduler;
        _this.scheduleTimeout();
        return _this;
    }
    TimeoutWithSubscriber.dispatchTimeout = function (subscriber) {
        var withObservable = subscriber.withObservable;
        subscriber._unsubscribeAndRecycle();
        subscriber.add(innerSubscribe_1.innerSubscribe(withObservable, new innerSubscribe_1.SimpleInnerSubscriber(subscriber)));
    };
    TimeoutWithSubscriber.prototype.scheduleTimeout = function () {
        var action = this.action;
        if (action) {
            this.action = action.schedule(this, this.waitFor);
        }
        else {
            this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber.dispatchTimeout, this.waitFor, this));
        }
    };
    TimeoutWithSubscriber.prototype._next = function (value) {
        if (!this.absoluteTimeout) {
            this.scheduleTimeout();
        }
        _super.prototype._next.call(this, value);
    };
    TimeoutWithSubscriber.prototype._unsubscribe = function () {
        this.action = undefined;
        this.scheduler = null;
        this.withObservable = null;
    };
    return TimeoutWithSubscriber;
}(innerSubscribe_1.SimpleOuterSubscriber));

},{"../innerSubscribe":43,"../scheduler/async":192,"../util/isDate":208}],165:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var async_1 = require("../scheduler/async");
var map_1 = require("./map");
function timestamp(scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return map_1.map(function (value) { return new Timestamp(value, scheduler.now()); });
}
exports.timestamp = timestamp;
var Timestamp = (function () {
    function Timestamp(value, timestamp) {
        this.value = value;
        this.timestamp = timestamp;
    }
    return Timestamp;
}());
exports.Timestamp = Timestamp;

},{"../scheduler/async":192,"./map":111}],166:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var reduce_1 = require("./reduce");
function toArrayReducer(arr, item, index) {
    if (index === 0) {
        return [item];
    }
    arr.push(item);
    return arr;
}
function toArray() {
    return reduce_1.reduce(toArrayReducer, []);
}
exports.toArray = toArray;

},{"./reduce":132}],167:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subject_1 = require("../Subject");
var innerSubscribe_1 = require("../innerSubscribe");
function window(windowBoundaries) {
    return function windowOperatorFunction(source) {
        return source.lift(new WindowOperator(windowBoundaries));
    };
}
exports.window = window;
var WindowOperator = (function () {
    function WindowOperator(windowBoundaries) {
        this.windowBoundaries = windowBoundaries;
    }
    WindowOperator.prototype.call = function (subscriber, source) {
        var windowSubscriber = new WindowSubscriber(subscriber);
        var sourceSubscription = source.subscribe(windowSubscriber);
        if (!sourceSubscription.closed) {
            windowSubscriber.add(innerSubscribe_1.innerSubscribe(this.windowBoundaries, new innerSubscribe_1.SimpleInnerSubscriber(windowSubscriber)));
        }
        return sourceSubscription;
    };
    return WindowOperator;
}());
var WindowSubscriber = (function (_super) {
    __extends(WindowSubscriber, _super);
    function WindowSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.window = new Subject_1.Subject();
        destination.next(_this.window);
        return _this;
    }
    WindowSubscriber.prototype.notifyNext = function () {
        this.openWindow();
    };
    WindowSubscriber.prototype.notifyError = function (error) {
        this._error(error);
    };
    WindowSubscriber.prototype.notifyComplete = function () {
        this._complete();
    };
    WindowSubscriber.prototype._next = function (value) {
        this.window.next(value);
    };
    WindowSubscriber.prototype._error = function (err) {
        this.window.error(err);
        this.destination.error(err);
    };
    WindowSubscriber.prototype._complete = function () {
        this.window.complete();
        this.destination.complete();
    };
    WindowSubscriber.prototype._unsubscribe = function () {
        this.window = null;
    };
    WindowSubscriber.prototype.openWindow = function () {
        var prevWindow = this.window;
        if (prevWindow) {
            prevWindow.complete();
        }
        var destination = this.destination;
        var newWindow = this.window = new Subject_1.Subject();
        destination.next(newWindow);
    };
    return WindowSubscriber;
}(innerSubscribe_1.SimpleOuterSubscriber));

},{"../Subject":38,"../innerSubscribe":43}],168:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
var Subject_1 = require("../Subject");
function windowCount(windowSize, startWindowEvery) {
    if (startWindowEvery === void 0) { startWindowEvery = 0; }
    return function windowCountOperatorFunction(source) {
        return source.lift(new WindowCountOperator(windowSize, startWindowEvery));
    };
}
exports.windowCount = windowCount;
var WindowCountOperator = (function () {
    function WindowCountOperator(windowSize, startWindowEvery) {
        this.windowSize = windowSize;
        this.startWindowEvery = startWindowEvery;
    }
    WindowCountOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WindowCountSubscriber(subscriber, this.windowSize, this.startWindowEvery));
    };
    return WindowCountOperator;
}());
var WindowCountSubscriber = (function (_super) {
    __extends(WindowCountSubscriber, _super);
    function WindowCountSubscriber(destination, windowSize, startWindowEvery) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.windowSize = windowSize;
        _this.startWindowEvery = startWindowEvery;
        _this.windows = [new Subject_1.Subject()];
        _this.count = 0;
        destination.next(_this.windows[0]);
        return _this;
    }
    WindowCountSubscriber.prototype._next = function (value) {
        var startWindowEvery = (this.startWindowEvery > 0) ? this.startWindowEvery : this.windowSize;
        var destination = this.destination;
        var windowSize = this.windowSize;
        var windows = this.windows;
        var len = windows.length;
        for (var i = 0; i < len && !this.closed; i++) {
            windows[i].next(value);
        }
        var c = this.count - windowSize + 1;
        if (c >= 0 && c % startWindowEvery === 0 && !this.closed) {
            windows.shift().complete();
        }
        if (++this.count % startWindowEvery === 0 && !this.closed) {
            var window_1 = new Subject_1.Subject();
            windows.push(window_1);
            destination.next(window_1);
        }
    };
    WindowCountSubscriber.prototype._error = function (err) {
        var windows = this.windows;
        if (windows) {
            while (windows.length > 0 && !this.closed) {
                windows.shift().error(err);
            }
        }
        this.destination.error(err);
    };
    WindowCountSubscriber.prototype._complete = function () {
        var windows = this.windows;
        if (windows) {
            while (windows.length > 0 && !this.closed) {
                windows.shift().complete();
            }
        }
        this.destination.complete();
    };
    WindowCountSubscriber.prototype._unsubscribe = function () {
        this.count = 0;
        this.windows = null;
    };
    return WindowCountSubscriber;
}(Subscriber_1.Subscriber));

},{"../Subject":38,"../Subscriber":40}],169:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subject_1 = require("../Subject");
var async_1 = require("../scheduler/async");
var Subscriber_1 = require("../Subscriber");
var isNumeric_1 = require("../util/isNumeric");
var isScheduler_1 = require("../util/isScheduler");
function windowTime(windowTimeSpan) {
    var scheduler = async_1.async;
    var windowCreationInterval = null;
    var maxWindowSize = Number.POSITIVE_INFINITY;
    if (isScheduler_1.isScheduler(arguments[3])) {
        scheduler = arguments[3];
    }
    if (isScheduler_1.isScheduler(arguments[2])) {
        scheduler = arguments[2];
    }
    else if (isNumeric_1.isNumeric(arguments[2])) {
        maxWindowSize = Number(arguments[2]);
    }
    if (isScheduler_1.isScheduler(arguments[1])) {
        scheduler = arguments[1];
    }
    else if (isNumeric_1.isNumeric(arguments[1])) {
        windowCreationInterval = Number(arguments[1]);
    }
    return function windowTimeOperatorFunction(source) {
        return source.lift(new WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler));
    };
}
exports.windowTime = windowTime;
var WindowTimeOperator = (function () {
    function WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
        this.windowTimeSpan = windowTimeSpan;
        this.windowCreationInterval = windowCreationInterval;
        this.maxWindowSize = maxWindowSize;
        this.scheduler = scheduler;
    }
    WindowTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WindowTimeSubscriber(subscriber, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler));
    };
    return WindowTimeOperator;
}());
var CountedSubject = (function (_super) {
    __extends(CountedSubject, _super);
    function CountedSubject() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._numberOfNextedValues = 0;
        return _this;
    }
    CountedSubject.prototype.next = function (value) {
        this._numberOfNextedValues++;
        _super.prototype.next.call(this, value);
    };
    Object.defineProperty(CountedSubject.prototype, "numberOfNextedValues", {
        get: function () {
            return this._numberOfNextedValues;
        },
        enumerable: true,
        configurable: true
    });
    return CountedSubject;
}(Subject_1.Subject));
var WindowTimeSubscriber = (function (_super) {
    __extends(WindowTimeSubscriber, _super);
    function WindowTimeSubscriber(destination, windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.windowTimeSpan = windowTimeSpan;
        _this.windowCreationInterval = windowCreationInterval;
        _this.maxWindowSize = maxWindowSize;
        _this.scheduler = scheduler;
        _this.windows = [];
        var window = _this.openWindow();
        if (windowCreationInterval !== null && windowCreationInterval >= 0) {
            var closeState = { subscriber: _this, window: window, context: null };
            var creationState = { windowTimeSpan: windowTimeSpan, windowCreationInterval: windowCreationInterval, subscriber: _this, scheduler: scheduler };
            _this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));
            _this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));
        }
        else {
            var timeSpanOnlyState = { subscriber: _this, window: window, windowTimeSpan: windowTimeSpan };
            _this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));
        }
        return _this;
    }
    WindowTimeSubscriber.prototype._next = function (value) {
        var windows = this.windows;
        var len = windows.length;
        for (var i = 0; i < len; i++) {
            var window_1 = windows[i];
            if (!window_1.closed) {
                window_1.next(value);
                if (window_1.numberOfNextedValues >= this.maxWindowSize) {
                    this.closeWindow(window_1);
                }
            }
        }
    };
    WindowTimeSubscriber.prototype._error = function (err) {
        var windows = this.windows;
        while (windows.length > 0) {
            windows.shift().error(err);
        }
        this.destination.error(err);
    };
    WindowTimeSubscriber.prototype._complete = function () {
        var windows = this.windows;
        while (windows.length > 0) {
            var window_2 = windows.shift();
            if (!window_2.closed) {
                window_2.complete();
            }
        }
        this.destination.complete();
    };
    WindowTimeSubscriber.prototype.openWindow = function () {
        var window = new CountedSubject();
        this.windows.push(window);
        var destination = this.destination;
        destination.next(window);
        return window;
    };
    WindowTimeSubscriber.prototype.closeWindow = function (window) {
        window.complete();
        var windows = this.windows;
        windows.splice(windows.indexOf(window), 1);
    };
    return WindowTimeSubscriber;
}(Subscriber_1.Subscriber));
function dispatchWindowTimeSpanOnly(state) {
    var subscriber = state.subscriber, windowTimeSpan = state.windowTimeSpan, window = state.window;
    if (window) {
        subscriber.closeWindow(window);
    }
    state.window = subscriber.openWindow();
    this.schedule(state, windowTimeSpan);
}
function dispatchWindowCreation(state) {
    var windowTimeSpan = state.windowTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler, windowCreationInterval = state.windowCreationInterval;
    var window = subscriber.openWindow();
    var action = this;
    var context = { action: action, subscription: null };
    var timeSpanState = { subscriber: subscriber, window: window, context: context };
    context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);
    action.add(context.subscription);
    action.schedule(state, windowCreationInterval);
}
function dispatchWindowClose(state) {
    var subscriber = state.subscriber, window = state.window, context = state.context;
    if (context && context.action && context.subscription) {
        context.action.remove(context.subscription);
    }
    subscriber.closeWindow(window);
}

},{"../Subject":38,"../Subscriber":40,"../scheduler/async":192,"../util/isNumeric":212,"../util/isScheduler":216}],170:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subject_1 = require("../Subject");
var Subscription_1 = require("../Subscription");
var OuterSubscriber_1 = require("../OuterSubscriber");
var subscribeToResult_1 = require("../util/subscribeToResult");
function windowToggle(openings, closingSelector) {
    return function (source) { return source.lift(new WindowToggleOperator(openings, closingSelector)); };
}
exports.windowToggle = windowToggle;
var WindowToggleOperator = (function () {
    function WindowToggleOperator(openings, closingSelector) {
        this.openings = openings;
        this.closingSelector = closingSelector;
    }
    WindowToggleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WindowToggleSubscriber(subscriber, this.openings, this.closingSelector));
    };
    return WindowToggleOperator;
}());
var WindowToggleSubscriber = (function (_super) {
    __extends(WindowToggleSubscriber, _super);
    function WindowToggleSubscriber(destination, openings, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.openings = openings;
        _this.closingSelector = closingSelector;
        _this.contexts = [];
        _this.add(_this.openSubscription = subscribeToResult_1.subscribeToResult(_this, openings, openings));
        return _this;
    }
    WindowToggleSubscriber.prototype._next = function (value) {
        var contexts = this.contexts;
        if (contexts) {
            var len = contexts.length;
            for (var i = 0; i < len; i++) {
                contexts[i].window.next(value);
            }
        }
    };
    WindowToggleSubscriber.prototype._error = function (err) {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
            var len = contexts.length;
            var index = -1;
            while (++index < len) {
                var context_1 = contexts[index];
                context_1.window.error(err);
                context_1.subscription.unsubscribe();
            }
        }
        _super.prototype._error.call(this, err);
    };
    WindowToggleSubscriber.prototype._complete = function () {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
            var len = contexts.length;
            var index = -1;
            while (++index < len) {
                var context_2 = contexts[index];
                context_2.window.complete();
                context_2.subscription.unsubscribe();
            }
        }
        _super.prototype._complete.call(this);
    };
    WindowToggleSubscriber.prototype._unsubscribe = function () {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
            var len = contexts.length;
            var index = -1;
            while (++index < len) {
                var context_3 = contexts[index];
                context_3.window.unsubscribe();
                context_3.subscription.unsubscribe();
            }
        }
    };
    WindowToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (outerValue === this.openings) {
            var closingNotifier = void 0;
            try {
                var closingSelector = this.closingSelector;
                closingNotifier = closingSelector(innerValue);
            }
            catch (e) {
                return this.error(e);
            }
            var window_1 = new Subject_1.Subject();
            var subscription = new Subscription_1.Subscription();
            var context_4 = { window: window_1, subscription: subscription };
            this.contexts.push(context_4);
            var innerSubscription = subscribeToResult_1.subscribeToResult(this, closingNotifier, context_4);
            if (innerSubscription.closed) {
                this.closeWindow(this.contexts.length - 1);
            }
            else {
                innerSubscription.context = context_4;
                subscription.add(innerSubscription);
            }
            this.destination.next(window_1);
        }
        else {
            this.closeWindow(this.contexts.indexOf(outerValue));
        }
    };
    WindowToggleSubscriber.prototype.notifyError = function (err) {
        this.error(err);
    };
    WindowToggleSubscriber.prototype.notifyComplete = function (inner) {
        if (inner !== this.openSubscription) {
            this.closeWindow(this.contexts.indexOf(inner.context));
        }
    };
    WindowToggleSubscriber.prototype.closeWindow = function (index) {
        if (index === -1) {
            return;
        }
        var contexts = this.contexts;
        var context = contexts[index];
        var window = context.window, subscription = context.subscription;
        contexts.splice(index, 1);
        window.complete();
        subscription.unsubscribe();
    };
    return WindowToggleSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

},{"../OuterSubscriber":35,"../Subject":38,"../Subscription":41,"../util/subscribeToResult":225}],171:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subject_1 = require("../Subject");
var OuterSubscriber_1 = require("../OuterSubscriber");
var subscribeToResult_1 = require("../util/subscribeToResult");
function windowWhen(closingSelector) {
    return function windowWhenOperatorFunction(source) {
        return source.lift(new WindowOperator(closingSelector));
    };
}
exports.windowWhen = windowWhen;
var WindowOperator = (function () {
    function WindowOperator(closingSelector) {
        this.closingSelector = closingSelector;
    }
    WindowOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WindowSubscriber(subscriber, this.closingSelector));
    };
    return WindowOperator;
}());
var WindowSubscriber = (function (_super) {
    __extends(WindowSubscriber, _super);
    function WindowSubscriber(destination, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.closingSelector = closingSelector;
        _this.openWindow();
        return _this;
    }
    WindowSubscriber.prototype.notifyNext = function (_outerValue, _innerValue, _outerIndex, _innerIndex, innerSub) {
        this.openWindow(innerSub);
    };
    WindowSubscriber.prototype.notifyError = function (error) {
        this._error(error);
    };
    WindowSubscriber.prototype.notifyComplete = function (innerSub) {
        this.openWindow(innerSub);
    };
    WindowSubscriber.prototype._next = function (value) {
        this.window.next(value);
    };
    WindowSubscriber.prototype._error = function (err) {
        this.window.error(err);
        this.destination.error(err);
        this.unsubscribeClosingNotification();
    };
    WindowSubscriber.prototype._complete = function () {
        this.window.complete();
        this.destination.complete();
        this.unsubscribeClosingNotification();
    };
    WindowSubscriber.prototype.unsubscribeClosingNotification = function () {
        if (this.closingNotification) {
            this.closingNotification.unsubscribe();
        }
    };
    WindowSubscriber.prototype.openWindow = function (innerSub) {
        if (innerSub === void 0) { innerSub = null; }
        if (innerSub) {
            this.remove(innerSub);
            innerSub.unsubscribe();
        }
        var prevWindow = this.window;
        if (prevWindow) {
            prevWindow.complete();
        }
        var window = this.window = new Subject_1.Subject();
        this.destination.next(window);
        var closingNotifier;
        try {
            var closingSelector = this.closingSelector;
            closingNotifier = closingSelector();
        }
        catch (e) {
            this.destination.error(e);
            this.window.error(e);
            return;
        }
        this.add(this.closingNotification = subscribeToResult_1.subscribeToResult(this, closingNotifier));
    };
    return WindowSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

},{"../OuterSubscriber":35,"../Subject":38,"../util/subscribeToResult":225}],172:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var OuterSubscriber_1 = require("../OuterSubscriber");
var subscribeToResult_1 = require("../util/subscribeToResult");
function withLatestFrom() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return function (source) {
        var project;
        if (typeof args[args.length - 1] === 'function') {
            project = args.pop();
        }
        var observables = args;
        return source.lift(new WithLatestFromOperator(observables, project));
    };
}
exports.withLatestFrom = withLatestFrom;
var WithLatestFromOperator = (function () {
    function WithLatestFromOperator(observables, project) {
        this.observables = observables;
        this.project = project;
    }
    WithLatestFromOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));
    };
    return WithLatestFromOperator;
}());
var WithLatestFromSubscriber = (function (_super) {
    __extends(WithLatestFromSubscriber, _super);
    function WithLatestFromSubscriber(destination, observables, project) {
        var _this = _super.call(this, destination) || this;
        _this.observables = observables;
        _this.project = project;
        _this.toRespond = [];
        var len = observables.length;
        _this.values = new Array(len);
        for (var i = 0; i < len; i++) {
            _this.toRespond.push(i);
        }
        for (var i = 0; i < len; i++) {
            var observable = observables[i];
            _this.add(subscribeToResult_1.subscribeToResult(_this, observable, undefined, i));
        }
        return _this;
    }
    WithLatestFromSubscriber.prototype.notifyNext = function (_outerValue, innerValue, outerIndex) {
        this.values[outerIndex] = innerValue;
        var toRespond = this.toRespond;
        if (toRespond.length > 0) {
            var found = toRespond.indexOf(outerIndex);
            if (found !== -1) {
                toRespond.splice(found, 1);
            }
        }
    };
    WithLatestFromSubscriber.prototype.notifyComplete = function () {
    };
    WithLatestFromSubscriber.prototype._next = function (value) {
        if (this.toRespond.length === 0) {
            var args = [value].concat(this.values);
            if (this.project) {
                this._tryProject(args);
            }
            else {
                this.destination.next(args);
            }
        }
    };
    WithLatestFromSubscriber.prototype._tryProject = function (args) {
        var result;
        try {
            result = this.project.apply(this, args);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return WithLatestFromSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

},{"../OuterSubscriber":35,"../util/subscribeToResult":225}],173:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var zip_1 = require("../observable/zip");
function zip() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    return function zipOperatorFunction(source) {
        return source.lift.call(zip_1.zip.apply(void 0, [source].concat(observables)));
    };
}
exports.zip = zip;

},{"../observable/zip":71}],174:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var zip_1 = require("../observable/zip");
function zipAll(project) {
    return function (source) { return source.lift(new zip_1.ZipOperator(project)); };
}
exports.zipAll = zipAll;

},{"../observable/zip":71}],175:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var Subscription_1 = require("../Subscription");
function scheduleArray(input, scheduler) {
    return new Observable_1.Observable(function (subscriber) {
        var sub = new Subscription_1.Subscription();
        var i = 0;
        sub.add(scheduler.schedule(function () {
            if (i === input.length) {
                subscriber.complete();
                return;
            }
            subscriber.next(input[i++]);
            if (!subscriber.closed) {
                sub.add(this.schedule());
            }
        }));
        return sub;
    });
}
exports.scheduleArray = scheduleArray;

},{"../Observable":33,"../Subscription":41}],176:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var Subscription_1 = require("../Subscription");
var iterator_1 = require("../symbol/iterator");
function scheduleIterable(input, scheduler) {
    if (!input) {
        throw new Error('Iterable cannot be null');
    }
    return new Observable_1.Observable(function (subscriber) {
        var sub = new Subscription_1.Subscription();
        var iterator;
        sub.add(function () {
            if (iterator && typeof iterator.return === 'function') {
                iterator.return();
            }
        });
        sub.add(scheduler.schedule(function () {
            iterator = input[iterator_1.iterator]();
            sub.add(scheduler.schedule(function () {
                if (subscriber.closed) {
                    return;
                }
                var value;
                var done;
                try {
                    var result = iterator.next();
                    value = result.value;
                    done = result.done;
                }
                catch (err) {
                    subscriber.error(err);
                    return;
                }
                if (done) {
                    subscriber.complete();
                }
                else {
                    subscriber.next(value);
                    this.schedule();
                }
            }));
        }));
        return sub;
    });
}
exports.scheduleIterable = scheduleIterable;

},{"../Observable":33,"../Subscription":41,"../symbol/iterator":194}],177:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var Subscription_1 = require("../Subscription");
var observable_1 = require("../symbol/observable");
function scheduleObservable(input, scheduler) {
    return new Observable_1.Observable(function (subscriber) {
        var sub = new Subscription_1.Subscription();
        sub.add(scheduler.schedule(function () {
            var observable = input[observable_1.observable]();
            sub.add(observable.subscribe({
                next: function (value) { sub.add(scheduler.schedule(function () { return subscriber.next(value); })); },
                error: function (err) { sub.add(scheduler.schedule(function () { return subscriber.error(err); })); },
                complete: function () { sub.add(scheduler.schedule(function () { return subscriber.complete(); })); },
            }));
        }));
        return sub;
    });
}
exports.scheduleObservable = scheduleObservable;

},{"../Observable":33,"../Subscription":41,"../symbol/observable":195}],178:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
var Subscription_1 = require("../Subscription");
function schedulePromise(input, scheduler) {
    return new Observable_1.Observable(function (subscriber) {
        var sub = new Subscription_1.Subscription();
        sub.add(scheduler.schedule(function () { return input.then(function (value) {
            sub.add(scheduler.schedule(function () {
                subscriber.next(value);
                sub.add(scheduler.schedule(function () { return subscriber.complete(); }));
            }));
        }, function (err) {
            sub.add(scheduler.schedule(function () { return subscriber.error(err); }));
        }); }));
        return sub;
    });
}
exports.schedulePromise = schedulePromise;

},{"../Observable":33,"../Subscription":41}],179:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var scheduleObservable_1 = require("./scheduleObservable");
var schedulePromise_1 = require("./schedulePromise");
var scheduleArray_1 = require("./scheduleArray");
var scheduleIterable_1 = require("./scheduleIterable");
var isInteropObservable_1 = require("../util/isInteropObservable");
var isPromise_1 = require("../util/isPromise");
var isArrayLike_1 = require("../util/isArrayLike");
var isIterable_1 = require("../util/isIterable");
function scheduled(input, scheduler) {
    if (input != null) {
        if (isInteropObservable_1.isInteropObservable(input)) {
            return scheduleObservable_1.scheduleObservable(input, scheduler);
        }
        else if (isPromise_1.isPromise(input)) {
            return schedulePromise_1.schedulePromise(input, scheduler);
        }
        else if (isArrayLike_1.isArrayLike(input)) {
            return scheduleArray_1.scheduleArray(input, scheduler);
        }
        else if (isIterable_1.isIterable(input) || typeof input === 'string') {
            return scheduleIterable_1.scheduleIterable(input, scheduler);
        }
    }
    throw new TypeError((input !== null && typeof input || input) + ' is not observable');
}
exports.scheduled = scheduled;

},{"../util/isArrayLike":207,"../util/isInteropObservable":210,"../util/isIterable":211,"../util/isPromise":215,"./scheduleArray":175,"./scheduleIterable":176,"./scheduleObservable":177,"./schedulePromise":178}],180:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Subscription_1 = require("../Subscription");
var Action = (function (_super) {
    __extends(Action, _super);
    function Action(scheduler, work) {
        return _super.call(this) || this;
    }
    Action.prototype.schedule = function (state, delay) {
        if (delay === void 0) { delay = 0; }
        return this;
    };
    return Action;
}(Subscription_1.Subscription));
exports.Action = Action;

},{"../Subscription":41}],181:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var AsyncAction_1 = require("./AsyncAction");
var AnimationFrameAction = (function (_super) {
    __extends(AnimationFrameAction, _super);
    function AnimationFrameAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
    }
    AnimationFrameAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        if (delay !== null && delay > 0) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        scheduler.actions.push(this);
        return scheduler.scheduled || (scheduler.scheduled = requestAnimationFrame(function () { return scheduler.flush(null); }));
    };
    AnimationFrameAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
        }
        if (scheduler.actions.length === 0) {
            cancelAnimationFrame(id);
            scheduler.scheduled = undefined;
        }
        return undefined;
    };
    return AnimationFrameAction;
}(AsyncAction_1.AsyncAction));
exports.AnimationFrameAction = AnimationFrameAction;

},{"./AsyncAction":185}],182:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var AsyncScheduler_1 = require("./AsyncScheduler");
var AnimationFrameScheduler = (function (_super) {
    __extends(AnimationFrameScheduler, _super);
    function AnimationFrameScheduler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AnimationFrameScheduler.prototype.flush = function (action) {
        this.active = true;
        this.scheduled = undefined;
        var actions = this.actions;
        var error;
        var index = -1;
        var count = actions.length;
        action = action || actions.shift();
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (++index < count && (action = actions.shift()));
        this.active = false;
        if (error) {
            while (++index < count && (action = actions.shift())) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AnimationFrameScheduler;
}(AsyncScheduler_1.AsyncScheduler));
exports.AnimationFrameScheduler = AnimationFrameScheduler;

},{"./AsyncScheduler":186}],183:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Immediate_1 = require("../util/Immediate");
var AsyncAction_1 = require("./AsyncAction");
var AsapAction = (function (_super) {
    __extends(AsapAction, _super);
    function AsapAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
    }
    AsapAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        if (delay !== null && delay > 0) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        scheduler.actions.push(this);
        return scheduler.scheduled || (scheduler.scheduled = Immediate_1.Immediate.setImmediate(scheduler.flush.bind(scheduler, null)));
    };
    AsapAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
        }
        if (scheduler.actions.length === 0) {
            Immediate_1.Immediate.clearImmediate(id);
            scheduler.scheduled = undefined;
        }
        return undefined;
    };
    return AsapAction;
}(AsyncAction_1.AsyncAction));
exports.AsapAction = AsapAction;

},{"../util/Immediate":199,"./AsyncAction":185}],184:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var AsyncScheduler_1 = require("./AsyncScheduler");
var AsapScheduler = (function (_super) {
    __extends(AsapScheduler, _super);
    function AsapScheduler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AsapScheduler.prototype.flush = function (action) {
        this.active = true;
        this.scheduled = undefined;
        var actions = this.actions;
        var error;
        var index = -1;
        var count = actions.length;
        action = action || actions.shift();
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (++index < count && (action = actions.shift()));
        this.active = false;
        if (error) {
            while (++index < count && (action = actions.shift())) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AsapScheduler;
}(AsyncScheduler_1.AsyncScheduler));
exports.AsapScheduler = AsapScheduler;

},{"./AsyncScheduler":186}],185:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Action_1 = require("./Action");
var AsyncAction = (function (_super) {
    __extends(AsyncAction, _super);
    function AsyncAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.pending = false;
        return _this;
    }
    AsyncAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) { delay = 0; }
        if (this.closed) {
            return this;
        }
        this.state = state;
        var id = this.id;
        var scheduler = this.scheduler;
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, delay);
        }
        this.pending = true;
        this.delay = delay;
        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
        return this;
    };
    AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        return setInterval(scheduler.flush.bind(scheduler, this), delay);
    };
    AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        if (delay !== null && this.delay === delay && this.pending === false) {
            return id;
        }
        clearInterval(id);
        return undefined;
    };
    AsyncAction.prototype.execute = function (state, delay) {
        if (this.closed) {
            return new Error('executing a cancelled action');
        }
        this.pending = false;
        var error = this._execute(state, delay);
        if (error) {
            return error;
        }
        else if (this.pending === false && this.id != null) {
            this.id = this.recycleAsyncId(this.scheduler, this.id, null);
        }
    };
    AsyncAction.prototype._execute = function (state, delay) {
        var errored = false;
        var errorValue = undefined;
        try {
            this.work(state);
        }
        catch (e) {
            errored = true;
            errorValue = !!e && e || new Error(e);
        }
        if (errored) {
            this.unsubscribe();
            return errorValue;
        }
    };
    AsyncAction.prototype._unsubscribe = function () {
        var id = this.id;
        var scheduler = this.scheduler;
        var actions = scheduler.actions;
        var index = actions.indexOf(this);
        this.work = null;
        this.state = null;
        this.pending = false;
        this.scheduler = null;
        if (index !== -1) {
            actions.splice(index, 1);
        }
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, null);
        }
        this.delay = null;
    };
    return AsyncAction;
}(Action_1.Action));
exports.AsyncAction = AsyncAction;

},{"./Action":180}],186:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Scheduler_1 = require("../Scheduler");
var AsyncScheduler = (function (_super) {
    __extends(AsyncScheduler, _super);
    function AsyncScheduler(SchedulerAction, now) {
        if (now === void 0) { now = Scheduler_1.Scheduler.now; }
        var _this = _super.call(this, SchedulerAction, function () {
            if (AsyncScheduler.delegate && AsyncScheduler.delegate !== _this) {
                return AsyncScheduler.delegate.now();
            }
            else {
                return now();
            }
        }) || this;
        _this.actions = [];
        _this.active = false;
        _this.scheduled = undefined;
        return _this;
    }
    AsyncScheduler.prototype.schedule = function (work, delay, state) {
        if (delay === void 0) { delay = 0; }
        if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {
            return AsyncScheduler.delegate.schedule(work, delay, state);
        }
        else {
            return _super.prototype.schedule.call(this, work, delay, state);
        }
    };
    AsyncScheduler.prototype.flush = function (action) {
        var actions = this.actions;
        if (this.active) {
            actions.push(action);
            return;
        }
        var error;
        this.active = true;
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (action = actions.shift());
        this.active = false;
        if (error) {
            while (action = actions.shift()) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AsyncScheduler;
}(Scheduler_1.Scheduler));
exports.AsyncScheduler = AsyncScheduler;

},{"../Scheduler":37}],187:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var AsyncAction_1 = require("./AsyncAction");
var QueueAction = (function (_super) {
    __extends(QueueAction, _super);
    function QueueAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
    }
    QueueAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) { delay = 0; }
        if (delay > 0) {
            return _super.prototype.schedule.call(this, state, delay);
        }
        this.delay = delay;
        this.state = state;
        this.scheduler.flush(this);
        return this;
    };
    QueueAction.prototype.execute = function (state, delay) {
        return (delay > 0 || this.closed) ?
            _super.prototype.execute.call(this, state, delay) :
            this._execute(state, delay);
    };
    QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        return scheduler.flush(this);
    };
    return QueueAction;
}(AsyncAction_1.AsyncAction));
exports.QueueAction = QueueAction;

},{"./AsyncAction":185}],188:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var AsyncScheduler_1 = require("./AsyncScheduler");
var QueueScheduler = (function (_super) {
    __extends(QueueScheduler, _super);
    function QueueScheduler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return QueueScheduler;
}(AsyncScheduler_1.AsyncScheduler));
exports.QueueScheduler = QueueScheduler;

},{"./AsyncScheduler":186}],189:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var AsyncAction_1 = require("./AsyncAction");
var AsyncScheduler_1 = require("./AsyncScheduler");
var VirtualTimeScheduler = (function (_super) {
    __extends(VirtualTimeScheduler, _super);
    function VirtualTimeScheduler(SchedulerAction, maxFrames) {
        if (SchedulerAction === void 0) { SchedulerAction = VirtualAction; }
        if (maxFrames === void 0) { maxFrames = Number.POSITIVE_INFINITY; }
        var _this = _super.call(this, SchedulerAction, function () { return _this.frame; }) || this;
        _this.maxFrames = maxFrames;
        _this.frame = 0;
        _this.index = -1;
        return _this;
    }
    VirtualTimeScheduler.prototype.flush = function () {
        var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;
        var error, action;
        while ((action = actions[0]) && action.delay <= maxFrames) {
            actions.shift();
            this.frame = action.delay;
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        }
        if (error) {
            while (action = actions.shift()) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    VirtualTimeScheduler.frameTimeFactor = 10;
    return VirtualTimeScheduler;
}(AsyncScheduler_1.AsyncScheduler));
exports.VirtualTimeScheduler = VirtualTimeScheduler;
var VirtualAction = (function (_super) {
    __extends(VirtualAction, _super);
    function VirtualAction(scheduler, work, index) {
        if (index === void 0) { index = scheduler.index += 1; }
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.index = index;
        _this.active = true;
        _this.index = scheduler.index = index;
        return _this;
    }
    VirtualAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) { delay = 0; }
        if (!this.id) {
            return _super.prototype.schedule.call(this, state, delay);
        }
        this.active = false;
        var action = new VirtualAction(this.scheduler, this.work);
        this.add(action);
        return action.schedule(state, delay);
    };
    VirtualAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        this.delay = scheduler.frame + delay;
        var actions = scheduler.actions;
        actions.push(this);
        actions.sort(VirtualAction.sortActions);
        return true;
    };
    VirtualAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        return undefined;
    };
    VirtualAction.prototype._execute = function (state, delay) {
        if (this.active === true) {
            return _super.prototype._execute.call(this, state, delay);
        }
    };
    VirtualAction.sortActions = function (a, b) {
        if (a.delay === b.delay) {
            if (a.index === b.index) {
                return 0;
            }
            else if (a.index > b.index) {
                return 1;
            }
            else {
                return -1;
            }
        }
        else if (a.delay > b.delay) {
            return 1;
        }
        else {
            return -1;
        }
    };
    return VirtualAction;
}(AsyncAction_1.AsyncAction));
exports.VirtualAction = VirtualAction;

},{"./AsyncAction":185,"./AsyncScheduler":186}],190:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var AnimationFrameAction_1 = require("./AnimationFrameAction");
var AnimationFrameScheduler_1 = require("./AnimationFrameScheduler");
exports.animationFrameScheduler = new AnimationFrameScheduler_1.AnimationFrameScheduler(AnimationFrameAction_1.AnimationFrameAction);
exports.animationFrame = exports.animationFrameScheduler;

},{"./AnimationFrameAction":181,"./AnimationFrameScheduler":182}],191:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var AsapAction_1 = require("./AsapAction");
var AsapScheduler_1 = require("./AsapScheduler");
exports.asapScheduler = new AsapScheduler_1.AsapScheduler(AsapAction_1.AsapAction);
exports.asap = exports.asapScheduler;

},{"./AsapAction":183,"./AsapScheduler":184}],192:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var AsyncAction_1 = require("./AsyncAction");
var AsyncScheduler_1 = require("./AsyncScheduler");
exports.asyncScheduler = new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction);
exports.async = exports.asyncScheduler;

},{"./AsyncAction":185,"./AsyncScheduler":186}],193:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var QueueAction_1 = require("./QueueAction");
var QueueScheduler_1 = require("./QueueScheduler");
exports.queueScheduler = new QueueScheduler_1.QueueScheduler(QueueAction_1.QueueAction);
exports.queue = exports.queueScheduler;

},{"./QueueAction":187,"./QueueScheduler":188}],194:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function getSymbolIterator() {
    if (typeof Symbol !== 'function' || !Symbol.iterator) {
        return '@@iterator';
    }
    return Symbol.iterator;
}
exports.getSymbolIterator = getSymbolIterator;
exports.iterator = getSymbolIterator();
exports.$$iterator = exports.iterator;

},{}],195:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.observable = (function () { return typeof Symbol === 'function' && Symbol.observable || '@@observable'; })();

},{}],196:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.rxSubscriber = (function () {
    return typeof Symbol === 'function'
        ? Symbol('rxSubscriber')
        : '@@rxSubscriber_' + Math.random();
})();
exports.$$rxSubscriber = exports.rxSubscriber;

},{}],197:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ArgumentOutOfRangeErrorImpl = (function () {
    function ArgumentOutOfRangeErrorImpl() {
        Error.call(this);
        this.message = 'argument out of range';
        this.name = 'ArgumentOutOfRangeError';
        return this;
    }
    ArgumentOutOfRangeErrorImpl.prototype = Object.create(Error.prototype);
    return ArgumentOutOfRangeErrorImpl;
})();
exports.ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl;

},{}],198:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var EmptyErrorImpl = (function () {
    function EmptyErrorImpl() {
        Error.call(this);
        this.message = 'no elements in sequence';
        this.name = 'EmptyError';
        return this;
    }
    EmptyErrorImpl.prototype = Object.create(Error.prototype);
    return EmptyErrorImpl;
})();
exports.EmptyError = EmptyErrorImpl;

},{}],199:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var nextHandle = 1;
var RESOLVED = (function () { return Promise.resolve(); })();
var activeHandles = {};
function findAndClearHandle(handle) {
    if (handle in activeHandles) {
        delete activeHandles[handle];
        return true;
    }
    return false;
}
exports.Immediate = {
    setImmediate: function (cb) {
        var handle = nextHandle++;
        activeHandles[handle] = true;
        RESOLVED.then(function () { return findAndClearHandle(handle) && cb(); });
        return handle;
    },
    clearImmediate: function (handle) {
        findAndClearHandle(handle);
    },
};
exports.TestTools = {
    pending: function () {
        return Object.keys(activeHandles).length;
    }
};

},{}],200:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ObjectUnsubscribedErrorImpl = (function () {
    function ObjectUnsubscribedErrorImpl() {
        Error.call(this);
        this.message = 'object unsubscribed';
        this.name = 'ObjectUnsubscribedError';
        return this;
    }
    ObjectUnsubscribedErrorImpl.prototype = Object.create(Error.prototype);
    return ObjectUnsubscribedErrorImpl;
})();
exports.ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl;

},{}],201:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var TimeoutErrorImpl = (function () {
    function TimeoutErrorImpl() {
        Error.call(this);
        this.message = 'Timeout has occurred';
        this.name = 'TimeoutError';
        return this;
    }
    TimeoutErrorImpl.prototype = Object.create(Error.prototype);
    return TimeoutErrorImpl;
})();
exports.TimeoutError = TimeoutErrorImpl;

},{}],202:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var UnsubscriptionErrorImpl = (function () {
    function UnsubscriptionErrorImpl(errors) {
        Error.call(this);
        this.message = errors ?
            errors.length + " errors occurred during unsubscription:\n" + errors.map(function (err, i) { return i + 1 + ") " + err.toString(); }).join('\n  ') : '';
        this.name = 'UnsubscriptionError';
        this.errors = errors;
        return this;
    }
    UnsubscriptionErrorImpl.prototype = Object.create(Error.prototype);
    return UnsubscriptionErrorImpl;
})();
exports.UnsubscriptionError = UnsubscriptionErrorImpl;

},{}],203:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
function canReportError(observer) {
    while (observer) {
        var _a = observer, closed_1 = _a.closed, destination = _a.destination, isStopped = _a.isStopped;
        if (closed_1 || isStopped) {
            return false;
        }
        else if (destination && destination instanceof Subscriber_1.Subscriber) {
            observer = destination;
        }
        else {
            observer = null;
        }
    }
    return true;
}
exports.canReportError = canReportError;

},{"../Subscriber":40}],204:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function hostReportError(err) {
    setTimeout(function () { throw err; }, 0);
}
exports.hostReportError = hostReportError;

},{}],205:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function identity(x) {
    return x;
}
exports.identity = identity;

},{}],206:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isArray = (function () { return Array.isArray || (function (x) { return x && typeof x.length === 'number'; }); })();

},{}],207:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isArrayLike = (function (x) { return x && typeof x.length === 'number' && typeof x !== 'function'; });

},{}],208:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function isDate(value) {
    return value instanceof Date && !isNaN(+value);
}
exports.isDate = isDate;

},{}],209:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function isFunction(x) {
    return typeof x === 'function';
}
exports.isFunction = isFunction;

},{}],210:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var observable_1 = require("../symbol/observable");
function isInteropObservable(input) {
    return input && typeof input[observable_1.observable] === 'function';
}
exports.isInteropObservable = isInteropObservable;

},{"../symbol/observable":195}],211:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var iterator_1 = require("../symbol/iterator");
function isIterable(input) {
    return input && typeof input[iterator_1.iterator] === 'function';
}
exports.isIterable = isIterable;

},{"../symbol/iterator":194}],212:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var isArray_1 = require("./isArray");
function isNumeric(val) {
    return !isArray_1.isArray(val) && (val - parseFloat(val) + 1) >= 0;
}
exports.isNumeric = isNumeric;

},{"./isArray":206}],213:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function isObject(x) {
    return x !== null && typeof x === 'object';
}
exports.isObject = isObject;

},{}],214:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("../Observable");
function isObservable(obj) {
    return !!obj && (obj instanceof Observable_1.Observable || (typeof obj.lift === 'function' && typeof obj.subscribe === 'function'));
}
exports.isObservable = isObservable;

},{"../Observable":33}],215:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function isPromise(value) {
    return !!value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
}
exports.isPromise = isPromise;

},{}],216:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function isScheduler(value) {
    return value && typeof value.schedule === 'function';
}
exports.isScheduler = isScheduler;

},{}],217:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function noop() { }
exports.noop = noop;

},{}],218:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function not(pred, thisArg) {
    function notPred() {
        return !(notPred.pred.apply(notPred.thisArg, arguments));
    }
    notPred.pred = pred;
    notPred.thisArg = thisArg;
    return notPred;
}
exports.not = not;

},{}],219:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var identity_1 = require("./identity");
function pipe() {
    var fns = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        fns[_i] = arguments[_i];
    }
    return pipeFromArray(fns);
}
exports.pipe = pipe;
function pipeFromArray(fns) {
    if (fns.length === 0) {
        return identity_1.identity;
    }
    if (fns.length === 1) {
        return fns[0];
    }
    return function piped(input) {
        return fns.reduce(function (prev, fn) { return fn(prev); }, input);
    };
}
exports.pipeFromArray = pipeFromArray;

},{"./identity":205}],220:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var subscribeToArray_1 = require("./subscribeToArray");
var subscribeToPromise_1 = require("./subscribeToPromise");
var subscribeToIterable_1 = require("./subscribeToIterable");
var subscribeToObservable_1 = require("./subscribeToObservable");
var isArrayLike_1 = require("./isArrayLike");
var isPromise_1 = require("./isPromise");
var isObject_1 = require("./isObject");
var iterator_1 = require("../symbol/iterator");
var observable_1 = require("../symbol/observable");
exports.subscribeTo = function (result) {
    if (!!result && typeof result[observable_1.observable] === 'function') {
        return subscribeToObservable_1.subscribeToObservable(result);
    }
    else if (isArrayLike_1.isArrayLike(result)) {
        return subscribeToArray_1.subscribeToArray(result);
    }
    else if (isPromise_1.isPromise(result)) {
        return subscribeToPromise_1.subscribeToPromise(result);
    }
    else if (!!result && typeof result[iterator_1.iterator] === 'function') {
        return subscribeToIterable_1.subscribeToIterable(result);
    }
    else {
        var value = isObject_1.isObject(result) ? 'an invalid object' : "'" + result + "'";
        var msg = "You provided " + value + " where a stream was expected."
            + ' You can provide an Observable, Promise, Array, or Iterable.';
        throw new TypeError(msg);
    }
};

},{"../symbol/iterator":194,"../symbol/observable":195,"./isArrayLike":207,"./isObject":213,"./isPromise":215,"./subscribeToArray":221,"./subscribeToIterable":222,"./subscribeToObservable":223,"./subscribeToPromise":224}],221:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.subscribeToArray = function (array) { return function (subscriber) {
    for (var i = 0, len = array.length; i < len && !subscriber.closed; i++) {
        subscriber.next(array[i]);
    }
    subscriber.complete();
}; };

},{}],222:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var iterator_1 = require("../symbol/iterator");
exports.subscribeToIterable = function (iterable) { return function (subscriber) {
    var iterator = iterable[iterator_1.iterator]();
    do {
        var item = void 0;
        try {
            item = iterator.next();
        }
        catch (err) {
            subscriber.error(err);
            return subscriber;
        }
        if (item.done) {
            subscriber.complete();
            break;
        }
        subscriber.next(item.value);
        if (subscriber.closed) {
            break;
        }
    } while (true);
    if (typeof iterator.return === 'function') {
        subscriber.add(function () {
            if (iterator.return) {
                iterator.return();
            }
        });
    }
    return subscriber;
}; };

},{"../symbol/iterator":194}],223:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var observable_1 = require("../symbol/observable");
exports.subscribeToObservable = function (obj) { return function (subscriber) {
    var obs = obj[observable_1.observable]();
    if (typeof obs.subscribe !== 'function') {
        throw new TypeError('Provided object does not correctly implement Symbol.observable');
    }
    else {
        return obs.subscribe(subscriber);
    }
}; };

},{"../symbol/observable":195}],224:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var hostReportError_1 = require("./hostReportError");
exports.subscribeToPromise = function (promise) { return function (subscriber) {
    promise.then(function (value) {
        if (!subscriber.closed) {
            subscriber.next(value);
            subscriber.complete();
        }
    }, function (err) { return subscriber.error(err); })
        .then(null, hostReportError_1.hostReportError);
    return subscriber;
}; };

},{"./hostReportError":204}],225:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var InnerSubscriber_1 = require("../InnerSubscriber");
var subscribeTo_1 = require("./subscribeTo");
var Observable_1 = require("../Observable");
function subscribeToResult(outerSubscriber, result, outerValue, outerIndex, innerSubscriber) {
    if (innerSubscriber === void 0) { innerSubscriber = new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex); }
    if (innerSubscriber.closed) {
        return undefined;
    }
    if (result instanceof Observable_1.Observable) {
        return result.subscribe(innerSubscriber);
    }
    return subscribeTo_1.subscribeTo(result)(innerSubscriber);
}
exports.subscribeToResult = subscribeToResult;

},{"../InnerSubscriber":31,"../Observable":33,"./subscribeTo":220}],226:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Subscriber_1 = require("../Subscriber");
var rxSubscriber_1 = require("../symbol/rxSubscriber");
var Observer_1 = require("../Observer");
function toSubscriber(nextOrObserver, error, complete) {
    if (nextOrObserver) {
        if (nextOrObserver instanceof Subscriber_1.Subscriber) {
            return nextOrObserver;
        }
        if (nextOrObserver[rxSubscriber_1.rxSubscriber]) {
            return nextOrObserver[rxSubscriber_1.rxSubscriber]();
        }
    }
    if (!nextOrObserver && !error && !complete) {
        return new Subscriber_1.Subscriber(Observer_1.empty);
    }
    return new Subscriber_1.Subscriber(nextOrObserver, error, complete);
}
exports.toSubscriber = toSubscriber;

},{"../Observer":34,"../Subscriber":40,"../symbol/rxSubscriber":196}],227:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var audit_1 = require("../internal/operators/audit");
exports.audit = audit_1.audit;
var auditTime_1 = require("../internal/operators/auditTime");
exports.auditTime = auditTime_1.auditTime;
var buffer_1 = require("../internal/operators/buffer");
exports.buffer = buffer_1.buffer;
var bufferCount_1 = require("../internal/operators/bufferCount");
exports.bufferCount = bufferCount_1.bufferCount;
var bufferTime_1 = require("../internal/operators/bufferTime");
exports.bufferTime = bufferTime_1.bufferTime;
var bufferToggle_1 = require("../internal/operators/bufferToggle");
exports.bufferToggle = bufferToggle_1.bufferToggle;
var bufferWhen_1 = require("../internal/operators/bufferWhen");
exports.bufferWhen = bufferWhen_1.bufferWhen;
var catchError_1 = require("../internal/operators/catchError");
exports.catchError = catchError_1.catchError;
var combineAll_1 = require("../internal/operators/combineAll");
exports.combineAll = combineAll_1.combineAll;
var combineLatest_1 = require("../internal/operators/combineLatest");
exports.combineLatest = combineLatest_1.combineLatest;
var concat_1 = require("../internal/operators/concat");
exports.concat = concat_1.concat;
var concatAll_1 = require("../internal/operators/concatAll");
exports.concatAll = concatAll_1.concatAll;
var concatMap_1 = require("../internal/operators/concatMap");
exports.concatMap = concatMap_1.concatMap;
var concatMapTo_1 = require("../internal/operators/concatMapTo");
exports.concatMapTo = concatMapTo_1.concatMapTo;
var count_1 = require("../internal/operators/count");
exports.count = count_1.count;
var debounce_1 = require("../internal/operators/debounce");
exports.debounce = debounce_1.debounce;
var debounceTime_1 = require("../internal/operators/debounceTime");
exports.debounceTime = debounceTime_1.debounceTime;
var defaultIfEmpty_1 = require("../internal/operators/defaultIfEmpty");
exports.defaultIfEmpty = defaultIfEmpty_1.defaultIfEmpty;
var delay_1 = require("../internal/operators/delay");
exports.delay = delay_1.delay;
var delayWhen_1 = require("../internal/operators/delayWhen");
exports.delayWhen = delayWhen_1.delayWhen;
var dematerialize_1 = require("../internal/operators/dematerialize");
exports.dematerialize = dematerialize_1.dematerialize;
var distinct_1 = require("../internal/operators/distinct");
exports.distinct = distinct_1.distinct;
var distinctUntilChanged_1 = require("../internal/operators/distinctUntilChanged");
exports.distinctUntilChanged = distinctUntilChanged_1.distinctUntilChanged;
var distinctUntilKeyChanged_1 = require("../internal/operators/distinctUntilKeyChanged");
exports.distinctUntilKeyChanged = distinctUntilKeyChanged_1.distinctUntilKeyChanged;
var elementAt_1 = require("../internal/operators/elementAt");
exports.elementAt = elementAt_1.elementAt;
var endWith_1 = require("../internal/operators/endWith");
exports.endWith = endWith_1.endWith;
var every_1 = require("../internal/operators/every");
exports.every = every_1.every;
var exhaust_1 = require("../internal/operators/exhaust");
exports.exhaust = exhaust_1.exhaust;
var exhaustMap_1 = require("../internal/operators/exhaustMap");
exports.exhaustMap = exhaustMap_1.exhaustMap;
var expand_1 = require("../internal/operators/expand");
exports.expand = expand_1.expand;
var filter_1 = require("../internal/operators/filter");
exports.filter = filter_1.filter;
var finalize_1 = require("../internal/operators/finalize");
exports.finalize = finalize_1.finalize;
var find_1 = require("../internal/operators/find");
exports.find = find_1.find;
var findIndex_1 = require("../internal/operators/findIndex");
exports.findIndex = findIndex_1.findIndex;
var first_1 = require("../internal/operators/first");
exports.first = first_1.first;
var groupBy_1 = require("../internal/operators/groupBy");
exports.groupBy = groupBy_1.groupBy;
var ignoreElements_1 = require("../internal/operators/ignoreElements");
exports.ignoreElements = ignoreElements_1.ignoreElements;
var isEmpty_1 = require("../internal/operators/isEmpty");
exports.isEmpty = isEmpty_1.isEmpty;
var last_1 = require("../internal/operators/last");
exports.last = last_1.last;
var map_1 = require("../internal/operators/map");
exports.map = map_1.map;
var mapTo_1 = require("../internal/operators/mapTo");
exports.mapTo = mapTo_1.mapTo;
var materialize_1 = require("../internal/operators/materialize");
exports.materialize = materialize_1.materialize;
var max_1 = require("../internal/operators/max");
exports.max = max_1.max;
var merge_1 = require("../internal/operators/merge");
exports.merge = merge_1.merge;
var mergeAll_1 = require("../internal/operators/mergeAll");
exports.mergeAll = mergeAll_1.mergeAll;
var mergeMap_1 = require("../internal/operators/mergeMap");
exports.mergeMap = mergeMap_1.mergeMap;
exports.flatMap = mergeMap_1.flatMap;
var mergeMapTo_1 = require("../internal/operators/mergeMapTo");
exports.mergeMapTo = mergeMapTo_1.mergeMapTo;
var mergeScan_1 = require("../internal/operators/mergeScan");
exports.mergeScan = mergeScan_1.mergeScan;
var min_1 = require("../internal/operators/min");
exports.min = min_1.min;
var multicast_1 = require("../internal/operators/multicast");
exports.multicast = multicast_1.multicast;
var observeOn_1 = require("../internal/operators/observeOn");
exports.observeOn = observeOn_1.observeOn;
var onErrorResumeNext_1 = require("../internal/operators/onErrorResumeNext");
exports.onErrorResumeNext = onErrorResumeNext_1.onErrorResumeNext;
var pairwise_1 = require("../internal/operators/pairwise");
exports.pairwise = pairwise_1.pairwise;
var partition_1 = require("../internal/operators/partition");
exports.partition = partition_1.partition;
var pluck_1 = require("../internal/operators/pluck");
exports.pluck = pluck_1.pluck;
var publish_1 = require("../internal/operators/publish");
exports.publish = publish_1.publish;
var publishBehavior_1 = require("../internal/operators/publishBehavior");
exports.publishBehavior = publishBehavior_1.publishBehavior;
var publishLast_1 = require("../internal/operators/publishLast");
exports.publishLast = publishLast_1.publishLast;
var publishReplay_1 = require("../internal/operators/publishReplay");
exports.publishReplay = publishReplay_1.publishReplay;
var race_1 = require("../internal/operators/race");
exports.race = race_1.race;
var reduce_1 = require("../internal/operators/reduce");
exports.reduce = reduce_1.reduce;
var repeat_1 = require("../internal/operators/repeat");
exports.repeat = repeat_1.repeat;
var repeatWhen_1 = require("../internal/operators/repeatWhen");
exports.repeatWhen = repeatWhen_1.repeatWhen;
var retry_1 = require("../internal/operators/retry");
exports.retry = retry_1.retry;
var retryWhen_1 = require("../internal/operators/retryWhen");
exports.retryWhen = retryWhen_1.retryWhen;
var refCount_1 = require("../internal/operators/refCount");
exports.refCount = refCount_1.refCount;
var sample_1 = require("../internal/operators/sample");
exports.sample = sample_1.sample;
var sampleTime_1 = require("../internal/operators/sampleTime");
exports.sampleTime = sampleTime_1.sampleTime;
var scan_1 = require("../internal/operators/scan");
exports.scan = scan_1.scan;
var sequenceEqual_1 = require("../internal/operators/sequenceEqual");
exports.sequenceEqual = sequenceEqual_1.sequenceEqual;
var share_1 = require("../internal/operators/share");
exports.share = share_1.share;
var shareReplay_1 = require("../internal/operators/shareReplay");
exports.shareReplay = shareReplay_1.shareReplay;
var single_1 = require("../internal/operators/single");
exports.single = single_1.single;
var skip_1 = require("../internal/operators/skip");
exports.skip = skip_1.skip;
var skipLast_1 = require("../internal/operators/skipLast");
exports.skipLast = skipLast_1.skipLast;
var skipUntil_1 = require("../internal/operators/skipUntil");
exports.skipUntil = skipUntil_1.skipUntil;
var skipWhile_1 = require("../internal/operators/skipWhile");
exports.skipWhile = skipWhile_1.skipWhile;
var startWith_1 = require("../internal/operators/startWith");
exports.startWith = startWith_1.startWith;
var subscribeOn_1 = require("../internal/operators/subscribeOn");
exports.subscribeOn = subscribeOn_1.subscribeOn;
var switchAll_1 = require("../internal/operators/switchAll");
exports.switchAll = switchAll_1.switchAll;
var switchMap_1 = require("../internal/operators/switchMap");
exports.switchMap = switchMap_1.switchMap;
var switchMapTo_1 = require("../internal/operators/switchMapTo");
exports.switchMapTo = switchMapTo_1.switchMapTo;
var take_1 = require("../internal/operators/take");
exports.take = take_1.take;
var takeLast_1 = require("../internal/operators/takeLast");
exports.takeLast = takeLast_1.takeLast;
var takeUntil_1 = require("../internal/operators/takeUntil");
exports.takeUntil = takeUntil_1.takeUntil;
var takeWhile_1 = require("../internal/operators/takeWhile");
exports.takeWhile = takeWhile_1.takeWhile;
var tap_1 = require("../internal/operators/tap");
exports.tap = tap_1.tap;
var throttle_1 = require("../internal/operators/throttle");
exports.throttle = throttle_1.throttle;
var throttleTime_1 = require("../internal/operators/throttleTime");
exports.throttleTime = throttleTime_1.throttleTime;
var throwIfEmpty_1 = require("../internal/operators/throwIfEmpty");
exports.throwIfEmpty = throwIfEmpty_1.throwIfEmpty;
var timeInterval_1 = require("../internal/operators/timeInterval");
exports.timeInterval = timeInterval_1.timeInterval;
var timeout_1 = require("../internal/operators/timeout");
exports.timeout = timeout_1.timeout;
var timeoutWith_1 = require("../internal/operators/timeoutWith");
exports.timeoutWith = timeoutWith_1.timeoutWith;
var timestamp_1 = require("../internal/operators/timestamp");
exports.timestamp = timestamp_1.timestamp;
var toArray_1 = require("../internal/operators/toArray");
exports.toArray = toArray_1.toArray;
var window_1 = require("../internal/operators/window");
exports.window = window_1.window;
var windowCount_1 = require("../internal/operators/windowCount");
exports.windowCount = windowCount_1.windowCount;
var windowTime_1 = require("../internal/operators/windowTime");
exports.windowTime = windowTime_1.windowTime;
var windowToggle_1 = require("../internal/operators/windowToggle");
exports.windowToggle = windowToggle_1.windowToggle;
var windowWhen_1 = require("../internal/operators/windowWhen");
exports.windowWhen = windowWhen_1.windowWhen;
var withLatestFrom_1 = require("../internal/operators/withLatestFrom");
exports.withLatestFrom = withLatestFrom_1.withLatestFrom;
var zip_1 = require("../internal/operators/zip");
exports.zip = zip_1.zip;
var zipAll_1 = require("../internal/operators/zipAll");
exports.zipAll = zipAll_1.zipAll;

},{"../internal/operators/audit":72,"../internal/operators/auditTime":73,"../internal/operators/buffer":74,"../internal/operators/bufferCount":75,"../internal/operators/bufferTime":76,"../internal/operators/bufferToggle":77,"../internal/operators/bufferWhen":78,"../internal/operators/catchError":79,"../internal/operators/combineAll":80,"../internal/operators/combineLatest":81,"../internal/operators/concat":82,"../internal/operators/concatAll":83,"../internal/operators/concatMap":84,"../internal/operators/concatMapTo":85,"../internal/operators/count":86,"../internal/operators/debounce":87,"../internal/operators/debounceTime":88,"../internal/operators/defaultIfEmpty":89,"../internal/operators/delay":90,"../internal/operators/delayWhen":91,"../internal/operators/dematerialize":92,"../internal/operators/distinct":93,"../internal/operators/distinctUntilChanged":94,"../internal/operators/distinctUntilKeyChanged":95,"../internal/operators/elementAt":96,"../internal/operators/endWith":97,"../internal/operators/every":98,"../internal/operators/exhaust":99,"../internal/operators/exhaustMap":100,"../internal/operators/expand":101,"../internal/operators/filter":102,"../internal/operators/finalize":103,"../internal/operators/find":104,"../internal/operators/findIndex":105,"../internal/operators/first":106,"../internal/operators/groupBy":107,"../internal/operators/ignoreElements":108,"../internal/operators/isEmpty":109,"../internal/operators/last":110,"../internal/operators/map":111,"../internal/operators/mapTo":112,"../internal/operators/materialize":113,"../internal/operators/max":114,"../internal/operators/merge":115,"../internal/operators/mergeAll":116,"../internal/operators/mergeMap":117,"../internal/operators/mergeMapTo":118,"../internal/operators/mergeScan":119,"../internal/operators/min":120,"../internal/operators/multicast":121,"../internal/operators/observeOn":122,"../internal/operators/onErrorResumeNext":123,"../internal/operators/pairwise":124,"../internal/operators/partition":125,"../internal/operators/pluck":126,"../internal/operators/publish":127,"../internal/operators/publishBehavior":128,"../internal/operators/publishLast":129,"../internal/operators/publishReplay":130,"../internal/operators/race":131,"../internal/operators/reduce":132,"../internal/operators/refCount":133,"../internal/operators/repeat":134,"../internal/operators/repeatWhen":135,"../internal/operators/retry":136,"../internal/operators/retryWhen":137,"../internal/operators/sample":138,"../internal/operators/sampleTime":139,"../internal/operators/scan":140,"../internal/operators/sequenceEqual":141,"../internal/operators/share":142,"../internal/operators/shareReplay":143,"../internal/operators/single":144,"../internal/operators/skip":145,"../internal/operators/skipLast":146,"../internal/operators/skipUntil":147,"../internal/operators/skipWhile":148,"../internal/operators/startWith":149,"../internal/operators/subscribeOn":150,"../internal/operators/switchAll":151,"../internal/operators/switchMap":152,"../internal/operators/switchMapTo":153,"../internal/operators/take":154,"../internal/operators/takeLast":155,"../internal/operators/takeUntil":156,"../internal/operators/takeWhile":157,"../internal/operators/tap":158,"../internal/operators/throttle":159,"../internal/operators/throttleTime":160,"../internal/operators/throwIfEmpty":161,"../internal/operators/timeInterval":162,"../internal/operators/timeout":163,"../internal/operators/timeoutWith":164,"../internal/operators/timestamp":165,"../internal/operators/toArray":166,"../internal/operators/window":167,"../internal/operators/windowCount":168,"../internal/operators/windowTime":169,"../internal/operators/windowToggle":170,"../internal/operators/windowWhen":171,"../internal/operators/withLatestFrom":172,"../internal/operators/zip":173,"../internal/operators/zipAll":174}],228:[function(require,module,exports){
'use strict';

// This is free and unencumbered software released into the public domain.
// See LICENSE.md for more information.

//
// Utilities
//

/**
 * @param {number} a The number to test.
 * @param {number} min The minimum value in the range, inclusive.
 * @param {number} max The maximum value in the range, inclusive.
 * @return {boolean} True if a >= min and a <= max.
 */
function inRange(a, min, max) {
  return min <= a && a <= max;
}

/**
 * @param {*} o
 * @return {Object}
 */
function ToDictionary(o) {
  if (o === undefined) return {};
  if (o === Object(o)) return o;
  throw TypeError('Could not convert argument to dictionary');
}

/**
 * @param {string} string Input string of UTF-16 code units.
 * @return {!Array.<number>} Code points.
 */
function stringToCodePoints(string) {
  // https://heycam.github.io/webidl/#dfn-obtain-unicode

  // 1. Let S be the DOMString value.
  var s = String(string);

  // 2. Let n be the length of S.
  var n = s.length;

  // 3. Initialize i to 0.
  var i = 0;

  // 4. Initialize U to be an empty sequence of Unicode characters.
  var u = [];

  // 5. While i < n:
  while (i < n) {

    // 1. Let c be the code unit in S at index i.
    var c = s.charCodeAt(i);

    // 2. Depending on the value of c:

    // c < 0xD800 or c > 0xDFFF
    if (c < 0xD800 || c > 0xDFFF) {
      // Append to U the Unicode character with code point c.
      u.push(c);
    }

    // 0xDC00  c  0xDFFF
    else if (0xDC00 <= c && c <= 0xDFFF) {
      // Append to U a U+FFFD REPLACEMENT CHARACTER.
      u.push(0xFFFD);
    }

    // 0xD800  c  0xDBFF
    else if (0xD800 <= c && c <= 0xDBFF) {
      // 1. If i = n1, then append to U a U+FFFD REPLACEMENT
      // CHARACTER.
      if (i === n - 1) {
        u.push(0xFFFD);
      }
      // 2. Otherwise, i < n1:
      else {
        // 1. Let d be the code unit in S at index i+1.
        var d = string.charCodeAt(i + 1);

        // 2. If 0xDC00  d  0xDFFF, then:
        if (0xDC00 <= d && d <= 0xDFFF) {
          // 1. Let a be c & 0x3FF.
          var a = c & 0x3FF;

          // 2. Let b be d & 0x3FF.
          var b = d & 0x3FF;

          // 3. Append to U the Unicode character with code point
          // 2^16+2^10*a+b.
          u.push(0x10000 + (a << 10) + b);

          // 4. Set i to i+1.
          i += 1;
        }

        // 3. Otherwise, d < 0xDC00 or d > 0xDFFF. Append to U a
        // U+FFFD REPLACEMENT CHARACTER.
        else  {
          u.push(0xFFFD);
        }
      }
    }

    // 3. Set i to i+1.
    i += 1;
  }

  // 6. Return U.
  return u;
}

/**
 * @param {!Array.<number>} code_points Array of code points.
 * @return {string} string String of UTF-16 code units.
 */
function codePointsToString(code_points) {
  var s = '';
  for (var i = 0; i < code_points.length; ++i) {
    var cp = code_points[i];
    if (cp <= 0xFFFF) {
      s += String.fromCharCode(cp);
    } else {
      cp -= 0x10000;
      s += String.fromCharCode((cp >> 10) + 0xD800,
                               (cp & 0x3FF) + 0xDC00);
    }
  }
  return s;
}


//
// Implementation of Encoding specification
// https://encoding.spec.whatwg.org/
//

//
// 3. Terminology
//

/**
 * End-of-stream is a special token that signifies no more tokens
 * are in the stream.
 * @const
 */ var end_of_stream = -1;

/**
 * A stream represents an ordered sequence of tokens.
 *
 * @constructor
 * @param {!(Array.<number>|Uint8Array)} tokens Array of tokens that provide the
 * stream.
 */
function Stream(tokens) {
  /** @type {!Array.<number>} */
  this.tokens = [].slice.call(tokens);
}

Stream.prototype = {
  /**
   * @return {boolean} True if end-of-stream has been hit.
   */
  endOfStream: function() {
    return !this.tokens.length;
  },

  /**
   * When a token is read from a stream, the first token in the
   * stream must be returned and subsequently removed, and
   * end-of-stream must be returned otherwise.
   *
   * @return {number} Get the next token from the stream, or
   * end_of_stream.
   */
   read: function() {
    if (!this.tokens.length)
      return end_of_stream;
     return this.tokens.shift();
   },

  /**
   * When one or more tokens are prepended to a stream, those tokens
   * must be inserted, in given order, before the first token in the
   * stream.
   *
   * @param {(number|!Array.<number>)} token The token(s) to prepend to the stream.
   */
  prepend: function(token) {
    if (Array.isArray(token)) {
      var tokens = /**@type {!Array.<number>}*/(token);
      while (tokens.length)
        this.tokens.unshift(tokens.pop());
    } else {
      this.tokens.unshift(token);
    }
  },

  /**
   * When one or more tokens are pushed to a stream, those tokens
   * must be inserted, in given order, after the last token in the
   * stream.
   *
   * @param {(number|!Array.<number>)} token The tokens(s) to prepend to the stream.
   */
  push: function(token) {
    if (Array.isArray(token)) {
      var tokens = /**@type {!Array.<number>}*/(token);
      while (tokens.length)
        this.tokens.push(tokens.shift());
    } else {
      this.tokens.push(token);
    }
  }
};

//
// 4. Encodings
//

// 4.1 Encoders and decoders

/** @const */
var finished = -1;

/**
 * @param {boolean} fatal If true, decoding errors raise an exception.
 * @param {number=} opt_code_point Override the standard fallback code point.
 * @return {number} The code point to insert on a decoding error.
 */
function decoderError(fatal, opt_code_point) {
  if (fatal)
    throw TypeError('Decoder error');
  return opt_code_point || 0xFFFD;
}

//
// 7. API
//

/** @const */ var DEFAULT_ENCODING = 'utf-8';

// 7.1 Interface TextDecoder

/**
 * @constructor
 * @param {string=} encoding The label of the encoding;
 *     defaults to 'utf-8'.
 * @param {Object=} options
 */
function TextDecoder(encoding, options) {
  if (!(this instanceof TextDecoder)) {
    return new TextDecoder(encoding, options);
  }
  encoding = encoding !== undefined ? String(encoding).toLowerCase() : DEFAULT_ENCODING;
  if (encoding !== DEFAULT_ENCODING) {
    throw new Error('Encoding not supported. Only utf-8 is supported');
  }
  options = ToDictionary(options);

  /** @private @type {boolean} */
  this._streaming = false;
  /** @private @type {boolean} */
  this._BOMseen = false;
  /** @private @type {?Decoder} */
  this._decoder = null;
  /** @private @type {boolean} */
  this._fatal = Boolean(options['fatal']);
  /** @private @type {boolean} */
  this._ignoreBOM = Boolean(options['ignoreBOM']);

  Object.defineProperty(this, 'encoding', {value: 'utf-8'});
  Object.defineProperty(this, 'fatal', {value: this._fatal});
  Object.defineProperty(this, 'ignoreBOM', {value: this._ignoreBOM});
}

TextDecoder.prototype = {
  /**
   * @param {ArrayBufferView=} input The buffer of bytes to decode.
   * @param {Object=} options
   * @return {string} The decoded string.
   */
  decode: function decode(input, options) {
    var bytes;
    if (typeof input === 'object' && input instanceof ArrayBuffer) {
      bytes = new Uint8Array(input);
    } else if (typeof input === 'object' && 'buffer' in input &&
               input.buffer instanceof ArrayBuffer) {
      bytes = new Uint8Array(input.buffer,
                             input.byteOffset,
                             input.byteLength);
    } else {
      bytes = new Uint8Array(0);
    }

    options = ToDictionary(options);

    if (!this._streaming) {
      this._decoder = new UTF8Decoder({fatal: this._fatal});
      this._BOMseen = false;
    }
    this._streaming = Boolean(options['stream']);

    var input_stream = new Stream(bytes);

    var code_points = [];

    /** @type {?(number|!Array.<number>)} */
    var result;

    while (!input_stream.endOfStream()) {
      result = this._decoder.handler(input_stream, input_stream.read());
      if (result === finished)
        break;
      if (result === null)
        continue;
      if (Array.isArray(result))
        code_points.push.apply(code_points, /**@type {!Array.<number>}*/(result));
      else
        code_points.push(result);
    }
    if (!this._streaming) {
      do {
        result = this._decoder.handler(input_stream, input_stream.read());
        if (result === finished)
          break;
        if (result === null)
          continue;
        if (Array.isArray(result))
          code_points.push.apply(code_points, /**@type {!Array.<number>}*/(result));
        else
          code_points.push(result);
      } while (!input_stream.endOfStream());
      this._decoder = null;
    }

    if (code_points.length) {
      // If encoding is one of utf-8, utf-16be, and utf-16le, and
      // ignore BOM flag and BOM seen flag are unset, run these
      // subsubsteps:
      if (['utf-8'].indexOf(this.encoding) !== -1 &&
          !this._ignoreBOM && !this._BOMseen) {
        // If token is U+FEFF, set BOM seen flag.
        if (code_points[0] === 0xFEFF) {
          this._BOMseen = true;
          code_points.shift();
        } else {
          // Otherwise, if token is not end-of-stream, set BOM seen
          // flag and append token to output.
          this._BOMseen = true;
        }
      }
    }

    return codePointsToString(code_points);
  }
};

// 7.2 Interface TextEncoder

/**
 * @constructor
 * @param {string=} encoding The label of the encoding;
 *     defaults to 'utf-8'.
 * @param {Object=} options
 */
function TextEncoder(encoding, options) {
  if (!(this instanceof TextEncoder))
    return new TextEncoder(encoding, options);
  encoding = encoding !== undefined ? String(encoding).toLowerCase() : DEFAULT_ENCODING;
  if (encoding !== DEFAULT_ENCODING) {
    throw new Error('Encoding not supported. Only utf-8 is supported');
  }
  options = ToDictionary(options);

  /** @private @type {boolean} */
  this._streaming = false;
  /** @private @type {?Encoder} */
  this._encoder = null;
  /** @private @type {{fatal: boolean}} */
  this._options = {fatal: Boolean(options['fatal'])};

  Object.defineProperty(this, 'encoding', {value: 'utf-8'});
}

TextEncoder.prototype = {
  /**
   * @param {string=} opt_string The string to encode.
   * @param {Object=} options
   * @return {Uint8Array} Encoded bytes, as a Uint8Array.
   */
  encode: function encode(opt_string, options) {
    opt_string = opt_string ? String(opt_string) : '';
    options = ToDictionary(options);

    // NOTE: This option is nonstandard. None of the encodings
    // permitted for encoding (i.e. UTF-8, UTF-16) are stateful,
    // so streaming is not necessary.
    if (!this._streaming)
      this._encoder = new UTF8Encoder(this._options);
    this._streaming = Boolean(options['stream']);

    var bytes = [];
    var input_stream = new Stream(stringToCodePoints(opt_string));
    /** @type {?(number|!Array.<number>)} */
    var result;
    while (!input_stream.endOfStream()) {
      result = this._encoder.handler(input_stream, input_stream.read());
      if (result === finished)
        break;
      if (Array.isArray(result))
        bytes.push.apply(bytes, /**@type {!Array.<number>}*/(result));
      else
        bytes.push(result);
    }
    if (!this._streaming) {
      while (true) {
        result = this._encoder.handler(input_stream, input_stream.read());
        if (result === finished)
          break;
        if (Array.isArray(result))
          bytes.push.apply(bytes, /**@type {!Array.<number>}*/(result));
        else
          bytes.push(result);
      }
      this._encoder = null;
    }
    return new Uint8Array(bytes);
  }
};

//
// 8. The encoding
//

// 8.1 utf-8

/**
 * @constructor
 * @implements {Decoder}
 * @param {{fatal: boolean}} options
 */
function UTF8Decoder(options) {
  var fatal = options.fatal;

  // utf-8's decoder's has an associated utf-8 code point, utf-8
  // bytes seen, and utf-8 bytes needed (all initially 0), a utf-8
  // lower boundary (initially 0x80), and a utf-8 upper boundary
  // (initially 0xBF).
  var /** @type {number} */ utf8_code_point = 0,
      /** @type {number} */ utf8_bytes_seen = 0,
      /** @type {number} */ utf8_bytes_needed = 0,
      /** @type {number} */ utf8_lower_boundary = 0x80,
      /** @type {number} */ utf8_upper_boundary = 0xBF;

  /**
   * @param {Stream} stream The stream of bytes being decoded.
   * @param {number} bite The next byte read from the stream.
   * @return {?(number|!Array.<number>)} The next code point(s)
   *     decoded, or null if not enough data exists in the input
   *     stream to decode a complete code point.
   */
  this.handler = function(stream, bite) {
    // 1. If byte is end-of-stream and utf-8 bytes needed is not 0,
    // set utf-8 bytes needed to 0 and return error.
    if (bite === end_of_stream && utf8_bytes_needed !== 0) {
      utf8_bytes_needed = 0;
      return decoderError(fatal);
    }

    // 2. If byte is end-of-stream, return finished.
    if (bite === end_of_stream)
      return finished;

    // 3. If utf-8 bytes needed is 0, based on byte:
    if (utf8_bytes_needed === 0) {

      // 0x00 to 0x7F
      if (inRange(bite, 0x00, 0x7F)) {
        // Return a code point whose value is byte.
        return bite;
      }

      // 0xC2 to 0xDF
      if (inRange(bite, 0xC2, 0xDF)) {
        // Set utf-8 bytes needed to 1 and utf-8 code point to byte
        //  0xC0.
        utf8_bytes_needed = 1;
        utf8_code_point = bite - 0xC0;
      }

      // 0xE0 to 0xEF
      else if (inRange(bite, 0xE0, 0xEF)) {
        // 1. If byte is 0xE0, set utf-8 lower boundary to 0xA0.
        if (bite === 0xE0)
          utf8_lower_boundary = 0xA0;
        // 2. If byte is 0xED, set utf-8 upper boundary to 0x9F.
        if (bite === 0xED)
          utf8_upper_boundary = 0x9F;
        // 3. Set utf-8 bytes needed to 2 and utf-8 code point to
        // byte  0xE0.
        utf8_bytes_needed = 2;
        utf8_code_point = bite - 0xE0;
      }

      // 0xF0 to 0xF4
      else if (inRange(bite, 0xF0, 0xF4)) {
        // 1. If byte is 0xF0, set utf-8 lower boundary to 0x90.
        if (bite === 0xF0)
          utf8_lower_boundary = 0x90;
        // 2. If byte is 0xF4, set utf-8 upper boundary to 0x8F.
        if (bite === 0xF4)
          utf8_upper_boundary = 0x8F;
        // 3. Set utf-8 bytes needed to 3 and utf-8 code point to
        // byte  0xF0.
        utf8_bytes_needed = 3;
        utf8_code_point = bite - 0xF0;
      }

      // Otherwise
      else {
        // Return error.
        return decoderError(fatal);
      }

      // Then (byte is in the range 0xC2 to 0xF4) set utf-8 code
      // point to utf-8 code point << (6  utf-8 bytes needed) and
      // return continue.
      utf8_code_point = utf8_code_point << (6 * utf8_bytes_needed);
      return null;
    }

    // 4. If byte is not in the range utf-8 lower boundary to utf-8
    // upper boundary, run these substeps:
    if (!inRange(bite, utf8_lower_boundary, utf8_upper_boundary)) {

      // 1. Set utf-8 code point, utf-8 bytes needed, and utf-8
      // bytes seen to 0, set utf-8 lower boundary to 0x80, and set
      // utf-8 upper boundary to 0xBF.
      utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
      utf8_lower_boundary = 0x80;
      utf8_upper_boundary = 0xBF;

      // 2. Prepend byte to stream.
      stream.prepend(bite);

      // 3. Return error.
      return decoderError(fatal);
    }

    // 5. Set utf-8 lower boundary to 0x80 and utf-8 upper boundary
    // to 0xBF.
    utf8_lower_boundary = 0x80;
    utf8_upper_boundary = 0xBF;

    // 6. Increase utf-8 bytes seen by one and set utf-8 code point
    // to utf-8 code point + (byte  0x80) << (6  (utf-8 bytes
    // needed  utf-8 bytes seen)).
    utf8_bytes_seen += 1;
    utf8_code_point += (bite - 0x80) << (6 * (utf8_bytes_needed - utf8_bytes_seen));

    // 7. If utf-8 bytes seen is not equal to utf-8 bytes needed,
    // continue.
    if (utf8_bytes_seen !== utf8_bytes_needed)
      return null;

    // 8. Let code point be utf-8 code point.
    var code_point = utf8_code_point;

    // 9. Set utf-8 code point, utf-8 bytes needed, and utf-8 bytes
    // seen to 0.
    utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;

    // 10. Return a code point whose value is code point.
    return code_point;
  };
}

/**
 * @constructor
 * @implements {Encoder}
 * @param {{fatal: boolean}} options
 */
function UTF8Encoder(options) {
  var fatal = options.fatal;
  /**
   * @param {Stream} stream Input stream.
   * @param {number} code_point Next code point read from the stream.
   * @return {(number|!Array.<number>)} Byte(s) to emit.
   */
  this.handler = function(stream, code_point) {
    // 1. If code point is end-of-stream, return finished.
    if (code_point === end_of_stream)
      return finished;

    // 2. If code point is in the range U+0000 to U+007F, return a
    // byte whose value is code point.
    if (inRange(code_point, 0x0000, 0x007f))
      return code_point;

    // 3. Set count and offset based on the range code point is in:
    var count, offset;
    // U+0080 to U+07FF:    1 and 0xC0
    if (inRange(code_point, 0x0080, 0x07FF)) {
      count = 1;
      offset = 0xC0;
    }
    // U+0800 to U+FFFF:    2 and 0xE0
    else if (inRange(code_point, 0x0800, 0xFFFF)) {
      count = 2;
      offset = 0xE0;
    }
    // U+10000 to U+10FFFF: 3 and 0xF0
    else if (inRange(code_point, 0x10000, 0x10FFFF)) {
      count = 3;
      offset = 0xF0;
    }

    // 4.Let bytes be a byte sequence whose first byte is (code
    // point >> (6  count)) + offset.
    var bytes = [(code_point >> (6 * count)) + offset];

    // 5. Run these substeps while count is greater than 0:
    while (count > 0) {

      // 1. Set temp to code point >> (6  (count  1)).
      var temp = code_point >> (6 * (count - 1));

      // 2. Append to bytes 0x80 | (temp & 0x3F).
      bytes.push(0x80 | (temp & 0x3F));

      // 3. Decrease count by one.
      count -= 1;
    }

    // 6. Return bytes bytes, in order.
    return bytes;
  };
}

exports.TextEncoder = TextEncoder;
exports.TextDecoder = TextDecoder;
},{}],229:[function(require,module,exports){
/** @license URI.js v4.4.0 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.URI = global.URI || {})));
}(this, (function (exports) { 'use strict';

function merge() {
    for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {
        sets[_key] = arguments[_key];
    }

    if (sets.length > 1) {
        sets[0] = sets[0].slice(0, -1);
        var xl = sets.length - 1;
        for (var x = 1; x < xl; ++x) {
            sets[x] = sets[x].slice(1, -1);
        }
        sets[xl] = sets[xl].slice(1);
        return sets.join('');
    } else {
        return sets[0];
    }
}
function subexp(str) {
    return "(?:" + str + ")";
}
function typeOf(o) {
    return o === undefined ? "undefined" : o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
}
function toUpperCase(str) {
    return str.toUpperCase();
}
function toArray(obj) {
    return obj !== undefined && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];
}
function assign(target, source) {
    var obj = target;
    if (source) {
        for (var key in source) {
            obj[key] = source[key];
        }
    }
    return obj;
}

function buildExps(isIRI) {
    var ALPHA$$ = "[A-Za-z]",
        CR$ = "[\\x0D]",
        DIGIT$$ = "[0-9]",
        DQUOTE$$ = "[\\x22]",
        HEXDIG$$ = merge(DIGIT$$, "[A-Fa-f]"),
        //case-insensitive
    LF$$ = "[\\x0A]",
        SP$$ = "[\\x20]",
        PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)),
        //expanded
    GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]",
        SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]",
        RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$),
        UCSCHAR$$ = isIRI ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]",
        //subset, excludes bidi control characters
    IPRIVATE$$ = isIRI ? "[\\uE000-\\uF8FF]" : "[]",
        //subset
    UNRESERVED$$ = merge(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$),
        SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*"),
        USERINFO$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:]")) + "*"),
        DEC_OCTET$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("[1-9]" + DIGIT$$) + "|" + DIGIT$$),
        DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$),
        //relaxed parsing rules
    IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$),
        H16$ = subexp(HEXDIG$$ + "{1,4}"),
        LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$),
        IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$),
        //                           6( h16 ":" ) ls32
    IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$),
        //                      "::" 5( h16 ":" ) ls32
    IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$),
        //[               h16 ] "::" 4( h16 ":" ) ls32
    IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$),
        //[ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
    IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$),
        //[ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
    IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$),
        //[ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
    IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$),
        //[ *4( h16 ":" ) h16 ] "::"              ls32
    IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$),
        //[ *5( h16 ":" ) h16 ] "::"              h16
    IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"),
        //[ *6( h16 ":" ) h16 ] "::"
    IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join("|")),
        ZONEID$ = subexp(subexp(UNRESERVED$$ + "|" + PCT_ENCODED$) + "+"),
        //RFC 6874
    IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + "\\%25" + ZONEID$),
        //RFC 6874
    IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp("\\%25|\\%(?!" + HEXDIG$$ + "{2})") + ZONEID$),
        //RFC 6874, with relaxed parsing rules
    IPVFUTURE$ = subexp("[vV]" + HEXDIG$$ + "+\\." + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:]") + "+"),
        IP_LITERAL$ = subexp("\\[" + subexp(IPV6ADDRZ_RELAXED$ + "|" + IPV6ADDRESS$ + "|" + IPVFUTURE$) + "\\]"),
        //RFC 6874
    REG_NAME$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$)) + "*"),
        HOST$ = subexp(IP_LITERAL$ + "|" + IPV4ADDRESS$ + "(?!" + REG_NAME$ + ")" + "|" + REG_NAME$),
        PORT$ = subexp(DIGIT$$ + "*"),
        AUTHORITY$ = subexp(subexp(USERINFO$ + "@") + "?" + HOST$ + subexp("\\:" + PORT$) + "?"),
        PCHAR$ = subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@]")),
        SEGMENT$ = subexp(PCHAR$ + "*"),
        SEGMENT_NZ$ = subexp(PCHAR$ + "+"),
        SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\@]")) + "+"),
        PATH_ABEMPTY$ = subexp(subexp("\\/" + SEGMENT$) + "*"),
        PATH_ABSOLUTE$ = subexp("\\/" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + "?"),
        //simplified
    PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$),
        //simplified
    PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$),
        //simplified
    PATH_EMPTY$ = "(?!" + PCHAR$ + ")",
        PATH$ = subexp(PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$),
        QUERY$ = subexp(subexp(PCHAR$ + "|" + merge("[\\/\\?]", IPRIVATE$$)) + "*"),
        FRAGMENT$ = subexp(subexp(PCHAR$ + "|[\\/\\?]") + "*"),
        HIER_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$),
        URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"),
        RELATIVE_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$),
        RELATIVE$ = subexp(RELATIVE_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"),
        URI_REFERENCE$ = subexp(URI$ + "|" + RELATIVE$),
        ABSOLUTE_URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?"),
        GENERIC_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$",
        RELATIVE_REF$ = "^(){0}" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$",
        ABSOLUTE_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?$",
        SAMEDOC_REF$ = "^" + subexp("\\#(" + FRAGMENT$ + ")") + "?$",
        AUTHORITY_REF$ = "^" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?$";
    return {
        NOT_SCHEME: new RegExp(merge("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
        NOT_USERINFO: new RegExp(merge("[^\\%\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
        NOT_HOST: new RegExp(merge("[^\\%\\[\\]\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
        NOT_PATH: new RegExp(merge("[^\\%\\/\\:\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
        NOT_PATH_NOSCHEME: new RegExp(merge("[^\\%\\/\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
        NOT_QUERY: new RegExp(merge("[^\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
        NOT_FRAGMENT: new RegExp(merge("[^\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
        ESCAPE: new RegExp(merge("[^]", UNRESERVED$$, SUB_DELIMS$$), "g"),
        UNRESERVED: new RegExp(UNRESERVED$$, "g"),
        OTHER_CHARS: new RegExp(merge("[^\\%]", UNRESERVED$$, RESERVED$$), "g"),
        PCT_ENCODED: new RegExp(PCT_ENCODED$, "g"),
        IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
        IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$ + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$") //RFC 6874, with relaxed parsing rules
    };
}
var URI_PROTOCOL = buildExps(false);

var IRI_PROTOCOL = buildExps(true);

var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();













var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

/** Highest positive signed 32-bit float value */

var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1

/** Bootstring parameters */
var base = 36;
var tMin = 1;
var tMax = 26;
var skew = 38;
var damp = 700;
var initialBias = 72;
var initialN = 128; // 0x80
var delimiter = '-'; // '\x2D'

/** Regular expressions */
var regexPunycode = /^xn--/;
var regexNonASCII = /[^\0-\x7E]/; // non-ASCII chars
var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g; // RFC 3490 separators

/** Error messages */
var errors = {
	'overflow': 'Overflow: input needs wider integers to process',
	'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
	'invalid-input': 'Invalid input'
};

/** Convenience shortcuts */
var baseMinusTMin = base - tMin;
var floor = Math.floor;
var stringFromCharCode = String.fromCharCode;

/*--------------------------------------------------------------------------*/

/**
 * A generic error utility function.
 * @private
 * @param {String} type The error type.
 * @returns {Error} Throws a `RangeError` with the applicable error message.
 */
function error$1(type) {
	throw new RangeError(errors[type]);
}

/**
 * A generic `Array#map` utility function.
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} callback The function that gets called for every array
 * item.
 * @returns {Array} A new array of values returned by the callback function.
 */
function map(array, fn) {
	var result = [];
	var length = array.length;
	while (length--) {
		result[length] = fn(array[length]);
	}
	return result;
}

/**
 * A simple `Array#map`-like wrapper to work with domain name strings or email
 * addresses.
 * @private
 * @param {String} domain The domain name or email address.
 * @param {Function} callback The function that gets called for every
 * character.
 * @returns {Array} A new string of characters returned by the callback
 * function.
 */
function mapDomain(string, fn) {
	var parts = string.split('@');
	var result = '';
	if (parts.length > 1) {
		// In email addresses, only the domain name should be punycoded. Leave
		// the local part (i.e. everything up to `@`) intact.
		result = parts[0] + '@';
		string = parts[1];
	}
	// Avoid `split(regex)` for IE8 compatibility. See #17.
	string = string.replace(regexSeparators, '\x2E');
	var labels = string.split('.');
	var encoded = map(labels, fn).join('.');
	return result + encoded;
}

/**
 * Creates an array containing the numeric code points of each Unicode
 * character in the string. While JavaScript uses UCS-2 internally,
 * this function will convert a pair of surrogate halves (each of which
 * UCS-2 exposes as separate characters) into a single code point,
 * matching UTF-16.
 * @see `punycode.ucs2.encode`
 * @see <https://mathiasbynens.be/notes/javascript-encoding>
 * @memberOf punycode.ucs2
 * @name decode
 * @param {String} string The Unicode input string (UCS-2).
 * @returns {Array} The new array of code points.
 */
function ucs2decode(string) {
	var output = [];
	var counter = 0;
	var length = string.length;
	while (counter < length) {
		var value = string.charCodeAt(counter++);
		if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
			// It's a high surrogate, and there is a next character.
			var extra = string.charCodeAt(counter++);
			if ((extra & 0xFC00) == 0xDC00) {
				// Low surrogate.
				output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
			} else {
				// It's an unmatched surrogate; only append this code unit, in case the
				// next code unit is the high surrogate of a surrogate pair.
				output.push(value);
				counter--;
			}
		} else {
			output.push(value);
		}
	}
	return output;
}

/**
 * Creates a string based on an array of numeric code points.
 * @see `punycode.ucs2.decode`
 * @memberOf punycode.ucs2
 * @name encode
 * @param {Array} codePoints The array of numeric code points.
 * @returns {String} The new Unicode string (UCS-2).
 */
var ucs2encode = function ucs2encode(array) {
	return String.fromCodePoint.apply(String, toConsumableArray(array));
};

/**
 * Converts a basic code point into a digit/integer.
 * @see `digitToBasic()`
 * @private
 * @param {Number} codePoint The basic numeric code point value.
 * @returns {Number} The numeric value of a basic code point (for use in
 * representing integers) in the range `0` to `base - 1`, or `base` if
 * the code point does not represent a value.
 */
var basicToDigit = function basicToDigit(codePoint) {
	if (codePoint - 0x30 < 0x0A) {
		return codePoint - 0x16;
	}
	if (codePoint - 0x41 < 0x1A) {
		return codePoint - 0x41;
	}
	if (codePoint - 0x61 < 0x1A) {
		return codePoint - 0x61;
	}
	return base;
};

/**
 * Converts a digit/integer into a basic code point.
 * @see `basicToDigit()`
 * @private
 * @param {Number} digit The numeric value of a basic code point.
 * @returns {Number} The basic code point whose value (when used for
 * representing integers) is `digit`, which needs to be in the range
 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
 * used; else, the lowercase form is used. The behavior is undefined
 * if `flag` is non-zero and `digit` has no uppercase form.
 */
var digitToBasic = function digitToBasic(digit, flag) {
	//  0..25 map to ASCII a..z or A..Z
	// 26..35 map to ASCII 0..9
	return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
};

/**
 * Bias adaptation function as per section 3.4 of RFC 3492.
 * https://tools.ietf.org/html/rfc3492#section-3.4
 * @private
 */
var adapt = function adapt(delta, numPoints, firstTime) {
	var k = 0;
	delta = firstTime ? floor(delta / damp) : delta >> 1;
	delta += floor(delta / numPoints);
	for (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {
		delta = floor(delta / baseMinusTMin);
	}
	return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
};

/**
 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
 * symbols.
 * @memberOf punycode
 * @param {String} input The Punycode string of ASCII-only symbols.
 * @returns {String} The resulting string of Unicode symbols.
 */
var decode = function decode(input) {
	// Don't use UCS-2.
	var output = [];
	var inputLength = input.length;
	var i = 0;
	var n = initialN;
	var bias = initialBias;

	// Handle the basic code points: let `basic` be the number of input code
	// points before the last delimiter, or `0` if there is none, then copy
	// the first basic code points to the output.

	var basic = input.lastIndexOf(delimiter);
	if (basic < 0) {
		basic = 0;
	}

	for (var j = 0; j < basic; ++j) {
		// if it's not a basic code point
		if (input.charCodeAt(j) >= 0x80) {
			error$1('not-basic');
		}
		output.push(input.charCodeAt(j));
	}

	// Main decoding loop: start just after the last delimiter if any basic code
	// points were copied; start at the beginning otherwise.

	for (var index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{

		// `index` is the index of the next character to be consumed.
		// Decode a generalized variable-length integer into `delta`,
		// which gets added to `i`. The overflow checking is easier
		// if we increase `i` as we go, then subtract off its starting
		// value at the end to obtain `delta`.
		var oldi = i;
		for (var w = 1, k = base;; /* no condition */k += base) {

			if (index >= inputLength) {
				error$1('invalid-input');
			}

			var digit = basicToDigit(input.charCodeAt(index++));

			if (digit >= base || digit > floor((maxInt - i) / w)) {
				error$1('overflow');
			}

			i += digit * w;
			var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

			if (digit < t) {
				break;
			}

			var baseMinusT = base - t;
			if (w > floor(maxInt / baseMinusT)) {
				error$1('overflow');
			}

			w *= baseMinusT;
		}

		var out = output.length + 1;
		bias = adapt(i - oldi, out, oldi == 0);

		// `i` was supposed to wrap around from `out` to `0`,
		// incrementing `n` each time, so we'll fix that now:
		if (floor(i / out) > maxInt - n) {
			error$1('overflow');
		}

		n += floor(i / out);
		i %= out;

		// Insert `n` at position `i` of the output.
		output.splice(i++, 0, n);
	}

	return String.fromCodePoint.apply(String, output);
};

/**
 * Converts a string of Unicode symbols (e.g. a domain name label) to a
 * Punycode string of ASCII-only symbols.
 * @memberOf punycode
 * @param {String} input The string of Unicode symbols.
 * @returns {String} The resulting Punycode string of ASCII-only symbols.
 */
var encode = function encode(input) {
	var output = [];

	// Convert the input in UCS-2 to an array of Unicode code points.
	input = ucs2decode(input);

	// Cache the length.
	var inputLength = input.length;

	// Initialize the state.
	var n = initialN;
	var delta = 0;
	var bias = initialBias;

	// Handle the basic code points.
	var _iteratorNormalCompletion = true;
	var _didIteratorError = false;
	var _iteratorError = undefined;

	try {
		for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
			var _currentValue2 = _step.value;

			if (_currentValue2 < 0x80) {
				output.push(stringFromCharCode(_currentValue2));
			}
		}
	} catch (err) {
		_didIteratorError = true;
		_iteratorError = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion && _iterator.return) {
				_iterator.return();
			}
		} finally {
			if (_didIteratorError) {
				throw _iteratorError;
			}
		}
	}

	var basicLength = output.length;
	var handledCPCount = basicLength;

	// `handledCPCount` is the number of code points that have been handled;
	// `basicLength` is the number of basic code points.

	// Finish the basic string with a delimiter unless it's empty.
	if (basicLength) {
		output.push(delimiter);
	}

	// Main encoding loop:
	while (handledCPCount < inputLength) {

		// All non-basic code points < n have been handled already. Find the next
		// larger one:
		var m = maxInt;
		var _iteratorNormalCompletion2 = true;
		var _didIteratorError2 = false;
		var _iteratorError2 = undefined;

		try {
			for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
				var currentValue = _step2.value;

				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow.
		} catch (err) {
			_didIteratorError2 = true;
			_iteratorError2 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion2 && _iterator2.return) {
					_iterator2.return();
				}
			} finally {
				if (_didIteratorError2) {
					throw _iteratorError2;
				}
			}
		}

		var handledCPCountPlusOne = handledCPCount + 1;
		if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
			error$1('overflow');
		}

		delta += (m - n) * handledCPCountPlusOne;
		n = m;

		var _iteratorNormalCompletion3 = true;
		var _didIteratorError3 = false;
		var _iteratorError3 = undefined;

		try {
			for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
				var _currentValue = _step3.value;

				if (_currentValue < n && ++delta > maxInt) {
					error$1('overflow');
				}
				if (_currentValue == n) {
					// Represent delta as a generalized variable-length integer.
					var q = delta;
					for (var k = base;; /* no condition */k += base) {
						var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
						if (q < t) {
							break;
						}
						var qMinusT = q - t;
						var baseMinusT = base - t;
						output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}
		} catch (err) {
			_didIteratorError3 = true;
			_iteratorError3 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion3 && _iterator3.return) {
					_iterator3.return();
				}
			} finally {
				if (_didIteratorError3) {
					throw _iteratorError3;
				}
			}
		}

		++delta;
		++n;
	}
	return output.join('');
};

/**
 * Converts a Punycode string representing a domain name or an email address
 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
 * it doesn't matter if you call it on a string that has already been
 * converted to Unicode.
 * @memberOf punycode
 * @param {String} input The Punycoded domain name or email address to
 * convert to Unicode.
 * @returns {String} The Unicode representation of the given Punycode
 * string.
 */
var toUnicode = function toUnicode(input) {
	return mapDomain(input, function (string) {
		return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
	});
};

/**
 * Converts a Unicode string representing a domain name or an email address to
 * Punycode. Only the non-ASCII parts of the domain name will be converted,
 * i.e. it doesn't matter if you call it with a domain that's already in
 * ASCII.
 * @memberOf punycode
 * @param {String} input The domain name or email address to convert, as a
 * Unicode string.
 * @returns {String} The Punycode representation of the given domain name or
 * email address.
 */
var toASCII = function toASCII(input) {
	return mapDomain(input, function (string) {
		return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
	});
};

/*--------------------------------------------------------------------------*/

/** Define the public API */
var punycode = {
	/**
  * A string representing the current Punycode.js version number.
  * @memberOf punycode
  * @type String
  */
	'version': '2.1.0',
	/**
  * An object of methods to convert from JavaScript's internal character
  * representation (UCS-2) to Unicode code points, and back.
  * @see <https://mathiasbynens.be/notes/javascript-encoding>
  * @memberOf punycode
  * @type Object
  */
	'ucs2': {
		'decode': ucs2decode,
		'encode': ucs2encode
	},
	'decode': decode,
	'encode': encode,
	'toASCII': toASCII,
	'toUnicode': toUnicode
};

/**
 * URI.js
 *
 * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.
 * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
 * @see http://github.com/garycourt/uri-js
 */
/**
 * Copyright 2011 Gary Court. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are
 * permitted provided that the following conditions are met:
 *
 *    1. Redistributions of source code must retain the above copyright notice, this list of
 *       conditions and the following disclaimer.
 *
 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
 *       of conditions and the following disclaimer in the documentation and/or other materials
 *       provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation are those of the
 * authors and should not be interpreted as representing official policies, either expressed
 * or implied, of Gary Court.
 */
var SCHEMES = {};
function pctEncChar(chr) {
    var c = chr.charCodeAt(0);
    var e = void 0;
    if (c < 16) e = "%0" + c.toString(16).toUpperCase();else if (c < 128) e = "%" + c.toString(16).toUpperCase();else if (c < 2048) e = "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();else e = "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
    return e;
}
function pctDecChars(str) {
    var newStr = "";
    var i = 0;
    var il = str.length;
    while (i < il) {
        var c = parseInt(str.substr(i + 1, 2), 16);
        if (c < 128) {
            newStr += String.fromCharCode(c);
            i += 3;
        } else if (c >= 194 && c < 224) {
            if (il - i >= 6) {
                var c2 = parseInt(str.substr(i + 4, 2), 16);
                newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);
            } else {
                newStr += str.substr(i, 6);
            }
            i += 6;
        } else if (c >= 224) {
            if (il - i >= 9) {
                var _c = parseInt(str.substr(i + 4, 2), 16);
                var c3 = parseInt(str.substr(i + 7, 2), 16);
                newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);
            } else {
                newStr += str.substr(i, 9);
            }
            i += 9;
        } else {
            newStr += str.substr(i, 3);
            i += 3;
        }
    }
    return newStr;
}
function _normalizeComponentEncoding(components, protocol) {
    function decodeUnreserved(str) {
        var decStr = pctDecChars(str);
        return !decStr.match(protocol.UNRESERVED) ? str : decStr;
    }
    if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, "");
    if (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    return components;
}

function _stripLeadingZeros(str) {
    return str.replace(/^0*(.*)/, "$1") || "0";
}
function _normalizeIPv4(host, protocol) {
    var matches = host.match(protocol.IPV4ADDRESS) || [];

    var _matches = slicedToArray(matches, 2),
        address = _matches[1];

    if (address) {
        return address.split(".").map(_stripLeadingZeros).join(".");
    } else {
        return host;
    }
}
function _normalizeIPv6(host, protocol) {
    var matches = host.match(protocol.IPV6ADDRESS) || [];

    var _matches2 = slicedToArray(matches, 3),
        address = _matches2[1],
        zone = _matches2[2];

    if (address) {
        var _address$toLowerCase$ = address.toLowerCase().split('::').reverse(),
            _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2),
            last = _address$toLowerCase$2[0],
            first = _address$toLowerCase$2[1];

        var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
        var lastFields = last.split(":").map(_stripLeadingZeros);
        var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
        var fieldCount = isLastFieldIPv4Address ? 7 : 8;
        var lastFieldsStart = lastFields.length - fieldCount;
        var fields = Array(fieldCount);
        for (var x = 0; x < fieldCount; ++x) {
            fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || '';
        }
        if (isLastFieldIPv4Address) {
            fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
        }
        var allZeroFields = fields.reduce(function (acc, field, index) {
            if (!field || field === "0") {
                var lastLongest = acc[acc.length - 1];
                if (lastLongest && lastLongest.index + lastLongest.length === index) {
                    lastLongest.length++;
                } else {
                    acc.push({ index: index, length: 1 });
                }
            }
            return acc;
        }, []);
        var longestZeroFields = allZeroFields.sort(function (a, b) {
            return b.length - a.length;
        })[0];
        var newHost = void 0;
        if (longestZeroFields && longestZeroFields.length > 1) {
            var newFirst = fields.slice(0, longestZeroFields.index);
            var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
            newHost = newFirst.join(":") + "::" + newLast.join(":");
        } else {
            newHost = fields.join(":");
        }
        if (zone) {
            newHost += "%" + zone;
        }
        return newHost;
    } else {
        return host;
    }
}
var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === undefined;
function parse(uriString) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var components = {};
    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
    if (options.reference === "suffix") uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
    var matches = uriString.match(URI_PARSE);
    if (matches) {
        if (NO_MATCH_IS_UNDEFINED) {
            //store each component
            components.scheme = matches[1];
            components.userinfo = matches[3];
            components.host = matches[4];
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || "";
            components.query = matches[7];
            components.fragment = matches[8];
            //fix port number
            if (isNaN(components.port)) {
                components.port = matches[5];
            }
        } else {
            //IE FIX for improper RegExp matching
            //store each component
            components.scheme = matches[1] || undefined;
            components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : undefined;
            components.host = uriString.indexOf("//") !== -1 ? matches[4] : undefined;
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || "";
            components.query = uriString.indexOf("?") !== -1 ? matches[7] : undefined;
            components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : undefined;
            //fix port number
            if (isNaN(components.port)) {
                components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : undefined;
            }
        }
        if (components.host) {
            //normalize IP hosts
            components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
        }
        //determine reference type
        if (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {
            components.reference = "same-document";
        } else if (components.scheme === undefined) {
            components.reference = "relative";
        } else if (components.fragment === undefined) {
            components.reference = "absolute";
        } else {
            components.reference = "uri";
        }
        //check for reference errors
        if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
            components.error = components.error || "URI is not a " + options.reference + " reference.";
        }
        //find scheme handler
        var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
        //check if scheme can't handle IRIs
        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
            //if host component is a domain name
            if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {
                //convert Unicode IDN -> ASCII IDN
                try {
                    components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
                } catch (e) {
                    components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
                }
            }
            //convert IRI -> URI
            _normalizeComponentEncoding(components, URI_PROTOCOL);
        } else {
            //normalize encodings
            _normalizeComponentEncoding(components, protocol);
        }
        //perform scheme specific parsing
        if (schemeHandler && schemeHandler.parse) {
            schemeHandler.parse(components, options);
        }
    } else {
        components.error = components.error || "URI can not be parsed.";
    }
    return components;
}

function _recomposeAuthority(components, options) {
    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
    var uriTokens = [];
    if (components.userinfo !== undefined) {
        uriTokens.push(components.userinfo);
        uriTokens.push("@");
    }
    if (components.host !== undefined) {
        //normalize IP hosts, add brackets and escape zone separator for IPv6
        uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function (_, $1, $2) {
            return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
        }));
    }
    if (typeof components.port === "number" || typeof components.port === "string") {
        uriTokens.push(":");
        uriTokens.push(String(components.port));
    }
    return uriTokens.length ? uriTokens.join("") : undefined;
}

var RDS1 = /^\.\.?\//;
var RDS2 = /^\/\.(\/|$)/;
var RDS3 = /^\/\.\.(\/|$)/;
var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
function removeDotSegments(input) {
    var output = [];
    while (input.length) {
        if (input.match(RDS1)) {
            input = input.replace(RDS1, "");
        } else if (input.match(RDS2)) {
            input = input.replace(RDS2, "/");
        } else if (input.match(RDS3)) {
            input = input.replace(RDS3, "/");
            output.pop();
        } else if (input === "." || input === "..") {
            input = "";
        } else {
            var im = input.match(RDS5);
            if (im) {
                var s = im[0];
                input = input.slice(s.length);
                output.push(s);
            } else {
                throw new Error("Unexpected dot segment condition");
            }
        }
    }
    return output.join("");
}

function serialize(components) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
    var uriTokens = [];
    //find scheme handler
    var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
    //perform scheme specific serialization
    if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);
    if (components.host) {
        //if host component is an IPv6 address
        if (protocol.IPV6ADDRESS.test(components.host)) {}
        //TODO: normalize IPv6 address as per RFC 5952

        //if host component is a domain name
        else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {
                //convert IDN via punycode
                try {
                    components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
                } catch (e) {
                    components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
                }
            }
    }
    //normalize encoding
    _normalizeComponentEncoding(components, protocol);
    if (options.reference !== "suffix" && components.scheme) {
        uriTokens.push(components.scheme);
        uriTokens.push(":");
    }
    var authority = _recomposeAuthority(components, options);
    if (authority !== undefined) {
        if (options.reference !== "suffix") {
            uriTokens.push("//");
        }
        uriTokens.push(authority);
        if (components.path && components.path.charAt(0) !== "/") {
            uriTokens.push("/");
        }
    }
    if (components.path !== undefined) {
        var s = components.path;
        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
            s = removeDotSegments(s);
        }
        if (authority === undefined) {
            s = s.replace(/^\/\//, "/%2F"); //don't allow the path to start with "//"
        }
        uriTokens.push(s);
    }
    if (components.query !== undefined) {
        uriTokens.push("?");
        uriTokens.push(components.query);
    }
    if (components.fragment !== undefined) {
        uriTokens.push("#");
        uriTokens.push(components.fragment);
    }
    return uriTokens.join(""); //merge tokens into a string
}

function resolveComponents(base, relative) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var skipNormalization = arguments[3];

    var target = {};
    if (!skipNormalization) {
        base = parse(serialize(base, options), options); //normalize base components
        relative = parse(serialize(relative, options), options); //normalize relative components
    }
    options = options || {};
    if (!options.tolerant && relative.scheme) {
        target.scheme = relative.scheme;
        //target.authority = relative.authority;
        target.userinfo = relative.userinfo;
        target.host = relative.host;
        target.port = relative.port;
        target.path = removeDotSegments(relative.path || "");
        target.query = relative.query;
    } else {
        if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {
            //target.authority = relative.authority;
            target.userinfo = relative.userinfo;
            target.host = relative.host;
            target.port = relative.port;
            target.path = removeDotSegments(relative.path || "");
            target.query = relative.query;
        } else {
            if (!relative.path) {
                target.path = base.path;
                if (relative.query !== undefined) {
                    target.query = relative.query;
                } else {
                    target.query = base.query;
                }
            } else {
                if (relative.path.charAt(0) === "/") {
                    target.path = removeDotSegments(relative.path);
                } else {
                    if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {
                        target.path = "/" + relative.path;
                    } else if (!base.path) {
                        target.path = relative.path;
                    } else {
                        target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
                    }
                    target.path = removeDotSegments(target.path);
                }
                target.query = relative.query;
            }
            //target.authority = base.authority;
            target.userinfo = base.userinfo;
            target.host = base.host;
            target.port = base.port;
        }
        target.scheme = base.scheme;
    }
    target.fragment = relative.fragment;
    return target;
}

function resolve(baseURI, relativeURI, options) {
    var schemelessOptions = assign({ scheme: 'null' }, options);
    return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
}

function normalize(uri, options) {
    if (typeof uri === "string") {
        uri = serialize(parse(uri, options), options);
    } else if (typeOf(uri) === "object") {
        uri = parse(serialize(uri, options), options);
    }
    return uri;
}

function equal(uriA, uriB, options) {
    if (typeof uriA === "string") {
        uriA = serialize(parse(uriA, options), options);
    } else if (typeOf(uriA) === "object") {
        uriA = serialize(uriA, options);
    }
    if (typeof uriB === "string") {
        uriB = serialize(parse(uriB, options), options);
    } else if (typeOf(uriB) === "object") {
        uriB = serialize(uriB, options);
    }
    return uriA === uriB;
}

function escapeComponent(str, options) {
    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
}

function unescapeComponent(str, options) {
    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
}

var handler = {
    scheme: "http",
    domainHost: true,
    parse: function parse(components, options) {
        //report missing host
        if (!components.host) {
            components.error = components.error || "HTTP URIs must have a host.";
        }
        return components;
    },
    serialize: function serialize(components, options) {
        var secure = String(components.scheme).toLowerCase() === "https";
        //normalize the default port
        if (components.port === (secure ? 443 : 80) || components.port === "") {
            components.port = undefined;
        }
        //normalize the empty path
        if (!components.path) {
            components.path = "/";
        }
        //NOTE: We do not parse query strings for HTTP URIs
        //as WWW Form Url Encoded query strings are part of the HTML4+ spec,
        //and not the HTTP spec.
        return components;
    }
};

var handler$1 = {
    scheme: "https",
    domainHost: handler.domainHost,
    parse: handler.parse,
    serialize: handler.serialize
};

function isSecure(wsComponents) {
    return typeof wsComponents.secure === 'boolean' ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
}
//RFC 6455
var handler$2 = {
    scheme: "ws",
    domainHost: true,
    parse: function parse(components, options) {
        var wsComponents = components;
        //indicate if the secure flag is set
        wsComponents.secure = isSecure(wsComponents);
        //construct resouce name
        wsComponents.resourceName = (wsComponents.path || '/') + (wsComponents.query ? '?' + wsComponents.query : '');
        wsComponents.path = undefined;
        wsComponents.query = undefined;
        return wsComponents;
    },
    serialize: function serialize(wsComponents, options) {
        //normalize the default port
        if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
            wsComponents.port = undefined;
        }
        //ensure scheme matches secure flag
        if (typeof wsComponents.secure === 'boolean') {
            wsComponents.scheme = wsComponents.secure ? 'wss' : 'ws';
            wsComponents.secure = undefined;
        }
        //reconstruct path from resource name
        if (wsComponents.resourceName) {
            var _wsComponents$resourc = wsComponents.resourceName.split('?'),
                _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2),
                path = _wsComponents$resourc2[0],
                query = _wsComponents$resourc2[1];

            wsComponents.path = path && path !== '/' ? path : undefined;
            wsComponents.query = query;
            wsComponents.resourceName = undefined;
        }
        //forbid fragment component
        wsComponents.fragment = undefined;
        return wsComponents;
    }
};

var handler$3 = {
    scheme: "wss",
    domainHost: handler$2.domainHost,
    parse: handler$2.parse,
    serialize: handler$2.serialize
};

var O = {};
var isIRI = true;
//RFC 3986
var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~" + (isIRI ? "\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF" : "") + "]";
var HEXDIG$$ = "[0-9A-Fa-f]"; //case-insensitive
var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)); //expanded
//RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =
//const ATEXT$$ = "[A-Za-z0-9\\!\\#\\$\\%\\&\\'\\*\\+\\-\\/\\=\\?\\^\\_\\`\\{\\|\\}\\~]";
//const WSP$$ = "[\\x20\\x09]";
//const OBS_QTEXT$$ = "[\\x01-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]";  //(%d1-8 / %d11-12 / %d14-31 / %d127)
//const QTEXT$$ = merge("[\\x21\\x23-\\x5B\\x5D-\\x7E]", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext
//const VCHAR$$ = "[\\x21-\\x7E]";
//const WSP$$ = "[\\x20\\x09]";
//const OBS_QP$ = subexp("\\\\" + merge("[\\x00\\x0D\\x0A]", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext
//const FWS$ = subexp(subexp(WSP$$ + "*" + "\\x0D\\x0A") + "?" + WSP$$ + "+");
//const QUOTED_PAIR$ = subexp(subexp("\\\\" + subexp(VCHAR$$ + "|" + WSP$$)) + "|" + OBS_QP$);
//const QUOTED_STRING$ = subexp('\\"' + subexp(FWS$ + "?" + QCONTENT$) + "*" + FWS$ + "?" + '\\"');
var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
var VCHAR$$ = merge(QTEXT$$, "[\\\"\\\\]");
var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
var UNRESERVED = new RegExp(UNRESERVED$$, "g");
var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
var NOT_LOCAL_PART = new RegExp(merge("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
var NOT_HFNAME = new RegExp(merge("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
var NOT_HFVALUE = NOT_HFNAME;
function decodeUnreserved(str) {
    var decStr = pctDecChars(str);
    return !decStr.match(UNRESERVED) ? str : decStr;
}
var handler$4 = {
    scheme: "mailto",
    parse: function parse$$1(components, options) {
        var mailtoComponents = components;
        var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
        mailtoComponents.path = undefined;
        if (mailtoComponents.query) {
            var unknownHeaders = false;
            var headers = {};
            var hfields = mailtoComponents.query.split("&");
            for (var x = 0, xl = hfields.length; x < xl; ++x) {
                var hfield = hfields[x].split("=");
                switch (hfield[0]) {
                    case "to":
                        var toAddrs = hfield[1].split(",");
                        for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
                            to.push(toAddrs[_x]);
                        }
                        break;
                    case "subject":
                        mailtoComponents.subject = unescapeComponent(hfield[1], options);
                        break;
                    case "body":
                        mailtoComponents.body = unescapeComponent(hfield[1], options);
                        break;
                    default:
                        unknownHeaders = true;
                        headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
                        break;
                }
            }
            if (unknownHeaders) mailtoComponents.headers = headers;
        }
        mailtoComponents.query = undefined;
        for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
            var addr = to[_x2].split("@");
            addr[0] = unescapeComponent(addr[0]);
            if (!options.unicodeSupport) {
                //convert Unicode IDN -> ASCII IDN
                try {
                    addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
                } catch (e) {
                    mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
                }
            } else {
                addr[1] = unescapeComponent(addr[1], options).toLowerCase();
            }
            to[_x2] = addr.join("@");
        }
        return mailtoComponents;
    },
    serialize: function serialize$$1(mailtoComponents, options) {
        var components = mailtoComponents;
        var to = toArray(mailtoComponents.to);
        if (to) {
            for (var x = 0, xl = to.length; x < xl; ++x) {
                var toAddr = String(to[x]);
                var atIdx = toAddr.lastIndexOf("@");
                var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
                var domain = toAddr.slice(atIdx + 1);
                //convert IDN via punycode
                try {
                    domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
                } catch (e) {
                    components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
                }
                to[x] = localPart + "@" + domain;
            }
            components.path = to.join(",");
        }
        var headers = mailtoComponents.headers = mailtoComponents.headers || {};
        if (mailtoComponents.subject) headers["subject"] = mailtoComponents.subject;
        if (mailtoComponents.body) headers["body"] = mailtoComponents.body;
        var fields = [];
        for (var name in headers) {
            if (headers[name] !== O[name]) {
                fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
            }
        }
        if (fields.length) {
            components.query = fields.join("&");
        }
        return components;
    }
};

var URN_PARSE = /^([^\:]+)\:(.*)/;
//RFC 2141
var handler$5 = {
    scheme: "urn",
    parse: function parse$$1(components, options) {
        var matches = components.path && components.path.match(URN_PARSE);
        var urnComponents = components;
        if (matches) {
            var scheme = options.scheme || urnComponents.scheme || "urn";
            var nid = matches[1].toLowerCase();
            var nss = matches[2];
            var urnScheme = scheme + ":" + (options.nid || nid);
            var schemeHandler = SCHEMES[urnScheme];
            urnComponents.nid = nid;
            urnComponents.nss = nss;
            urnComponents.path = undefined;
            if (schemeHandler) {
                urnComponents = schemeHandler.parse(urnComponents, options);
            }
        } else {
            urnComponents.error = urnComponents.error || "URN can not be parsed.";
        }
        return urnComponents;
    },
    serialize: function serialize$$1(urnComponents, options) {
        var scheme = options.scheme || urnComponents.scheme || "urn";
        var nid = urnComponents.nid;
        var urnScheme = scheme + ":" + (options.nid || nid);
        var schemeHandler = SCHEMES[urnScheme];
        if (schemeHandler) {
            urnComponents = schemeHandler.serialize(urnComponents, options);
        }
        var uriComponents = urnComponents;
        var nss = urnComponents.nss;
        uriComponents.path = (nid || options.nid) + ":" + nss;
        return uriComponents;
    }
};

var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
//RFC 4122
var handler$6 = {
    scheme: "urn:uuid",
    parse: function parse(urnComponents, options) {
        var uuidComponents = urnComponents;
        uuidComponents.uuid = uuidComponents.nss;
        uuidComponents.nss = undefined;
        if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {
            uuidComponents.error = uuidComponents.error || "UUID is not valid.";
        }
        return uuidComponents;
    },
    serialize: function serialize(uuidComponents, options) {
        var urnComponents = uuidComponents;
        //normalize UUID
        urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
        return urnComponents;
    }
};

SCHEMES[handler.scheme] = handler;
SCHEMES[handler$1.scheme] = handler$1;
SCHEMES[handler$2.scheme] = handler$2;
SCHEMES[handler$3.scheme] = handler$3;
SCHEMES[handler$4.scheme] = handler$4;
SCHEMES[handler$5.scheme] = handler$5;
SCHEMES[handler$6.scheme] = handler$6;

exports.SCHEMES = SCHEMES;
exports.pctEncChar = pctEncChar;
exports.pctDecChars = pctDecChars;
exports.parse = parse;
exports.removeDotSegments = removeDotSegments;
exports.serialize = serialize;
exports.resolveComponents = resolveComponents;
exports.resolve = resolve;
exports.normalize = normalize;
exports.equal = equal;
exports.escapeComponent = escapeComponent;
exports.unescapeComponent = unescapeComponent;

Object.defineProperty(exports, '__esModule', { value: true });

})));


},{}],230:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.WRITE = exports.READ = exports.Driver = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _error = require("./error");

var _connectionProvider = _interopRequireDefault(require("./internal/connection-provider"));

var _bookmark = _interopRequireDefault(require("./internal/bookmark"));

var _connectionProviderDirect = _interopRequireDefault(require("./internal/connection-provider-direct"));

var _connectivityVerifier = _interopRequireDefault(require("./internal/connectivity-verifier"));

var _constants = require("./internal/constants");

var _logger = _interopRequireDefault(require("./internal/logger"));

var _poolConfig = require("./internal/pool-config");

var _session = _interopRequireDefault(require("./session"));

var _sessionRx = _interopRequireDefault(require("./session-rx"));

var _requestMessage = require("./internal/request-message");

var _util = require("./internal/util");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var DEFAULT_MAX_CONNECTION_LIFETIME = 60 * 60 * 1000; // 1 hour

/**
 * The default record fetch size. This is used in Bolt V4 protocol to pull query execution result in batches.
 * @type {number}
 */

var DEFAULT_FETCH_SIZE = 1000;
/**
 * Constant that represents read session access mode.
 * Should be used like this: `driver.session({ defaultAccessMode: neo4j.session.READ })`.
 * @type {string}
 */

var READ = _constants.ACCESS_MODE_READ;
/**
 * Constant that represents write session access mode.
 * Should be used like this: `driver.session({ defaultAccessMode: neo4j.session.WRITE })`.
 * @type {string}
 */

exports.READ = READ;
var WRITE = _constants.ACCESS_MODE_WRITE;
exports.WRITE = WRITE;
var idGenerator = 0;
/**
 * A driver maintains one or more {@link Session}s with a remote
 * Neo4j instance. Through the {@link Session}s you can send queries
 * and retrieve results from the database.
 *
 * Drivers are reasonably expensive to create - you should strive to keep one
 * driver instance around per Neo4j Instance you connect to.
 *
 * @access public
 */

var Driver =
/*#__PURE__*/
function () {
  /**
   * You should not be calling this directly, instead use {@link driver}.
   * @constructor
   * @protected
   * @param {ServerAddress} address
   * @param {string} userAgent
   * @param {Object} authToken
   * @param {Object} config
   */
  function Driver(address, userAgent) {
    var authToken = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var config = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    (0, _classCallCheck2["default"])(this, Driver);
    sanitizeConfig(config);
    this._id = idGenerator++;
    this._address = address;
    this._userAgent = userAgent;
    this._authToken = authToken;
    this._config = config;
    this._log = _logger["default"].create(config);
    /**
     * Reference to the connection provider. Initialized lazily by {@link _getOrCreateConnectionProvider}.
     * @type {ConnectionProvider}
     * @protected
     */

    this._connectionProvider = null;

    this._afterConstruction();
  }
  /**
   * Verifies connectivity of this driver by trying to open a connection with the provided driver options.
   *
   * @public
   * @param {Object} param - The object parameter
   * @param {string} param.database - The target database to verify connectivity for.
   * @returns {Promise<void>} promise resolved with server info or rejected with error.
   */


  (0, _createClass2["default"])(Driver, [{
    key: "verifyConnectivity",
    value: function verifyConnectivity() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$database = _ref.database,
          database = _ref$database === void 0 ? '' : _ref$database;

      var connectionProvider = this._getOrCreateConnectionProvider();

      var connectivityVerifier = new _connectivityVerifier["default"](connectionProvider);
      return connectivityVerifier.verify({
        database: database
      });
    }
    /**
     * Returns whether the server supports multi database capabilities based on the protocol
     * version negotiated via handshake.
     *
     * Note that this function call _always_ causes a round-trip to the server.
     *
     * @returns {Promise<boolean>} promise resolved with a boolean or rejected with error.
     */

  }, {
    key: "supportsMultiDb",
    value: function supportsMultiDb() {
      var connectionProvider = this._getOrCreateConnectionProvider();

      return connectionProvider.supportsMultiDb();
    }
    /**
     * Returns whether the server supports transaction config capabilities based on the protocol
     * version negotiated via handshake.
     *
     * Note that this function call _always_ causes a round-trip to the server.
     *
     * @returns {Promise<boolean>} promise resolved with a boolean or rejected with error.
     */

  }, {
    key: "supportsTransactionConfig",
    value: function supportsTransactionConfig() {
      var connectionProvider = this._getOrCreateConnectionProvider();

      return connectionProvider.supportsTransactionConfig();
    }
    /**
     * @protected
     * @returns {boolean}
     */

  }, {
    key: "_supportsRouting",
    value: function _supportsRouting() {
      return false;
    }
    /**
     * Returns boolean to indicate if driver has been configured with encryption enabled.
     *
     * @protected
     * @returns {boolean}
     */

  }, {
    key: "_isEncrypted",
    value: function _isEncrypted() {
      return this._config.encrypted === _util.ENCRYPTION_ON;
    }
    /**
     * Returns the configured trust strategy that the driver has been configured with.
     *
     * @protected
     * @returns {TrustStrategy}
     */

  }, {
    key: "_getTrust",
    value: function _getTrust() {
      return this._config.trust;
    }
    /**
     * Acquire a session to communicate with the database. The session will
     * borrow connections from the underlying connection pool as required and
     * should be considered lightweight and disposable.
     *
     * This comes with some responsibility - make sure you always call
     * {@link close} when you are done using a session, and likewise,
     * make sure you don't close your session before you are done using it. Once
     * it is closed, the underlying connection will be released to the connection
     * pool and made available for others to use.
     *
     * @public
     * @param {Object} param - The object parameter
     * @param {string} param.defaultAccessMode=WRITE - The access mode of this session, allowed values are {@link READ} and {@link WRITE}.
     * @param {string|string[]} param.bookmarks - The initial reference or references to some previous
     * transactions. Value is optional and absence indicates that that the bookmarks do not exist or are unknown.
     * @param {number} param.fetchSize - The record fetch size of each batch of this session.
     * Use {@link ALL} to always pull all records in one batch. This will override the config value set on driver config.
     * @param {string} param.database - The database this session will operate on.
     * @return {Session} new session.
     */

  }, {
    key: "session",
    value: function session() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref2$defaultAccessMo = _ref2.defaultAccessMode,
          defaultAccessMode = _ref2$defaultAccessMo === void 0 ? WRITE : _ref2$defaultAccessMo,
          bookmarkOrBookmarks = _ref2.bookmarks,
          _ref2$database = _ref2.database,
          database = _ref2$database === void 0 ? '' : _ref2$database,
          fetchSize = _ref2.fetchSize;

      return this._newSession({
        defaultAccessMode: defaultAccessMode,
        bookmarkOrBookmarks: bookmarkOrBookmarks,
        database: database,
        reactive: false,
        fetchSize: validateFetchSizeValue(fetchSize, this._config.fetchSize)
      });
    }
    /**
     * Acquire a reactive session to communicate with the database. The session will
     * borrow connections from the underlying connection pool as required and
     * should be considered lightweight and disposable.
     *
     * This comes with some responsibility - make sure you always call
     * {@link close} when you are done using a session, and likewise,
     * make sure you don't close your session before you are done using it. Once
     * it is closed, the underlying connection will be released to the connection
     * pool and made available for others to use.
     *
     * @public
     * @param {Object} param
     * @param {string} param.defaultAccessMode=WRITE - The access mode of this session, allowed values are {@link READ} and {@link WRITE}.
     * @param {string|string[]} param.bookmarks - The initial reference or references to some previous transactions. Value is optional and
     * absence indicates that the bookmarks do not exist or are unknown.
     * @param {string} param.database - The database this session will operate on.
     * @returns {RxSession} new reactive session.
     */

  }, {
    key: "rxSession",
    value: function rxSession() {
      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref3$defaultAccessMo = _ref3.defaultAccessMode,
          defaultAccessMode = _ref3$defaultAccessMo === void 0 ? WRITE : _ref3$defaultAccessMo,
          bookmarks = _ref3.bookmarks,
          _ref3$database = _ref3.database,
          database = _ref3$database === void 0 ? '' : _ref3$database,
          fetchSize = _ref3.fetchSize;

      return new _sessionRx["default"]({
        session: this._newSession({
          defaultAccessMode: defaultAccessMode,
          bookmarks: bookmarks,
          database: database,
          reactive: true,
          fetchSize: validateFetchSizeValue(fetchSize, this._config.fetchSize)
        }),
        config: this._config
      });
    }
    /**
     * Close all open sessions and other associated resources. You should
     * make sure to use this when you are done with this driver instance.
     * @public
     * @return {Promise<void>} promise resolved when the driver is closed.
     */

  }, {
    key: "close",
    value: function close() {
      this._log.info("Driver ".concat(this._id, " closing"));

      if (this._connectionProvider) {
        return this._connectionProvider.close();
      }

      return Promise.resolve();
    }
    /**
     * @protected
     */

  }, {
    key: "_afterConstruction",
    value: function _afterConstruction() {
      this._log.info("Direct driver ".concat(this._id, " created for server address ").concat(this._address));
    }
    /**
     * @protected
     */

  }, {
    key: "_createConnectionProvider",
    value: function _createConnectionProvider(address, userAgent, authToken) {
      return new _connectionProviderDirect["default"]({
        id: this._id,
        config: this._config,
        log: this._log,
        address: address,
        userAgent: userAgent,
        authToken: authToken
      });
    }
    /**
     * @protected
     */

  }, {
    key: "_newSession",

    /**
     * @private
     */
    value: function _newSession(_ref4) {
      var defaultAccessMode = _ref4.defaultAccessMode,
          bookmarkOrBookmarks = _ref4.bookmarkOrBookmarks,
          database = _ref4.database,
          reactive = _ref4.reactive,
          fetchSize = _ref4.fetchSize;

      var sessionMode = Driver._validateSessionMode(defaultAccessMode);

      var connectionProvider = this._getOrCreateConnectionProvider();

      var bookmark = bookmarkOrBookmarks ? new _bookmark["default"](bookmarkOrBookmarks) : _bookmark["default"].empty();
      return new _session["default"]({
        mode: sessionMode,
        database: database,
        connectionProvider: connectionProvider,
        bookmark: bookmark,
        config: this._config,
        reactive: reactive,
        fetchSize: fetchSize
      });
    }
    /**
     * @private
     */

  }, {
    key: "_getOrCreateConnectionProvider",
    value: function _getOrCreateConnectionProvider() {
      if (!this._connectionProvider) {
        this._connectionProvider = this._createConnectionProvider(this._address, this._userAgent, this._authToken);
      }

      return this._connectionProvider;
    }
  }], [{
    key: "_validateSessionMode",
    value: function _validateSessionMode(rawMode) {
      var mode = rawMode || WRITE;

      if (mode !== _constants.ACCESS_MODE_READ && mode !== _constants.ACCESS_MODE_WRITE) {
        throw (0, _error.newError)('Illegal session mode ' + mode);
      }

      return mode;
    }
  }]);
  return Driver;
}();
/**
 * @private
 */


exports.Driver = Driver;

function sanitizeConfig(config) {
  config.maxConnectionLifetime = sanitizeIntValue(config.maxConnectionLifetime, DEFAULT_MAX_CONNECTION_LIFETIME);
  config.maxConnectionPoolSize = sanitizeIntValue(config.maxConnectionPoolSize, _poolConfig.DEFAULT_MAX_SIZE);
  config.connectionAcquisitionTimeout = sanitizeIntValue(config.connectionAcquisitionTimeout, _poolConfig.DEFAULT_ACQUISITION_TIMEOUT);
  config.fetchSize = validateFetchSizeValue(config.fetchSize, DEFAULT_FETCH_SIZE);
}
/**
 * @private
 */


function sanitizeIntValue(rawValue, defaultWhenAbsent) {
  var sanitizedValue = parseInt(rawValue, 10);

  if (sanitizedValue > 0 || sanitizedValue === 0) {
    return sanitizedValue;
  } else if (sanitizedValue < 0) {
    return Number.MAX_SAFE_INTEGER;
  } else {
    return defaultWhenAbsent;
  }
}
/**
 * @private
 */


function validateFetchSizeValue(rawValue, defaultWhenAbsent) {
  var fetchSize = parseInt(rawValue, 10);

  if (fetchSize > 0 || fetchSize === _requestMessage.ALL) {
    return fetchSize;
  } else if (fetchSize === 0 || fetchSize < 0) {
    throw new Error('The fetch size can only be a positive value or -1 for ALL. However fetchSize = ' + fetchSize);
  } else {
    return defaultWhenAbsent;
  }
}

var _default = Driver;
exports["default"] = _default;

},{"./error":231,"./internal/bookmark":242,"./internal/connection-provider":261,"./internal/connection-provider-direct":257,"./internal/connectivity-verifier":263,"./internal/constants":264,"./internal/logger":267,"./internal/pool-config":270,"./internal/request-message":274,"./internal/util":288,"./session":295,"./session-rx":294,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":12}],231:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.newError = newError;
exports.PROTOCOL_ERROR = exports.SESSION_EXPIRED = exports.SERVICE_UNAVAILABLE = exports.Neo4jError = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _wrapNativeSuper2 = _interopRequireDefault(require("@babel/runtime/helpers/wrapNativeSuper"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// A common place for constructing error objects, to keep them
// uniform across the driver surface.

/**
 * Error code representing complete loss of service. Used by {@link Neo4jError#code}.
 * @type {string}
 */
var SERVICE_UNAVAILABLE = 'ServiceUnavailable';
/**
 * Error code representing transient loss of service. Used by {@link Neo4jError#code}.
 * @type {string}
 */

exports.SERVICE_UNAVAILABLE = SERVICE_UNAVAILABLE;
var SESSION_EXPIRED = 'SessionExpired';
/**
 * Error code representing serialization/deserialization issue in the Bolt protocol. Used by {@link Neo4jError#code}.
 * @type {string}
 */

exports.SESSION_EXPIRED = SESSION_EXPIRED;
var PROTOCOL_ERROR = 'ProtocolError';
/**
 * Create a new error from a message and error code
 * @param message the error message
 * @param code the error code
 * @return {Neo4jError} an {@link Neo4jError}
 * @private
 */

exports.PROTOCOL_ERROR = PROTOCOL_ERROR;

function newError(message) {
  var code = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'N/A';
  // TODO: Idea is that we can check the code here and throw sub-classes
  // of Neo4jError as appropriate
  return new Neo4jError(message, code);
}
/**
 * Class for all errors thrown/returned by the driver.
 */


var Neo4jError =
/*#__PURE__*/
function (_Error) {
  (0, _inherits2["default"])(Neo4jError, _Error);

  /**
   * @constructor
   * @param {string} message - The error message.
   * @param {string} code - Optional error code. Will be populated when error originates in the database.
   */
  function Neo4jError(message) {
    var _this;

    var code = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'N/A';
    (0, _classCallCheck2["default"])(this, Neo4jError);
    _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(Neo4jError).call(this, message));
    /**
     * The error message
     * @type {string}
     */

    _this.message = message;
    /**
     * Optional error code. Will be populated when error originates in the database.
     * @type {string}
     */

    _this.code = code;
    /**
     * The name of the error.
     * @type {string}
     */

    _this.name = 'Neo4jError';
    return _this;
  }

  return Neo4jError;
}((0, _wrapNativeSuper2["default"])(Error));

exports.Neo4jError = Neo4jError;

},{"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":19,"@babel/runtime/helpers/wrapNativeSuper":25}],232:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isNode = isNode;
exports.isRelationship = isRelationship;
exports.isUnboundRelationship = isUnboundRelationship;
exports.isPath = isPath;
exports.isPathSegment = isPathSegment;
exports.PathSegment = exports.Path = exports.UnboundRelationship = exports.Relationship = exports.Node = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var IDENTIFIER_PROPERTY_ATTRIBUTES = {
  value: true,
  enumerable: false,
  configurable: false,
  writable: false
};
var NODE_IDENTIFIER_PROPERTY = '__isNode__';
var RELATIONSHIP_IDENTIFIER_PROPERTY = '__isRelationship__';
var UNBOUND_RELATIONSHIP_IDENTIFIER_PROPERTY = '__isUnboundRelationship__';
var PATH_IDENTIFIER_PROPERTY = '__isPath__';
var PATH_SEGMENT_IDENTIFIER_PROPERTY = '__isPathSegment__';

function hasIdentifierProperty(obj, property) {
  return (obj && obj[property]) === true;
}
/**
 * Class for Node Type.
 */


var Node =
/*#__PURE__*/
function () {
  /**
   * @constructor
   * @protected
   * @param {Integer} identity - Unique identity
   * @param {Array<string>} labels - Array for all labels
   * @param {Object} properties - Map with node properties
   */
  function Node(identity, labels, properties) {
    (0, _classCallCheck2["default"])(this, Node);

    /**
     * Identity of the node.
     * @type {Integer}
     */
    this.identity = identity;
    /**
     * Labels of the node.
     * @type {string[]}
     */

    this.labels = labels;
    /**
     * Properties of the node.
     * @type {Object}
     */

    this.properties = properties;
  }
  /**
   * @ignore
   */


  (0, _createClass2["default"])(Node, [{
    key: "toString",
    value: function toString() {
      var s = '(' + this.identity;

      for (var i = 0; i < this.labels.length; i++) {
        s += ':' + this.labels[i];
      }

      var keys = Object.keys(this.properties);

      if (keys.length > 0) {
        s += ' {';

        for (var _i = 0; _i < keys.length; _i++) {
          if (_i > 0) s += ',';
          s += keys[_i] + ':' + JSON.stringify(this.properties[keys[_i]]);
        }

        s += '}';
      }

      s += ')';
      return s;
    }
  }]);
  return Node;
}();

exports.Node = Node;
Object.defineProperty(Node.prototype, NODE_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);
/**
 * Test if given object is an instance of {@link Node} class.
 * @param {Object} obj the object to test.
 * @return {boolean} `true` if given object is a {@link Node}, `false` otherwise.
 */

function isNode(obj) {
  return hasIdentifierProperty(obj, NODE_IDENTIFIER_PROPERTY);
}
/**
 * Class for Relationship Type.
 */


var Relationship =
/*#__PURE__*/
function () {
  /**
   * @constructor
   * @protected
   * @param {Integer} identity - Unique identity
   * @param {Integer} start - Identity of start Node
   * @param {Integer} end - Identity of end Node
   * @param {string} type - Relationship type
   * @param {Object} properties - Map with relationship properties
   */
  function Relationship(identity, start, end, type, properties) {
    (0, _classCallCheck2["default"])(this, Relationship);

    /**
     * Identity of the relationship.
     * @type {Integer}
     */
    this.identity = identity;
    /**
     * Identity of the start node.
     * @type {Integer}
     */

    this.start = start;
    /**
     * Identity of the end node.
     * @type {Integer}
     */

    this.end = end;
    /**
     * Type of the relationship.
     * @type {string}
     */

    this.type = type;
    /**
     * Properties of the relationship.
     * @type {Object}
     */

    this.properties = properties;
  }
  /**
   * @ignore
   */


  (0, _createClass2["default"])(Relationship, [{
    key: "toString",
    value: function toString() {
      var s = '(' + this.start + ')-[:' + this.type;
      var keys = Object.keys(this.properties);

      if (keys.length > 0) {
        s += ' {';

        for (var i = 0; i < keys.length; i++) {
          if (i > 0) s += ',';
          s += keys[i] + ':' + JSON.stringify(this.properties[keys[i]]);
        }

        s += '}';
      }

      s += ']->(' + this.end + ')';
      return s;
    }
  }]);
  return Relationship;
}();

exports.Relationship = Relationship;
Object.defineProperty(Relationship.prototype, RELATIONSHIP_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);
/**
 * Test if given object is an instance of {@link Relationship} class.
 * @param {Object} obj the object to test.
 * @return {boolean} `true` if given object is a {@link Relationship}, `false` otherwise.
 */

function isRelationship(obj) {
  return hasIdentifierProperty(obj, RELATIONSHIP_IDENTIFIER_PROPERTY);
}
/**
 * Class for UnboundRelationship Type.
 * @access private
 */


var UnboundRelationship =
/*#__PURE__*/
function () {
  /**
   * @constructor
   * @protected
   * @param {Integer} identity - Unique identity
   * @param {string} type - Relationship type
   * @param {Object} properties - Map with relationship properties
   */
  function UnboundRelationship(identity, type, properties) {
    (0, _classCallCheck2["default"])(this, UnboundRelationship);

    /**
     * Identity of the relationship.
     * @type {Integer}
     */
    this.identity = identity;
    /**
     * Type of the relationship.
     * @type {string}
     */

    this.type = type;
    /**
     * Properties of the relationship.
     * @type {Object}
     */

    this.properties = properties;
  }
  /**
   * Bind relationship
   *
   * @protected
   * @param {Integer} start - Identity of start node
   * @param {Integer} end - Identity of end node
   * @return {Relationship} - Created relationship
   */


  (0, _createClass2["default"])(UnboundRelationship, [{
    key: "bind",
    value: function bind(start, end) {
      return new Relationship(this.identity, start, end, this.type, this.properties);
    }
    /**
     * @ignore
     */

  }, {
    key: "toString",
    value: function toString() {
      var s = '-[:' + this.type;
      var keys = Object.keys(this.properties);

      if (keys.length > 0) {
        s += ' {';

        for (var i = 0; i < keys.length; i++) {
          if (i > 0) s += ',';
          s += keys[i] + ':' + JSON.stringify(this.properties[keys[i]]);
        }

        s += '}';
      }

      s += ']->';
      return s;
    }
  }]);
  return UnboundRelationship;
}();

exports.UnboundRelationship = UnboundRelationship;
Object.defineProperty(UnboundRelationship.prototype, UNBOUND_RELATIONSHIP_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);
/**
 * Test if given object is an instance of {@link UnboundRelationship} class.
 * @param {Object} obj the object to test.
 * @return {boolean} `true` if given object is a {@link UnboundRelationship}, `false` otherwise.
 */

function isUnboundRelationship(obj) {
  return hasIdentifierProperty(obj, UNBOUNT_RELATIONSHIP_IDENTIFIER_PROPERTY);
}
/**
 * Class for PathSegment Type.
 */


var PathSegment =
/**
 * @constructor
 * @protected
 * @param {Node} start - start node
 * @param {Relationship} rel - relationship that connects start and end node
 * @param {Node} end - end node
 */
function PathSegment(start, rel, end) {
  (0, _classCallCheck2["default"])(this, PathSegment);

  /**
   * Start node.
   * @type {Node}
   */
  this.start = start;
  /**
   * Relationship.
   * @type {Relationship}
   */

  this.relationship = rel;
  /**
   * End node.
   * @type {Node}
   */

  this.end = end;
};

exports.PathSegment = PathSegment;
Object.defineProperty(PathSegment.prototype, PATH_SEGMENT_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);
/**
 * Test if given object is an instance of {@link PathSegment} class.
 * @param {Object} obj the object to test.
 * @return {boolean} `true` if given object is a {@link PathSegment}, `false` otherwise.
 */

function isPathSegment(obj) {
  return hasIdentifierProperty(obj, PATH_SEGMENT_IDENTIFIER_PROPERTY);
}
/**
 * Class for Path Type.
 */


var Path =
/**
 * @constructor
 * @protected
 * @param {Node} start  - start node
 * @param {Node} end - end node
 * @param {Array<PathSegment>} segments - Array of Segments
 */
function Path(start, end, segments) {
  (0, _classCallCheck2["default"])(this, Path);

  /**
   * Start node.
   * @type {Node}
   */
  this.start = start;
  /**
   * End node.
   * @type {Node}
   */

  this.end = end;
  /**
   * Segments.
   * @type {Array<PathSegment>}
   */

  this.segments = segments;
  /**
   * Length of the segments.
   * @type {Number}
   */

  this.length = segments.length;
};

exports.Path = Path;
Object.defineProperty(Path.prototype, PATH_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);
/**
 * Test if given object is an instance of {@link Path} class.
 * @param {Object} obj the object to test.
 * @return {boolean} `true` if given object is a {@link Path}, `false` otherwise.
 */

function isPath(obj) {
  return hasIdentifierProperty(obj, PATH_IDENTIFIER_PROPERTY);
}

},{"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":12}],233:[function(require,module,exports){
(function (global){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.driver = driver;
Object.defineProperty(exports, "int", {
  enumerable: true,
  get: function get() {
    return _integer["int"];
  }
});
Object.defineProperty(exports, "isInt", {
  enumerable: true,
  get: function get() {
    return _integer.isInt;
  }
});
Object.defineProperty(exports, "Neo4jError", {
  enumerable: true,
  get: function get() {
    return _error.Neo4jError;
  }
});
Object.defineProperty(exports, "isPoint", {
  enumerable: true,
  get: function get() {
    return _spatialTypes.isPoint;
  }
});
Object.defineProperty(exports, "isDate", {
  enumerable: true,
  get: function get() {
    return _temporalTypes.isDate;
  }
});
Object.defineProperty(exports, "isDateTime", {
  enumerable: true,
  get: function get() {
    return _temporalTypes.isDateTime;
  }
});
Object.defineProperty(exports, "isDuration", {
  enumerable: true,
  get: function get() {
    return _temporalTypes.isDuration;
  }
});
Object.defineProperty(exports, "isLocalDateTime", {
  enumerable: true,
  get: function get() {
    return _temporalTypes.isLocalDateTime;
  }
});
Object.defineProperty(exports, "isLocalTime", {
  enumerable: true,
  get: function get() {
    return _temporalTypes.isLocalTime;
  }
});
Object.defineProperty(exports, "isTime", {
  enumerable: true,
  get: function get() {
    return _temporalTypes.isTime;
  }
});
exports["default"] = exports.temporal = exports.spatial = exports.error = exports.session = exports.types = exports.logging = exports.auth = exports.integer = void 0;

var _integer = _interopRequireWildcard(require("./integer"));

var _graphTypes = require("./graph-types");

var _error = require("./error");

var _result = _interopRequireDefault(require("./result"));

var _resultSummary = _interopRequireDefault(require("./result-summary"));

var _record = _interopRequireDefault(require("./record"));

var _driver = require("./driver");

var _routingDriver = _interopRequireDefault(require("./routing-driver"));

var _version = _interopRequireDefault(require("./version"));

var _util = require("./internal/util");

var _urlUtil = _interopRequireDefault(require("./internal/url-util"));

var _spatialTypes = require("./spatial-types");

var _temporalTypes = require("./temporal-types");

var _serverAddress = _interopRequireDefault(require("./internal/server-address"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Construct a new Neo4j Driver. This is your main entry point for this
 * library.
 *
 * ## Configuration
 *
 * This function optionally takes a configuration argument. Available configuration
 * options are as follows:
 *
 *     {
 *       // Encryption level: ENCRYPTION_ON or ENCRYPTION_OFF.
 *       encrypted: ENCRYPTION_ON|ENCRYPTION_OFF
 *
 *       // Trust strategy to use if encryption is enabled. There is no mode to disable
 *       // trust other than disabling encryption altogether. The reason for
 *       // this is that if you don't know who you are talking to, it is easy for an
 *       // attacker to hijack your encrypted connection, rendering encryption pointless.
 *       //
 *       // TRUST_SYSTEM_CA_SIGNED_CERTIFICATES is the default choice. For NodeJS environments, this
 *       // means that you trust whatever certificates are in the default trusted certificate
 *       // store of the underlying system. For Browser environments, the trusted certificate
 *       // store is usually managed by the browser. Refer to your system or browser documentation
 *       // if you want to explicitly add a certificate as trusted.
 *       //
 *       // TRUST_CUSTOM_CA_SIGNED_CERTIFICATES is another option for trust verification -
 *       // whenever we establish an encrypted connection, we ensure the host is using
 *       // an encryption certificate that is in, or is signed by, a certificate given
 *       // as trusted through configuration. This option is only available for NodeJS environments.
 *       //
 *       // TRUST_ALL_CERTIFICATES means that you trust everything without any verifications
 *       // steps carried out.  This option is only available for NodeJS environments and should not
 *       // be used on production systems.
 *       trust: "TRUST_SYSTEM_CA_SIGNED_CERTIFICATES" | "TRUST_CUSTOM_CA_SIGNED_CERTIFICATES" |
 *       "TRUST_ALL_CERTIFICATES",
 *
 *       // List of one or more paths to trusted encryption certificates. This only
 *       // works in the NodeJS bundle, and only matters if you use "TRUST_CUSTOM_CA_SIGNED_CERTIFICATES".
 *       // The certificate files should be in regular X.509 PEM format.
 *       // For instance, ['./trusted.pem']
 *       trustedCertificates: [],
 *
 *       // The maximum total number of connections allowed to be managed by the connection pool, per host.
 *       // This includes both in-use and idle connections. No maximum connection pool size is imposed
 *       // by default.
 *       maxConnectionPoolSize: 100,
 *
 *       // The maximum allowed lifetime for a pooled connection in milliseconds. Pooled connections older than this
 *       // threshold will be closed and removed from the pool. Such discarding happens during connection acquisition
 *       // so that new session is never backed by an old connection. Setting this option to a low value will cause
 *       // a high connection churn and might result in a performance hit. It is recommended to set maximum lifetime
 *       // to a slightly smaller value than the one configured in network equipment (load balancer, proxy, firewall,
 *       // etc. can also limit maximum connection lifetime). No maximum lifetime limit is imposed by default. Zero
 *       // and negative values result in lifetime not being checked.
 *       maxConnectionLifetime: 60 * 60 * 1000, // 1 hour
 *
 *       // The maximum amount of time to wait to acquire a connection from the pool (to either create a new
 *       // connection or borrow an existing one.
 *       connectionAcquisitionTimeout: 60000, // 1 minute
 *
 *       // Specify the maximum time in milliseconds transactions are allowed to retry via
 *       // `Session#readTransaction()` and `Session#writeTransaction()` functions.
 *       // These functions will retry the given unit of work on `ServiceUnavailable`, `SessionExpired` and transient
 *       // errors with exponential backoff using initial delay of 1 second.
 *       // Default value is 30000 which is 30 seconds.
 *       maxTransactionRetryTime: 30000, // 30 seconds
 *
 *       // Specify socket connection timeout in milliseconds. Numeric values are expected. Negative and zero values
 *       // result in no timeout being applied. Connection establishment will be then bound by the timeout configured
 *       // on the operating system level. Default value is 30000, which is 30 seconds.
 *       connectionTimeout: 30000, // 30 seconds
 *
 *       // Make this driver always return native JavaScript numbers for integer values, instead of the
 *       // dedicated {@link Integer} class. Values that do not fit in native number bit range will be represented as
 *       // `Number.NEGATIVE_INFINITY` or `Number.POSITIVE_INFINITY`.
 *       // **Warning:** ResultSummary It is not always safe to enable this setting when JavaScript applications are not the only ones
 *       // interacting with the database. Stored numbers might in such case be not representable by native
 *       // {@link Number} type and thus driver will return lossy values. This might also happen when data was
 *       // initially imported using neo4j import tool and contained numbers larger than
 *       // `Number.MAX_SAFE_INTEGER`. Driver will then return positive infinity, which is lossy.
 *       // Default value for this option is `false` because native JavaScript numbers might result
 *       // in loss of precision in the general case.
 *       disableLosslessIntegers: false,
 *
 *       // Specify the logging configuration for the driver. Object should have two properties `level` and `logger`.
 *       //
 *       // Property `level` represents the logging level which should be one of: 'error', 'warn', 'info' or 'debug'. This property is optional and
 *       // its default value is 'info'. Levels have priorities: 'error': 0, 'warn': 1, 'info': 2, 'debug': 3. Enabling a certain level also enables all
 *       // levels with lower priority. For example: 'error', 'warn' and 'info' will be logged when 'info' level is configured.
 *       //
 *       // Property `logger` represents the logging function which will be invoked for every log call with an acceptable level. The function should
 *       // take two string arguments `level` and `message`. The function should not execute any blocking or long-running operations
 *       // because it is often executed on a hot path.
 *       //
 *       // No logging is done by default. See `neo4j.logging` object that contains predefined logging implementations.
 *       logging: {
 *         level: 'info',
 *         logger: (level, message) => console.log(level + ' ' + message)
 *       },
 *
 *       // Specify a custom server address resolver function used by the routing driver to resolve the initial address used to create the driver.
 *       // Such resolution happens:
 *       //  * during the very first rediscovery when driver is created
 *       //  * when all the known routers from the current routing table have failed and driver needs to fallback to the initial address
 *       //
 *       // In NodeJS environment driver defaults to performing a DNS resolution of the initial address using 'dns' module.
 *       // In browser environment driver uses the initial address as-is.
 *       // Value should be a function that takes a single string argument - the initial address. It should return an array of new addresses.
 *       // Address is a string of shape '<host>:<port>'. Provided function can return either a Promise resolved with an array of addresses
 *       // or array of addresses directly.
 *       resolver: function(address) {
 *         return ['127.0.0.1:8888', 'fallback.db.com:7687'];
 *       },
 *
 *      // Optionally override the default user agent name.
 *       userAgent: USER_AGENT
 *     }
 *
 * @param {string} url The URL for the Neo4j database, for instance "neo4j://localhost" and/or "bolt://localhost"
 * @param {Map<string,string>} authToken Authentication credentials. See {@link auth} for helpers.
 * @param {Object} config Configuration object. See the configuration section above for details.
 * @returns {Driver}
 */
function driver(url, authToken) {
  var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  (0, _util.assertString)(url, 'Bolt URL');

  var parsedUrl = _urlUtil["default"].parseDatabaseUrl(url); // Determine entryption/trust options from the URL.


  var routing = false;
  var encrypted = false;
  var trust;

  switch (parsedUrl.scheme) {
    case 'bolt':
      break;

    case 'bolt+s':
      encrypted = true;
      trust = 'TRUST_SYSTEM_CA_SIGNED_CERTIFICATES';
      break;

    case 'bolt+ssc':
      encrypted = true;
      trust = 'TRUST_ALL_CERTIFICATES';
      break;

    case 'neo4j':
      routing = true;
      break;

    case 'neo4j+s':
      encrypted = true;
      trust = 'TRUST_SYSTEM_CA_SIGNED_CERTIFICATES';
      routing = true;
      break;

    case 'neo4j+ssc':
      encrypted = true;
      trust = 'TRUST_ALL_CERTIFICATES';
      routing = true;
      break;

    default:
      throw new Error("Unknown scheme: ".concat(parsedUrl.scheme));
  } // Encryption enabled on URL, propagate trust to the config.


  if (encrypted) {
    // Check for configuration conflict between URL and config.
    if ('encrypted' in config || 'trust' in config) {
      throw new Error('Encryption/trust can only be configured either through URL or config, not both');
    }

    config.encrypted = _util.ENCRYPTION_ON;
    config.trust = trust;
  } // Sanitize authority token. Nicer error from server when a scheme is set.


  authToken = authToken || {};
  authToken.scheme = authToken.scheme || 'none'; // Use default user agent or user agent specified by user.

  config.userAgent = config.userAgent || USER_AGENT;

  if (routing) {
    return new _routingDriver["default"](_serverAddress["default"].fromUrl(parsedUrl.hostAndPort), parsedUrl.query, config.userAgent, authToken, config);
  } else {
    if (!(0, _util.isEmptyObjectOrNull)(parsedUrl.query)) {
      throw new Error("Parameters are not supported with none routed scheme. Given URL: '".concat(url, "'"));
    }

    return new _driver.Driver(_serverAddress["default"].fromUrl(parsedUrl.hostAndPort), config.userAgent, authToken, config);
  }
}
/**
 * @property {function(username: string, password: string, realm: ?string)} basic the function to create a
 * basic authentication token.
 * @property {function(base64EncodedTicket: string)} kerberos the function to create a Kerberos authentication token.
 * Accepts a single string argument - base64 encoded Kerberos ticket.
 * @property {function(principal: string, credentials: string, realm: string, scheme: string, parameters: ?object)} custom
 * the function to create a custom authentication token.
 */


var auth = {
  basic: function basic(username, password) {
    var realm = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;

    if (realm) {
      return {
        scheme: 'basic',
        principal: username,
        credentials: password,
        realm: realm
      };
    } else {
      return {
        scheme: 'basic',
        principal: username,
        credentials: password
      };
    }
  },
  kerberos: function kerberos(base64EncodedTicket) {
    return {
      scheme: 'kerberos',
      principal: '',
      // This empty string is required for backwards compatibility.
      credentials: base64EncodedTicket
    };
  },
  custom: function custom(principal, credentials, realm, scheme) {
    var parameters = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : undefined;

    if (parameters) {
      return {
        scheme: scheme,
        principal: principal,
        credentials: credentials,
        realm: realm,
        parameters: parameters
      };
    } else {
      return {
        scheme: scheme,
        principal: principal,
        credentials: credentials,
        realm: realm
      };
    }
  }
};
exports.auth = auth;
var USER_AGENT = 'neo4j-javascript/' + _version["default"];
/**
 * Object containing predefined logging configurations. These are expected to be used as values of the driver config's `logging` property.
 * @property {function(level: ?string): object} console the function to create a logging config that prints all messages to `console.log` with
 * timestamp, level and message. It takes an optional `level` parameter which represents the maximum log level to be logged. Default value is 'info'.
 */

var logging = {
  console: function (_console) {
    function console(_x) {
      return _console.apply(this, arguments);
    }

    console.toString = function () {
      return _console.toString();
    };

    return console;
  }(function (level) {
    return {
      level: level,
      logger: function logger(level, message) {
        return console.log("".concat(global.Date.now(), " ").concat(level.toUpperCase(), " ").concat(message));
      }
    };
  })
  /**
   * Object containing constructors for all neo4j types.
   */

};
exports.logging = logging;
var types = {
  Node: _graphTypes.Node,
  Relationship: _graphTypes.Relationship,
  UnboundRelationship: _graphTypes.UnboundRelationship,
  PathSegment: _graphTypes.PathSegment,
  Path: _graphTypes.Path,
  Result: _result["default"],
  ResultSummary: _resultSummary["default"],
  Record: _record["default"],
  Point: _spatialTypes.Point,
  Date: _temporalTypes.Date,
  DateTime: _temporalTypes.DateTime,
  Duration: _temporalTypes.Duration,
  LocalDateTime: _temporalTypes.LocalDateTime,
  LocalTime: _temporalTypes.LocalTime,
  Time: _temporalTypes.Time,
  Integer: _integer["default"]
  /**
   * Object containing string constants representing session access modes.
   */

};
exports.types = types;
var session = {
  READ: _driver.READ,
  WRITE: _driver.WRITE
  /**
   * Object containing string constants representing predefined {@link Neo4jError} codes.
   */

};
exports.session = session;
var error = {
  SERVICE_UNAVAILABLE: _error.SERVICE_UNAVAILABLE,
  SESSION_EXPIRED: _error.SESSION_EXPIRED,
  PROTOCOL_ERROR: _error.PROTOCOL_ERROR
  /**
   * Object containing functions to work with {@link Integer} objects.
   */

};
exports.error = error;
var integer = {
  toNumber: _integer.toNumber,
  toString: _integer.toString,
  inSafeRange: _integer.inSafeRange
  /**
   * Object containing functions to work with spatial types, like {@link Point}.
   */

};
exports.integer = integer;
var spatial = {
  isPoint: _spatialTypes.isPoint
  /**
   * Object containing functions to work with temporal types, like {@link Time} or {@link Duration}.
   */

};
exports.spatial = spatial;
var temporal = {
  isDuration: _temporalTypes.isDuration,
  isLocalTime: _temporalTypes.isLocalTime,
  isTime: _temporalTypes.isTime,
  isDate: _temporalTypes.isDate,
  isLocalDateTime: _temporalTypes.isLocalDateTime,
  isDateTime: _temporalTypes.isDateTime
  /**
   * @private
   */

};
exports.temporal = temporal;
var forExport = {
  driver: driver,
  "int": _integer["int"],
  isInt: _integer.isInt,
  isPoint: _spatialTypes.isPoint,
  isDuration: _temporalTypes.isDuration,
  isLocalTime: _temporalTypes.isLocalTime,
  isTime: _temporalTypes.isTime,
  isDate: _temporalTypes.isDate,
  isLocalDateTime: _temporalTypes.isLocalDateTime,
  isDateTime: _temporalTypes.isDateTime,
  integer: integer,
  Neo4jError: _error.Neo4jError,
  auth: auth,
  logging: logging,
  types: types,
  session: session,
  error: error,
  spatial: spatial,
  temporal: temporal
};
var _default = forExport;
exports["default"] = _default;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./driver":230,"./error":231,"./graph-types":232,"./integer":234,"./internal/server-address":281,"./internal/url-util":287,"./internal/util":288,"./record":289,"./result":292,"./result-summary":291,"./routing-driver":293,"./spatial-types":296,"./temporal-types":297,"./version":300,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/interopRequireWildcard":13}],234:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.toString = exports.toNumber = exports.inSafeRange = exports.isInt = exports["int"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _error = require("./error");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// 64-bit Integer library, originally from Long.js by dcodeIO
// https://github.com/dcodeIO/Long.js
// License Apache 2

/**
 * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
 * See exported functions for more convenient ways of operating integers.
 * Use `int()` function to create new integers, `isInt()` to check if given object is integer,
 * `inSafeRange()` to check if it is safe to convert given value to native number,
 * `toNumber()` and `toString()` to convert given integer to number or string respectively.
 * @access public
 * @exports Integer
 * @class A Integer class for representing a 64 bit two's-complement integer value.
 * @param {number} low The low (signed) 32 bits of the long
 * @param {number} high The high (signed) 32 bits of the long
 * @constructor
 */
var Integer =
/*#__PURE__*/
function () {
  function Integer(low, high) {
    (0, _classCallCheck2["default"])(this, Integer);

    /**
     * The low 32 bits as a signed value.
     * @type {number}
     * @expose
     */
    this.low = low | 0;
    /**
     * The high 32 bits as a signed value.
     * @type {number}
     * @expose
     */

    this.high = high | 0;
  } // The internal representation of an Integer is the two given signed, 32-bit values.
  // We use 32-bit pieces because these are the size of integers on which
  // JavaScript performs bit-operations.  For operations like addition and
  // multiplication, we split each number into 16 bit pieces, which can easily be
  // multiplied within JavaScript's floating-point representation without overflow
  // or change in sign.
  //
  // In the algorithms below, we frequently reduce the negative case to the
  // positive case by negating the input(s) and then post-processing the result.
  // Note that we must ALWAYS check specially whether those values are MIN_VALUE
  // (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
  // a positive number, it overflows back into a negative).  Not handling this
  // case would often result in infinite recursion.
  //
  // Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
  // methods on which they depend.


  (0, _createClass2["default"])(Integer, [{
    key: "inSafeRange",
    value: function inSafeRange() {
      return this.greaterThanOrEqual(Integer.MIN_SAFE_VALUE) && this.lessThanOrEqual(Integer.MAX_SAFE_VALUE);
    }
    /**
     * Converts the Integer to an exact javascript Number, assuming it is a 32 bit integer.
     * @returns {number}
     * @expose
     */

  }, {
    key: "toInt",
    value: function toInt() {
      return this.low;
    }
    /**
     * Converts the Integer to a the nearest floating-point representation of this value (double, 53 bit mantissa).
     * @returns {number}
     * @expose
     */

  }, {
    key: "toNumber",
    value: function toNumber() {
      return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
    }
    /**
     * Converts the Integer to native number or -Infinity/+Infinity when it does not fit.
     * @return {number}
     * @package
     */

  }, {
    key: "toNumberOrInfinity",
    value: function toNumberOrInfinity() {
      if (this.lessThan(Integer.MIN_SAFE_VALUE)) {
        return Number.NEGATIVE_INFINITY;
      } else if (this.greaterThan(Integer.MAX_SAFE_VALUE)) {
        return Number.POSITIVE_INFINITY;
      } else {
        return this.toNumber();
      }
    }
    /**
     * Converts the Integer to a string written in the specified radix.
     * @param {number=} radix Radix (2-36), defaults to 10
     * @returns {string}
     * @override
     * @throws {RangeError} If `radix` is out of range
     * @expose
     */

  }, {
    key: "toString",
    value: function toString(radix) {
      radix = radix || 10;

      if (radix < 2 || radix > 36) {
        throw RangeError('radix out of range: ' + radix);
      }

      if (this.isZero()) {
        return '0';
      }

      var rem;

      if (this.isNegative()) {
        if (this.equals(Integer.MIN_VALUE)) {
          // We need to change the Integer value before it can be negated, so we remove
          // the bottom-most digit in this base and then recurse to do the rest.
          var radixInteger = Integer.fromNumber(radix);
          var div = this.div(radixInteger);
          rem = div.multiply(radixInteger).subtract(this);
          return div.toString(radix) + rem.toInt().toString(radix);
        } else {
          return '-' + this.negate().toString(radix);
        }
      } // Do several (6) digits each time through the loop, so as to
      // minimize the calls to the very expensive emulated div.


      var radixToPower = Integer.fromNumber(Math.pow(radix, 6));
      rem = this;
      var result = '';

      while (true) {
        var remDiv = rem.div(radixToPower);
        var intval = rem.subtract(remDiv.multiply(radixToPower)).toInt() >>> 0;
        var digits = intval.toString(radix);
        rem = remDiv;

        if (rem.isZero()) {
          return digits + result;
        } else {
          while (digits.length < 6) {
            digits = '0' + digits;
          }

          result = '' + digits + result;
        }
      }
    }
    /**
     * Gets the high 32 bits as a signed integer.
     * @returns {number} Signed high bits
     * @expose
     */

  }, {
    key: "getHighBits",
    value: function getHighBits() {
      return this.high;
    }
    /**
     * Gets the low 32 bits as a signed integer.
     * @returns {number} Signed low bits
     * @expose
     */

  }, {
    key: "getLowBits",
    value: function getLowBits() {
      return this.low;
    }
    /**
     * Gets the number of bits needed to represent the absolute value of this Integer.
     * @returns {number}
     * @expose
     */

  }, {
    key: "getNumBitsAbs",
    value: function getNumBitsAbs() {
      if (this.isNegative()) {
        return this.equals(Integer.MIN_VALUE) ? 64 : this.negate().getNumBitsAbs();
      }

      var val = this.high !== 0 ? this.high : this.low;

      for (var bit = 31; bit > 0; bit--) {
        if ((val & 1 << bit) !== 0) {
          break;
        }
      }

      return this.high !== 0 ? bit + 33 : bit + 1;
    }
    /**
     * Tests if this Integer's value equals zero.
     * @returns {boolean}
     * @expose
     */

  }, {
    key: "isZero",
    value: function isZero() {
      return this.high === 0 && this.low === 0;
    }
    /**
     * Tests if this Integer's value is negative.
     * @returns {boolean}
     * @expose
     */

  }, {
    key: "isNegative",
    value: function isNegative() {
      return this.high < 0;
    }
    /**
     * Tests if this Integer's value is positive.
     * @returns {boolean}
     * @expose
     */

  }, {
    key: "isPositive",
    value: function isPositive() {
      return this.high >= 0;
    }
    /**
     * Tests if this Integer's value is odd.
     * @returns {boolean}
     * @expose
     */

  }, {
    key: "isOdd",
    value: function isOdd() {
      return (this.low & 1) === 1;
    }
    /**
     * Tests if this Integer's value is even.
     * @returns {boolean}
     * @expose
     */

  }, {
    key: "isEven",
    value: function isEven() {
      return (this.low & 1) === 0;
    }
    /**
     * Tests if this Integer's value equals the specified's.
     * @param {!Integer|number|string} other Other value
     * @returns {boolean}
     * @expose
     */

  }, {
    key: "equals",
    value: function equals(other) {
      if (!Integer.isInteger(other)) {
        other = Integer.fromValue(other);
      }

      return this.high === other.high && this.low === other.low;
    }
    /**
     * Tests if this Integer's value differs from the specified's.
     * @param {!Integer|number|string} other Other value
     * @returns {boolean}
     * @expose
     */

  }, {
    key: "notEquals",
    value: function notEquals(other) {
      return !this.equals(
      /* validates */
      other);
    }
    /**
     * Tests if this Integer's value is less than the specified's.
     * @param {!Integer|number|string} other Other value
     * @returns {boolean}
     * @expose
     */

  }, {
    key: "lessThan",
    value: function lessThan(other) {
      return this.compare(
      /* validates */
      other) < 0;
    }
    /**
     * Tests if this Integer's value is less than or equal the specified's.
     * @param {!Integer|number|string} other Other value
     * @returns {boolean}
     * @expose
     */

  }, {
    key: "lessThanOrEqual",
    value: function lessThanOrEqual(other) {
      return this.compare(
      /* validates */
      other) <= 0;
    }
    /**
     * Tests if this Integer's value is greater than the specified's.
     * @param {!Integer|number|string} other Other value
     * @returns {boolean}
     * @expose
     */

  }, {
    key: "greaterThan",
    value: function greaterThan(other) {
      return this.compare(
      /* validates */
      other) > 0;
    }
    /**
     * Tests if this Integer's value is greater than or equal the specified's.
     * @param {!Integer|number|string} other Other value
     * @returns {boolean}
     * @expose
     */

  }, {
    key: "greaterThanOrEqual",
    value: function greaterThanOrEqual(other) {
      return this.compare(
      /* validates */
      other) >= 0;
    }
    /**
     * Compares this Integer's value with the specified's.
     * @param {!Integer|number|string} other Other value
     * @returns {number} 0 if they are the same, 1 if the this is greater and -1
     *  if the given one is greater
     * @expose
     */

  }, {
    key: "compare",
    value: function compare(other) {
      if (!Integer.isInteger(other)) {
        other = Integer.fromValue(other);
      }

      if (this.equals(other)) {
        return 0;
      }

      var thisNeg = this.isNegative();
      var otherNeg = other.isNegative();

      if (thisNeg && !otherNeg) {
        return -1;
      }

      if (!thisNeg && otherNeg) {
        return 1;
      } // At this point the sign bits are the same


      return this.subtract(other).isNegative() ? -1 : 1;
    }
    /**
     * Negates this Integer's value.
     * @returns {!Integer} Negated Integer
     * @expose
     */

  }, {
    key: "negate",
    value: function negate() {
      if (this.equals(Integer.MIN_VALUE)) {
        return Integer.MIN_VALUE;
      }

      return this.not().add(Integer.ONE);
    }
    /**
     * Returns the sum of this and the specified Integer.
     * @param {!Integer|number|string} addend Addend
     * @returns {!Integer} Sum
     * @expose
     */

  }, {
    key: "add",
    value: function add(addend) {
      if (!Integer.isInteger(addend)) {
        addend = Integer.fromValue(addend);
      } // Divide each number into 4 chunks of 16 bits, and then sum the chunks.


      var a48 = this.high >>> 16;
      var a32 = this.high & 0xffff;
      var a16 = this.low >>> 16;
      var a00 = this.low & 0xffff;
      var b48 = addend.high >>> 16;
      var b32 = addend.high & 0xffff;
      var b16 = addend.low >>> 16;
      var b00 = addend.low & 0xffff;
      var c48 = 0;
      var c32 = 0;
      var c16 = 0;
      var c00 = 0;
      c00 += a00 + b00;
      c16 += c00 >>> 16;
      c00 &= 0xffff;
      c16 += a16 + b16;
      c32 += c16 >>> 16;
      c16 &= 0xffff;
      c32 += a32 + b32;
      c48 += c32 >>> 16;
      c32 &= 0xffff;
      c48 += a48 + b48;
      c48 &= 0xffff;
      return Integer.fromBits(c16 << 16 | c00, c48 << 16 | c32);
    }
    /**
     * Returns the difference of this and the specified Integer.
     * @param {!Integer|number|string} subtrahend Subtrahend
     * @returns {!Integer} Difference
     * @expose
     */

  }, {
    key: "subtract",
    value: function subtract(subtrahend) {
      if (!Integer.isInteger(subtrahend)) {
        subtrahend = Integer.fromValue(subtrahend);
      }

      return this.add(subtrahend.negate());
    }
    /**
     * Returns the product of this and the specified Integer.
     * @param {!Integer|number|string} multiplier Multiplier
     * @returns {!Integer} Product
     * @expose
     */

  }, {
    key: "multiply",
    value: function multiply(multiplier) {
      if (this.isZero()) {
        return Integer.ZERO;
      }

      if (!Integer.isInteger(multiplier)) {
        multiplier = Integer.fromValue(multiplier);
      }

      if (multiplier.isZero()) {
        return Integer.ZERO;
      }

      if (this.equals(Integer.MIN_VALUE)) {
        return multiplier.isOdd() ? Integer.MIN_VALUE : Integer.ZERO;
      }

      if (multiplier.equals(Integer.MIN_VALUE)) {
        return this.isOdd() ? Integer.MIN_VALUE : Integer.ZERO;
      }

      if (this.isNegative()) {
        if (multiplier.isNegative()) {
          return this.negate().multiply(multiplier.negate());
        } else {
          return this.negate().multiply(multiplier).negate();
        }
      } else if (multiplier.isNegative()) {
        return this.multiply(multiplier.negate()).negate();
      } // If both longs are small, use float multiplication


      if (this.lessThan(TWO_PWR_24) && multiplier.lessThan(TWO_PWR_24)) {
        return Integer.fromNumber(this.toNumber() * multiplier.toNumber());
      } // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
      // We can skip products that would overflow.


      var a48 = this.high >>> 16;
      var a32 = this.high & 0xffff;
      var a16 = this.low >>> 16;
      var a00 = this.low & 0xffff;
      var b48 = multiplier.high >>> 16;
      var b32 = multiplier.high & 0xffff;
      var b16 = multiplier.low >>> 16;
      var b00 = multiplier.low & 0xffff;
      var c48 = 0;
      var c32 = 0;
      var c16 = 0;
      var c00 = 0;
      c00 += a00 * b00;
      c16 += c00 >>> 16;
      c00 &= 0xffff;
      c16 += a16 * b00;
      c32 += c16 >>> 16;
      c16 &= 0xffff;
      c16 += a00 * b16;
      c32 += c16 >>> 16;
      c16 &= 0xffff;
      c32 += a32 * b00;
      c48 += c32 >>> 16;
      c32 &= 0xffff;
      c32 += a16 * b16;
      c48 += c32 >>> 16;
      c32 &= 0xffff;
      c32 += a00 * b32;
      c48 += c32 >>> 16;
      c32 &= 0xffff;
      c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
      c48 &= 0xffff;
      return Integer.fromBits(c16 << 16 | c00, c48 << 16 | c32);
    }
    /**
     * Returns this Integer divided by the specified.
     * @param {!Integer|number|string} divisor Divisor
     * @returns {!Integer} Quotient
     * @expose
     */

  }, {
    key: "div",
    value: function div(divisor) {
      if (!Integer.isInteger(divisor)) {
        divisor = Integer.fromValue(divisor);
      }

      if (divisor.isZero()) {
        throw (0, _error.newError)('division by zero');
      }

      if (this.isZero()) {
        return Integer.ZERO;
      }

      var approx, rem, res;

      if (this.equals(Integer.MIN_VALUE)) {
        if (divisor.equals(Integer.ONE) || divisor.equals(Integer.NEG_ONE)) {
          return Integer.MIN_VALUE;
        }

        if (divisor.equals(Integer.MIN_VALUE)) {
          return Integer.ONE;
        } else {
          // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
          var halfThis = this.shiftRight(1);
          approx = halfThis.div(divisor).shiftLeft(1);

          if (approx.equals(Integer.ZERO)) {
            return divisor.isNegative() ? Integer.ONE : Integer.NEG_ONE;
          } else {
            rem = this.subtract(divisor.multiply(approx));
            res = approx.add(rem.div(divisor));
            return res;
          }
        }
      } else if (divisor.equals(Integer.MIN_VALUE)) {
        return Integer.ZERO;
      }

      if (this.isNegative()) {
        if (divisor.isNegative()) {
          return this.negate().div(divisor.negate());
        }

        return this.negate().div(divisor).negate();
      } else if (divisor.isNegative()) {
        return this.div(divisor.negate()).negate();
      } // Repeat the following until the remainder is less than other:  find a
      // floating-point that approximates remainder / other *from below*, add this
      // into the result, and subtract it from the remainder.  It is critical that
      // the approximate value is less than or equal to the real value so that the
      // remainder never becomes negative.


      res = Integer.ZERO;
      rem = this;

      while (rem.greaterThanOrEqual(divisor)) {
        // Approximate the result of division. This may be a little greater or
        // smaller than the actual value.
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber())); // We will tweak the approximate result by changing it in the 48-th digit or
        // the smallest non-fractional digit, whichever is larger.

        var log2 = Math.ceil(Math.log(approx) / Math.LN2);
        var delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48); // Decrease the approximation until it is smaller than the remainder.  Note
        // that if it is too large, the product overflows and is negative.

        var approxRes = Integer.fromNumber(approx);
        var approxRem = approxRes.multiply(divisor);

        while (approxRem.isNegative() || approxRem.greaterThan(rem)) {
          approx -= delta;
          approxRes = Integer.fromNumber(approx);
          approxRem = approxRes.multiply(divisor);
        } // We know the answer can't be zero... and actually, zero would cause
        // infinite recursion since we would make no progress.


        if (approxRes.isZero()) {
          approxRes = Integer.ONE;
        }

        res = res.add(approxRes);
        rem = rem.subtract(approxRem);
      }

      return res;
    }
    /**
     * Returns this Integer modulo the specified.
     * @param {!Integer|number|string} divisor Divisor
     * @returns {!Integer} Remainder
     * @expose
     */

  }, {
    key: "modulo",
    value: function modulo(divisor) {
      if (!Integer.isInteger(divisor)) {
        divisor = Integer.fromValue(divisor);
      }

      return this.subtract(this.div(divisor).multiply(divisor));
    }
    /**
     * Returns the bitwise NOT of this Integer.
     * @returns {!Integer}
     * @expose
     */

  }, {
    key: "not",
    value: function not() {
      return Integer.fromBits(~this.low, ~this.high);
    }
    /**
     * Returns the bitwise AND of this Integer and the specified.
     * @param {!Integer|number|string} other Other Integer
     * @returns {!Integer}
     * @expose
     */

  }, {
    key: "and",
    value: function and(other) {
      if (!Integer.isInteger(other)) {
        other = Integer.fromValue(other);
      }

      return Integer.fromBits(this.low & other.low, this.high & other.high);
    }
    /**
     * Returns the bitwise OR of this Integer and the specified.
     * @param {!Integer|number|string} other Other Integer
     * @returns {!Integer}
     * @expose
     */

  }, {
    key: "or",
    value: function or(other) {
      if (!Integer.isInteger(other)) {
        other = Integer.fromValue(other);
      }

      return Integer.fromBits(this.low | other.low, this.high | other.high);
    }
    /**
     * Returns the bitwise XOR of this Integer and the given one.
     * @param {!Integer|number|string} other Other Integer
     * @returns {!Integer}
     * @expose
     */

  }, {
    key: "xor",
    value: function xor(other) {
      if (!Integer.isInteger(other)) {
        other = Integer.fromValue(other);
      }

      return Integer.fromBits(this.low ^ other.low, this.high ^ other.high);
    }
    /**
     * Returns this Integer with bits shifted to the left by the given amount.
     * @param {number|!Integer} numBits Number of bits
     * @returns {!Integer} Shifted Integer
     * @expose
     */

  }, {
    key: "shiftLeft",
    value: function shiftLeft(numBits) {
      if (Integer.isInteger(numBits)) {
        numBits = numBits.toInt();
      }

      if ((numBits &= 63) === 0) {
        return this;
      } else if (numBits < 32) {
        return Integer.fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits);
      } else {
        return Integer.fromBits(0, this.low << numBits - 32);
      }
    }
    /**
     * Returns this Integer with bits arithmetically shifted to the right by the given amount.
     * @param {number|!Integer} numBits Number of bits
     * @returns {!Integer} Shifted Integer
     * @expose
     */

  }, {
    key: "shiftRight",
    value: function shiftRight(numBits) {
      if (Integer.isInteger(numBits)) {
        numBits = numBits.toInt();
      }

      if ((numBits &= 63) === 0) {
        return this;
      } else if (numBits < 32) {
        return Integer.fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits);
      } else {
        return Integer.fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1);
      }
    }
  }]);
  return Integer;
}();
/**
 * An indicator used to reliably determine if an object is a Integer or not.
 * @type {boolean}
 * @const
 * @expose
 * @private
 */


Integer.__isInteger__ = true;
Object.defineProperty(Integer.prototype, '__isInteger__', {
  value: true,
  enumerable: false,
  configurable: false
});
/**
 * Tests if the specified object is a Integer.
 * @access private
 * @param {*} obj Object
 * @returns {boolean}
 * @expose
 */

Integer.isInteger = function (obj) {
  return (obj && obj.__isInteger__) === true;
};
/**
 * A cache of the Integer representations of small integer values.
 * @type {!Object}
 * @inner
 * @private
 */


var INT_CACHE = {};
/**
 * Returns a Integer representing the given 32 bit integer value.
 * @access private
 * @param {number} value The 32 bit integer in question
 * @returns {!Integer} The corresponding Integer value
 * @expose
 */

Integer.fromInt = function (value) {
  var obj, cachedObj;
  value = value | 0;

  if (value >= -128 && value < 128) {
    cachedObj = INT_CACHE[value];

    if (cachedObj) {
      return cachedObj;
    }
  }

  obj = new Integer(value, value < 0 ? -1 : 0, false);

  if (value >= -128 && value < 128) {
    INT_CACHE[value] = obj;
  }

  return obj;
};
/**
 * Returns a Integer representing the given value, provided that it is a finite number. Otherwise, zero is returned.
 * @access private
 * @param {number} value The number in question
 * @returns {!Integer} The corresponding Integer value
 * @expose
 */


Integer.fromNumber = function (value) {
  if (isNaN(value) || !isFinite(value)) {
    return Integer.ZERO;
  }

  if (value <= -TWO_PWR_63_DBL) {
    return Integer.MIN_VALUE;
  }

  if (value + 1 >= TWO_PWR_63_DBL) {
    return Integer.MAX_VALUE;
  }

  if (value < 0) {
    return Integer.fromNumber(-value).negate();
  }

  return new Integer(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0);
};
/**
 * Returns a Integer representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
 *  assumed to use 32 bits.
 * @access private
 * @param {number} lowBits The low 32 bits
 * @param {number} highBits The high 32 bits
 * @returns {!Integer} The corresponding Integer value
 * @expose
 */


Integer.fromBits = function (lowBits, highBits) {
  return new Integer(lowBits, highBits);
};
/**
 * Returns a Integer representation of the given string, written using the specified radix.
 * @access private
 * @param {string} str The textual representation of the Integer
 * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
 * @returns {!Integer} The corresponding Integer value
 * @expose
 */


Integer.fromString = function (str, radix) {
  if (str.length === 0) {
    throw (0, _error.newError)('number format error: empty string');
  }

  if (str === 'NaN' || str === 'Infinity' || str === '+Infinity' || str === '-Infinity') {
    return Integer.ZERO;
  }

  radix = radix || 10;

  if (radix < 2 || radix > 36) {
    throw (0, _error.newError)('radix out of range: ' + radix);
  }

  var p;

  if ((p = str.indexOf('-')) > 0) {
    throw (0, _error.newError)('number format error: interior "-" character: ' + str);
  } else if (p === 0) {
    return Integer.fromString(str.substring(1), radix).negate();
  } // Do several (8) digits each time through the loop, so as to
  // minimize the calls to the very expensive emulated div.


  var radixToPower = Integer.fromNumber(Math.pow(radix, 8));
  var result = Integer.ZERO;

  for (var i = 0; i < str.length; i += 8) {
    var size = Math.min(8, str.length - i);
    var value = parseInt(str.substring(i, i + size), radix);

    if (size < 8) {
      var power = Integer.fromNumber(Math.pow(radix, size));
      result = result.multiply(power).add(Integer.fromNumber(value));
    } else {
      result = result.multiply(radixToPower);
      result = result.add(Integer.fromNumber(value));
    }
  }

  return result;
};
/**
 * Converts the specified value to a Integer.
 * @access private
 * @param {!Integer|number|string|!{low: number, high: number}} val Value
 * @returns {!Integer}
 * @expose
 */


Integer.fromValue = function (val) {
  if (val
  /* is compatible */
  instanceof Integer) {
    return val;
  }

  if (typeof val === 'number') {
    return Integer.fromNumber(val);
  }

  if (typeof val === 'string') {
    return Integer.fromString(val);
  } // Throws for non-objects, converts non-instanceof Integer:


  return new Integer(val.low, val.high);
};
/**
 * Converts the specified value to a number.
 * @access private
 * @param {!Integer|number|string|!{low: number, high: number}} val Value
 * @returns {number}
 * @expose
 */


Integer.toNumber = function (val) {
  return Integer.fromValue(val).toNumber();
};
/**
 * Converts the specified value to a string.
 * @access private
 * @param {!Integer|number|string|!{low: number, high: number}} val Value
 * @param {number} radix optional radix for string conversion, defaults to 10
 * @returns {string}
 * @expose
 */


Integer.toString = function (val, radix) {
  return Integer.fromValue(val).toString(radix);
};
/**
 * Checks if the given value is in the safe range in order to be converted to a native number
 * @access private
 * @param {!Integer|number|string|!{low: number, high: number}} val Value
 * @param {number} radix optional radix for string conversion, defaults to 10
 * @returns {boolean}
 * @expose
 */


Integer.inSafeRange = function (val) {
  return Integer.fromValue(val).inSafeRange();
};
/**
 * @type {number}
 * @const
 * @inner
 * @private
 */


var TWO_PWR_16_DBL = 1 << 16;
/**
 * @type {number}
 * @const
 * @inner
 * @private
 */

var TWO_PWR_24_DBL = 1 << 24;
/**
 * @type {number}
 * @const
 * @inner
 * @private
 */

var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
/**
 * @type {number}
 * @const
 * @inner
 * @private
 */

var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
/**
 * @type {number}
 * @const
 * @inner
 * @private
 */

var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
/**
 * @type {!Integer}
 * @const
 * @inner
 * @private
 */

var TWO_PWR_24 = Integer.fromInt(TWO_PWR_24_DBL);
/**
 * Signed zero.
 * @type {!Integer}
 * @expose
 */

Integer.ZERO = Integer.fromInt(0);
/**
 * Signed one.
 * @type {!Integer}
 * @expose
 */

Integer.ONE = Integer.fromInt(1);
/**
 * Signed negative one.
 * @type {!Integer}
 * @expose
 */

Integer.NEG_ONE = Integer.fromInt(-1);
/**
 * Maximum signed value.
 * @type {!Integer}
 * @expose
 */

Integer.MAX_VALUE = Integer.fromBits(0xffffffff | 0, 0x7fffffff | 0, false);
/**
 * Minimum signed value.
 * @type {!Integer}
 * @expose
 */

Integer.MIN_VALUE = Integer.fromBits(0, 0x80000000 | 0, false);
/**
 * Minimum safe value.
 * @type {!Integer}
 * @expose
 */

Integer.MIN_SAFE_VALUE = Integer.fromBits(0x1 | 0, 0xffffffffffe00000 | 0);
/**
 * Maximum safe value.
 * @type {!Integer}
 * @expose
 */

Integer.MAX_SAFE_VALUE = Integer.fromBits(0xffffffff | 0, 0x1fffff | 0);
/**
 * Cast value to Integer type.
 * @access public
 * @param {Mixed} value - The value to use.
 * @return {Integer} - An object of type Integer.
 */

var _int = Integer.fromValue;
/**
 * Check if a variable is of Integer type.
 * @access public
 * @param {Mixed} value - The variable to check.
 * @return {Boolean} - Is it of the Integer type?
 */

exports["int"] = _int;
var isInt = Integer.isInteger;
/**
 * Check if a variable can be safely converted to a number
 * @access public
 * @param {Mixed} value - The variable to check
 * @return {Boolean} - true if it is safe to call toNumber on variable otherwise false
 */

exports.isInt = isInt;
var inSafeRange = Integer.inSafeRange;
/**
 * Converts a variable to a number
 * @access public
 * @param {Mixed} value - The variable to convert
 * @return {number} - the variable as a number
 */

exports.inSafeRange = inSafeRange;
var toNumber = Integer.toNumber;
/**
 * Converts the integer to a string representation
 * @access public
 * @param {Mixed} value - The variable to convert
 * @param {number} radix - radix to use in string conversion, defaults to 10
 * @return {string} - returns a string representation of the integer
 */

exports.toNumber = toNumber;
var toString = Integer.toString;
exports.toString = toString;
var _default = Integer;
exports["default"] = _default;

},{"./error":231,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":12}],235:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.assertDatabaseIsEmpty = assertDatabaseIsEmpty;
exports.assertTxConfigIsEmpty = assertTxConfigIsEmpty;

var _error = require("../error");

var _streamObservers = require("./stream-observers");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @param {TxConfig} txConfig the auto-commit transaction configuration.
 * @param {Connection} connection the connection.
 * @param {ResultStreamObserver} observer the response observer.
 */
function assertTxConfigIsEmpty(txConfig, connection, observer) {
  if (txConfig && !txConfig.isEmpty()) {
    var error = (0, _error.newError)('Driver is connected to the database that does not support transaction configuration. ' + 'Please upgrade to neo4j 3.5.0 or later in order to use this functionality'); // unsupported API was used, consider this a fatal error for the current connection

    connection._handleFatalError(error);

    observer.onError(error);
    throw error;
  }
}
/**
 * Asserts that the passed-in database name is empty.
 * @param {string} database
 * @param {Connection} connection
 */


function assertDatabaseIsEmpty(database, connection, observer) {
  if (database) {
    var error = (0, _error.newError)('Driver is connected to the database that does not support multiple databases. ' + 'Please upgrade to neo4j 4.0.0 or later in order to use this functionality'); // unsupported API was used, consider this a fatal error for the current connection

    connection._handleFatalError(error);

    observer.onError(error);
    throw error;
  }
}

},{"../error":231,"./stream-observers":283}],236:[function(require,module,exports){
"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _boltProtocolUtil = require("./bolt-protocol-util");

var _bookmark = _interopRequireDefault(require("./bookmark"));

var _chunking = require("./chunking");

var _connection = _interopRequireDefault(require("./connection"));

var _constants = require("./constants");

var v1 = _interopRequireWildcard(require("./packstream-v1"));

var _requestMessage = _interopRequireDefault(require("./request-message"));

var _streamObservers = require("./stream-observers");

var _txConfig = _interopRequireDefault(require("./tx-config"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var BoltProtocol =
/*#__PURE__*/
function () {
  /**
   * @constructor
   * @param {Connection} connection the connection.
   * @param {Chunker} chunker the chunker.
   * @param {boolean} disableLosslessIntegers if this connection should convert all received integers to native JS numbers.
   */
  function BoltProtocol(connection, chunker, disableLosslessIntegers) {
    (0, _classCallCheck2["default"])(this, BoltProtocol);
    this._connection = connection;
    this._packer = this._createPacker(chunker);
    this._unpacker = this._createUnpacker(disableLosslessIntegers);
  }
  /**
   * Returns the numerical version identifier for this protocol
   */


  (0, _createClass2["default"])(BoltProtocol, [{
    key: "packer",

    /**
     * Get the packer.
     * @return {Packer} the protocol's packer.
     */
    value: function packer() {
      return this._packer;
    }
    /**
     * Get the unpacker.
     * @return {Unpacker} the protocol's unpacker.
     */

  }, {
    key: "unpacker",
    value: function unpacker() {
      return this._unpacker;
    }
    /**
     * Transform metadata received in SUCCESS message before it is passed to the handler.
     * @param {Object} metadata the received metadata.
     * @return {Object} transformed metadata.
     */

  }, {
    key: "transformMetadata",
    value: function transformMetadata(metadata) {
      return metadata;
    }
    /**
     * Perform initialization and authentication of the underlying connection.
     * @param {Object} param
     * @param {string} param.userAgent the user agent.
     * @param {Object} param.authToken the authentication token.
     * @param {function(err: Error)} param.onError the callback to invoke on error.
     * @param {function()} param.onComplete the callback to invoke on completion.
     * @returns {StreamObserver} the stream observer that monitors the corresponding server response.
     */

  }, {
    key: "initialize",
    value: function initialize() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          userAgent = _ref.userAgent,
          authToken = _ref.authToken,
          onError = _ref.onError,
          onComplete = _ref.onComplete;

      var observer = new _streamObservers.LoginObserver({
        connection: this._connection,
        afterError: onError,
        afterComplete: onComplete
      });

      this._connection.write(_requestMessage["default"].init(userAgent, authToken), observer, true);

      return observer;
    }
    /**
     * Perform protocol related operations for closing this connection
     */

  }, {
    key: "prepareToClose",
    value: function prepareToClose() {} // no need to notify the database in this protocol version

    /**
     * Begin an explicit transaction.
     * @param {Object} param
     * @param {Bookmark} param.bookmark the bookmark.
     * @param {TxConfig} param.txConfig the configuration.
     * @param {string} param.database the target database name.
     * @param {string} param.mode the access mode.
     * @param {function(err: Error)} param.beforeError the callback to invoke before handling the error.
     * @param {function(err: Error)} param.afterError the callback to invoke after handling the error.
     * @param {function()} param.beforeComplete the callback to invoke before handling the completion.
     * @param {function()} param.afterComplete the callback to invoke after handling the completion.
     * @returns {StreamObserver} the stream observer that monitors the corresponding server response.
     */

  }, {
    key: "beginTransaction",
    value: function beginTransaction() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          bookmark = _ref2.bookmark,
          txConfig = _ref2.txConfig,
          database = _ref2.database,
          mode = _ref2.mode,
          beforeError = _ref2.beforeError,
          afterError = _ref2.afterError,
          beforeComplete = _ref2.beforeComplete,
          afterComplete = _ref2.afterComplete;

      return this.run('BEGIN', bookmark ? bookmark.asBeginTransactionParameters() : {}, {
        bookmark: bookmark,
        txConfig: txConfig,
        database: database,
        mode: mode,
        beforeError: beforeError,
        afterError: afterError,
        beforeComplete: beforeComplete,
        afterComplete: afterComplete,
        flush: false
      });
    }
    /**
     * Commit the explicit transaction.
     * @param {Object} param
     * @param {function(err: Error)} param.beforeError the callback to invoke before handling the error.
     * @param {function(err: Error)} param.afterError the callback to invoke after handling the error.
     * @param {function()} param.beforeComplete the callback to invoke before handling the completion.
     * @param {function()} param.afterComplete the callback to invoke after handling the completion.
     * @returns {StreamObserver} the stream observer that monitors the corresponding server response.
     */

  }, {
    key: "commitTransaction",
    value: function commitTransaction() {
      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          beforeError = _ref3.beforeError,
          afterError = _ref3.afterError,
          beforeComplete = _ref3.beforeComplete,
          afterComplete = _ref3.afterComplete;

      // WRITE access mode is used as a place holder here, it has
      // no effect on behaviour for Bolt V1 & V2
      return this.run('COMMIT', {}, {
        bookmark: _bookmark["default"].empty(),
        txConfig: _txConfig["default"].empty(),
        mode: _constants.ACCESS_MODE_WRITE,
        beforeError: beforeError,
        afterError: afterError,
        beforeComplete: beforeComplete,
        afterComplete: afterComplete
      });
    }
    /**
     * Rollback the explicit transaction.
     * @param {Object} param
     * @param {function(err: Error)} param.beforeError the callback to invoke before handling the error.
     * @param {function(err: Error)} param.afterError the callback to invoke after handling the error.
     * @param {function()} param.beforeComplete the callback to invoke before handling the completion.
     * @param {function()} param.afterComplete the callback to invoke after handling the completion.
     * @returns {StreamObserver} the stream observer that monitors the corresponding server response.
     */

  }, {
    key: "rollbackTransaction",
    value: function rollbackTransaction() {
      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          beforeError = _ref4.beforeError,
          afterError = _ref4.afterError,
          beforeComplete = _ref4.beforeComplete,
          afterComplete = _ref4.afterComplete;

      // WRITE access mode is used as a place holder here, it has
      // no effect on behaviour for Bolt V1 & V2
      return this.run('ROLLBACK', {}, {
        bookmark: _bookmark["default"].empty(),
        txConfig: _txConfig["default"].empty(),
        mode: _constants.ACCESS_MODE_WRITE,
        beforeError: beforeError,
        afterError: afterError,
        beforeComplete: beforeComplete,
        afterComplete: afterComplete
      });
    }
    /**
     * Send a Cypher query through the underlying connection.
     * @param {string} query the cypher query.
     * @param {Object} parameters the query parameters.
     * @param {Object} param
     * @param {Bookmark} param.bookmark the bookmark.
     * @param {TxConfig} param.txConfig the transaction configuration.
     * @param {string} param.database the target database name.
     * @param {string} param.mode the access mode.
     * @param {function(keys: string[])} param.beforeKeys the callback to invoke before handling the keys.
     * @param {function(keys: string[])} param.afterKeys the callback to invoke after handling the keys.
     * @param {function(err: Error)} param.beforeError the callback to invoke before handling the error.
     * @param {function(err: Error)} param.afterError the callback to invoke after handling the error.
     * @param {function()} param.beforeComplete the callback to invoke before handling the completion.
     * @param {function()} param.afterComplete the callback to invoke after handling the completion.
     * @param {boolean} param.flush whether to flush the buffered messages.
     * @returns {StreamObserver} the stream observer that monitors the corresponding server response.
     */

  }, {
    key: "run",
    value: function run(query, parameters) {
      var _ref5 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
          bookmark = _ref5.bookmark,
          txConfig = _ref5.txConfig,
          database = _ref5.database,
          mode = _ref5.mode,
          beforeKeys = _ref5.beforeKeys,
          afterKeys = _ref5.afterKeys,
          beforeError = _ref5.beforeError,
          afterError = _ref5.afterError,
          beforeComplete = _ref5.beforeComplete,
          afterComplete = _ref5.afterComplete,
          _ref5$flush = _ref5.flush,
          flush = _ref5$flush === void 0 ? true : _ref5$flush;

      var observer = new _streamObservers.ResultStreamObserver({
        connection: this._connection,
        beforeKeys: beforeKeys,
        afterKeys: afterKeys,
        beforeError: beforeError,
        afterError: afterError,
        beforeComplete: beforeComplete,
        afterComplete: afterComplete
      }); // bookmark and mode are ignored in this version of the protocol

      (0, _boltProtocolUtil.assertTxConfigIsEmpty)(txConfig, this._connection, observer); // passing in a database name on this protocol version throws an error

      (0, _boltProtocolUtil.assertDatabaseIsEmpty)(database, this._connection, observer);

      this._connection.write(_requestMessage["default"].run(query, parameters), observer, false);

      this._connection.write(_requestMessage["default"].pullAll(), observer, flush);

      return observer;
    }
    /**
     * Send a RESET through the underlying connection.
     * @param {Object} param
     * @param {function(err: Error)} param.onError the callback to invoke on error.
     * @param {function()} param.onComplete the callback to invoke on completion.
     * @returns {StreamObserver} the stream observer that monitors the corresponding server response.
     */

  }, {
    key: "reset",
    value: function reset() {
      var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          onError = _ref6.onError,
          onComplete = _ref6.onComplete;

      var observer = new _streamObservers.ResetObserver({
        connection: this._connection,
        onError: onError,
        onComplete: onComplete
      });

      this._connection.write(_requestMessage["default"].reset(), observer, true);

      return observer;
    }
  }, {
    key: "_createPacker",
    value: function _createPacker(chunker) {
      return new v1.Packer(chunker);
    }
  }, {
    key: "_createUnpacker",
    value: function _createUnpacker(disableLosslessIntegers) {
      return new v1.Unpacker(disableLosslessIntegers);
    }
  }, {
    key: "version",
    get: function get() {
      return _constants.BOLT_PROTOCOL_V1;
    }
  }]);
  return BoltProtocol;
}();

exports["default"] = BoltProtocol;

},{"./bolt-protocol-util":235,"./bookmark":242,"./chunking":251,"./connection":262,"./constants":264,"./packstream-v1":268,"./request-message":274,"./stream-observers":283,"./tx-config":286,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/interopRequireWildcard":13}],237:[function(require,module,exports){
"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _boltProtocolV = _interopRequireDefault(require("./bolt-protocol-v1"));

var v2 = _interopRequireWildcard(require("./packstream-v2"));

var _constants = require("./constants");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var BoltProtocol =
/*#__PURE__*/
function (_BoltProtocolV) {
  (0, _inherits2["default"])(BoltProtocol, _BoltProtocolV);

  function BoltProtocol() {
    (0, _classCallCheck2["default"])(this, BoltProtocol);
    return (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(BoltProtocol).apply(this, arguments));
  }

  (0, _createClass2["default"])(BoltProtocol, [{
    key: "_createPacker",
    value: function _createPacker(chunker) {
      return new v2.Packer(chunker);
    }
  }, {
    key: "_createUnpacker",
    value: function _createUnpacker(disableLosslessIntegers) {
      return new v2.Unpacker(disableLosslessIntegers);
    }
  }, {
    key: "version",
    get: function get() {
      return _constants.BOLT_PROTOCOL_V2;
    }
  }]);
  return BoltProtocol;
}(_boltProtocolV["default"]);

exports["default"] = BoltProtocol;

},{"./bolt-protocol-v1":236,"./constants":264,"./packstream-v2":269,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/interopRequireWildcard":13,"@babel/runtime/helpers/possibleConstructorReturn":19}],238:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _boltProtocolV = _interopRequireDefault(require("./bolt-protocol-v2"));

var _requestMessage = _interopRequireDefault(require("./request-message"));

var _boltProtocolUtil = require("./bolt-protocol-util");

var _streamObservers = require("./stream-observers");

var _constants = require("./constants");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var noOpObserver = new _streamObservers.StreamObserver();

var BoltProtocol =
/*#__PURE__*/
function (_BoltProtocolV) {
  (0, _inherits2["default"])(BoltProtocol, _BoltProtocolV);

  function BoltProtocol() {
    (0, _classCallCheck2["default"])(this, BoltProtocol);
    return (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(BoltProtocol).apply(this, arguments));
  }

  (0, _createClass2["default"])(BoltProtocol, [{
    key: "transformMetadata",
    value: function transformMetadata(metadata) {
      if ('t_first' in metadata) {
        // Bolt V3 uses shorter key 't_first' to represent 'result_available_after'
        // adjust the key to be the same as in Bolt V1 so that ResultSummary can retrieve the value
        metadata.result_available_after = metadata.t_first;
        delete metadata.t_first;
      }

      if ('t_last' in metadata) {
        // Bolt V3 uses shorter key 't_last' to represent 'result_consumed_after'
        // adjust the key to be the same as in Bolt V1 so that ResultSummary can retrieve the value
        metadata.result_consumed_after = metadata.t_last;
        delete metadata.t_last;
      }

      return metadata;
    }
  }, {
    key: "initialize",
    value: function initialize() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          userAgent = _ref.userAgent,
          authToken = _ref.authToken,
          onError = _ref.onError,
          onComplete = _ref.onComplete;

      var observer = new _streamObservers.LoginObserver({
        connection: this._connection,
        afterError: onError,
        afterComplete: onComplete
      });

      this._connection.write(_requestMessage["default"].hello(userAgent, authToken), observer, true);

      return observer;
    }
  }, {
    key: "prepareToClose",
    value: function prepareToClose() {
      this._connection.write(_requestMessage["default"].goodbye(), noOpObserver, true);
    }
  }, {
    key: "beginTransaction",
    value: function beginTransaction() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          bookmark = _ref2.bookmark,
          txConfig = _ref2.txConfig,
          database = _ref2.database,
          mode = _ref2.mode,
          beforeError = _ref2.beforeError,
          afterError = _ref2.afterError,
          beforeComplete = _ref2.beforeComplete,
          afterComplete = _ref2.afterComplete;

      var observer = new _streamObservers.ResultStreamObserver({
        connection: this._connection,
        beforeError: beforeError,
        afterError: afterError,
        beforeComplete: beforeComplete,
        afterComplete: afterComplete
      });
      observer.prepareToHandleSingleResponse(); // passing in a database name on this protocol version throws an error

      (0, _boltProtocolUtil.assertDatabaseIsEmpty)(database, this._connection, observer);

      this._connection.write(_requestMessage["default"].begin({
        bookmark: bookmark,
        txConfig: txConfig,
        mode: mode
      }), observer, true);

      return observer;
    }
  }, {
    key: "commitTransaction",
    value: function commitTransaction() {
      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          beforeError = _ref3.beforeError,
          afterError = _ref3.afterError,
          beforeComplete = _ref3.beforeComplete,
          afterComplete = _ref3.afterComplete;

      var observer = new _streamObservers.ResultStreamObserver({
        connection: this._connection,
        beforeError: beforeError,
        afterError: afterError,
        beforeComplete: beforeComplete,
        afterComplete: afterComplete
      });
      observer.prepareToHandleSingleResponse();

      this._connection.write(_requestMessage["default"].commit(), observer, true);

      return observer;
    }
  }, {
    key: "rollbackTransaction",
    value: function rollbackTransaction() {
      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          beforeError = _ref4.beforeError,
          afterError = _ref4.afterError,
          beforeComplete = _ref4.beforeComplete,
          afterComplete = _ref4.afterComplete;

      var observer = new _streamObservers.ResultStreamObserver({
        connection: this._connection,
        beforeError: beforeError,
        afterError: afterError,
        beforeComplete: beforeComplete,
        afterComplete: afterComplete
      });
      observer.prepareToHandleSingleResponse();

      this._connection.write(_requestMessage["default"].rollback(), observer, true);

      return observer;
    }
  }, {
    key: "run",
    value: function run(query, parameters) {
      var _ref5 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
          bookmark = _ref5.bookmark,
          txConfig = _ref5.txConfig,
          database = _ref5.database,
          mode = _ref5.mode,
          beforeKeys = _ref5.beforeKeys,
          afterKeys = _ref5.afterKeys,
          beforeError = _ref5.beforeError,
          afterError = _ref5.afterError,
          beforeComplete = _ref5.beforeComplete,
          afterComplete = _ref5.afterComplete,
          _ref5$flush = _ref5.flush,
          flush = _ref5$flush === void 0 ? true : _ref5$flush;

      var observer = new _streamObservers.ResultStreamObserver({
        connection: this._connection,
        beforeKeys: beforeKeys,
        afterKeys: afterKeys,
        beforeError: beforeError,
        afterError: afterError,
        beforeComplete: beforeComplete,
        afterComplete: afterComplete
      }); // passing in a database name on this protocol version throws an error

      (0, _boltProtocolUtil.assertDatabaseIsEmpty)(database, this._connection, observer);

      this._connection.write(_requestMessage["default"].runWithMetadata(query, parameters, {
        bookmark: bookmark,
        txConfig: txConfig,
        mode: mode
      }), observer, false);

      this._connection.write(_requestMessage["default"].pullAll(), observer, flush);

      return observer;
    }
  }, {
    key: "version",
    get: function get() {
      return _constants.BOLT_PROTOCOL_V3;
    }
  }]);
  return BoltProtocol;
}(_boltProtocolV["default"]);

exports["default"] = BoltProtocol;

},{"./bolt-protocol-util":235,"./bolt-protocol-v2":237,"./constants":264,"./request-message":274,"./stream-observers":283,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":19}],239:[function(require,module,exports){
"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _boltProtocolV = _interopRequireDefault(require("./bolt-protocol-v3"));

var _requestMessage = _interopRequireWildcard(require("./request-message"));

var _streamObservers = require("./stream-observers");

var _constants = require("./constants");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var BoltProtocol =
/*#__PURE__*/
function (_BoltProtocolV) {
  (0, _inherits2["default"])(BoltProtocol, _BoltProtocolV);

  function BoltProtocol() {
    (0, _classCallCheck2["default"])(this, BoltProtocol);
    return (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(BoltProtocol).apply(this, arguments));
  }

  (0, _createClass2["default"])(BoltProtocol, [{
    key: "beginTransaction",
    value: function beginTransaction() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          bookmark = _ref.bookmark,
          txConfig = _ref.txConfig,
          database = _ref.database,
          mode = _ref.mode,
          beforeError = _ref.beforeError,
          afterError = _ref.afterError,
          beforeComplete = _ref.beforeComplete,
          afterComplete = _ref.afterComplete;

      var observer = new _streamObservers.ResultStreamObserver({
        connection: this._connection,
        beforeError: beforeError,
        afterError: afterError,
        beforeComplete: beforeComplete,
        afterComplete: afterComplete
      });
      observer.prepareToHandleSingleResponse();

      this._connection.write(_requestMessage["default"].begin({
        bookmark: bookmark,
        txConfig: txConfig,
        database: database,
        mode: mode
      }), observer, true);

      return observer;
    }
  }, {
    key: "run",
    value: function run(query, parameters) {
      var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
          bookmark = _ref2.bookmark,
          txConfig = _ref2.txConfig,
          database = _ref2.database,
          mode = _ref2.mode,
          beforeKeys = _ref2.beforeKeys,
          afterKeys = _ref2.afterKeys,
          beforeError = _ref2.beforeError,
          afterError = _ref2.afterError,
          beforeComplete = _ref2.beforeComplete,
          afterComplete = _ref2.afterComplete,
          _ref2$flush = _ref2.flush,
          flush = _ref2$flush === void 0 ? true : _ref2$flush,
          _ref2$reactive = _ref2.reactive,
          reactive = _ref2$reactive === void 0 ? false : _ref2$reactive,
          _ref2$fetchSize = _ref2.fetchSize,
          fetchSize = _ref2$fetchSize === void 0 ? _requestMessage.ALL : _ref2$fetchSize;

      var observer = new _streamObservers.ResultStreamObserver({
        connection: this._connection,
        reactive: reactive,
        fetchSize: fetchSize,
        moreFunction: this._requestMore,
        discardFunction: this._requestDiscard,
        beforeKeys: beforeKeys,
        afterKeys: afterKeys,
        beforeError: beforeError,
        afterError: afterError,
        beforeComplete: beforeComplete,
        afterComplete: afterComplete
      });
      var flushRun = reactive;

      this._connection.write(_requestMessage["default"].runWithMetadata(query, parameters, {
        bookmark: bookmark,
        txConfig: txConfig,
        database: database,
        mode: mode
      }), observer, flushRun && flush);

      if (!reactive) {
        this._connection.write(_requestMessage["default"].pull({
          n: fetchSize
        }), observer, flush);
      }

      return observer;
    }
  }, {
    key: "_requestMore",
    value: function _requestMore(connection, stmtId, n, observer) {
      connection.write(_requestMessage["default"].pull({
        stmtId: stmtId,
        n: n
      }), observer, true);
    }
  }, {
    key: "_requestDiscard",
    value: function _requestDiscard(connection, stmtId, observer) {
      connection.write(_requestMessage["default"].discard({
        stmtId: stmtId
      }), observer, true);
    }
  }, {
    key: "_noOp",
    value: function _noOp() {}
  }, {
    key: "version",
    get: function get() {
      return _constants.BOLT_PROTOCOL_V4_0;
    }
  }]);
  return BoltProtocol;
}(_boltProtocolV["default"]);

exports["default"] = BoltProtocol;

},{"./bolt-protocol-v3":238,"./constants":264,"./request-message":274,"./stream-observers":283,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/interopRequireWildcard":13,"@babel/runtime/helpers/possibleConstructorReturn":19}],240:[function(require,module,exports){
"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _boltProtocolV4x = _interopRequireDefault(require("./bolt-protocol-v4x0"));

var _requestMessage = _interopRequireWildcard(require("./request-message"));

var _constants = require("./constants");

var _streamObservers = require("./stream-observers");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var BoltProtocol =
/*#__PURE__*/
function (_BoltProtocolV) {
  (0, _inherits2["default"])(BoltProtocol, _BoltProtocolV);

  /**
   * @constructor
   * @param {Connection} connection the connection.
   * @param {Chunker} chunker the chunker.
   * @param {boolean} disableLosslessIntegers if this connection should convert all received integers to native JS numbers.
   * @param {Object} serversideRouting
   */
  function BoltProtocol(connection, chunker, disableLosslessIntegers, serversideRouting) {
    var _this;

    (0, _classCallCheck2["default"])(this, BoltProtocol);
    _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(BoltProtocol).call(this, connection, chunker, disableLosslessIntegers));
    _this._serversideRouting = serversideRouting;
    return _this;
  }

  (0, _createClass2["default"])(BoltProtocol, [{
    key: "initialize",
    value: function initialize() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          userAgent = _ref.userAgent,
          authToken = _ref.authToken,
          onError = _ref.onError,
          onComplete = _ref.onComplete;

      var observer = new _streamObservers.LoginObserver({
        connection: this._connection,
        afterError: onError,
        afterComplete: onComplete
      });

      this._connection.write(_requestMessage["default"].hello(userAgent, authToken, this._serversideRouting), observer, true);

      return observer;
    }
  }, {
    key: "version",
    get: function get() {
      return _constants.BOLT_PROTOCOL_V4_1;
    }
  }]);
  return BoltProtocol;
}(_boltProtocolV4x["default"]);

exports["default"] = BoltProtocol;

},{"./bolt-protocol-v4x0":239,"./constants":264,"./request-message":274,"./stream-observers":283,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/interopRequireWildcard":13,"@babel/runtime/helpers/possibleConstructorReturn":19}],241:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _boltProtocolV4x = _interopRequireDefault(require("./bolt-protocol-v4x1"));

var _constants = require("./constants");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var BoltProtocol =
/*#__PURE__*/
function (_BoltProtocolV) {
  (0, _inherits2["default"])(BoltProtocol, _BoltProtocolV);

  /**
   * @constructor
   * @param {Connection} connection the connection.
   * @param {Chunker} chunker the chunker.
   * @param {boolean} disableLosslessIntegers if this connection should convert all received integers to native JS numbers.
   * @param {Object} serversideRouting
   */
  function BoltProtocol(connection, chunker, disableLosslessIntegers, serversideRouting) {
    (0, _classCallCheck2["default"])(this, BoltProtocol);
    return (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(BoltProtocol).call(this, connection, chunker, disableLosslessIntegers, serversideRouting));
  }

  (0, _createClass2["default"])(BoltProtocol, [{
    key: "version",
    get: function get() {
      return _constants.BOLT_PROTOCOL_V4_2;
    }
  }]);
  return BoltProtocol;
}(_boltProtocolV4x["default"]);

exports["default"] = BoltProtocol;

},{"./bolt-protocol-v4x1":240,"./constants":264,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":19}],242:[function(require,module,exports){
"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var util = _interopRequireWildcard(require("./util"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var BOOKMARKS_KEY = 'bookmarks';

var Bookmark =
/*#__PURE__*/
function () {
  /**
   * @constructor
   * @param {string|string[]} values single bookmark as string or multiple bookmarks as a string array.
   */
  function Bookmark(values) {
    (0, _classCallCheck2["default"])(this, Bookmark);
    this._values = asStringArray(values);
  }

  (0, _createClass2["default"])(Bookmark, [{
    key: "isEmpty",

    /**
     * Check if the given bookmark is meaningful and can be send to the database.
     * @return {boolean} returns `true` bookmark has a value, `false` otherwise.
     */
    value: function isEmpty() {
      return this._values.length === 0;
    }
    /**
     * Get all bookmark values as an array.
     * @return {string[]} all values.
     */

  }, {
    key: "values",
    value: function values() {
      return this._values;
    }
    /**
     * Get this bookmark as an object for begin transaction call.
     * @return {Object} the value of this bookmark as object.
     */

  }, {
    key: "asBeginTransactionParameters",
    value: function asBeginTransactionParameters() {
      if (this.isEmpty()) {
        return {};
      } // Driver sends {bookmark: "max", bookmarks: ["one", "two", "max"]} instead of simple
      // {bookmarks: ["one", "two", "max"]} for backwards compatibility reasons. Old servers can only accept single
      // bookmark that is why driver has to parse and compare given list of bookmarks. This functionality will
      // eventually be removed.


      return (0, _defineProperty2["default"])({}, BOOKMARKS_KEY, this._values);
    }
  }], [{
    key: "empty",
    value: function empty() {
      return EMPTY_BOOKMARK;
    }
  }]);
  return Bookmark;
}();

exports["default"] = Bookmark;
var EMPTY_BOOKMARK = new Bookmark(null);
/**
 * Converts given value to an array.
 * @param {string|string[]|Array} [value=undefined] argument to convert.
 * @return {string[]} value converted to an array.
 */

function asStringArray(value) {
  if (!value) {
    return [];
  }

  if (util.isString(value)) {
    return [value];
  }

  if (Array.isArray(value)) {
    var result = [];
    var flattenedValue = flattenArray(value);

    for (var i = 0; i < flattenedValue.length; i++) {
      var element = flattenedValue[i]; // if it is undefined or null, ignore it

      if (element !== undefined && element !== null) {
        if (!util.isString(element)) {
          throw new TypeError("Bookmark value should be a string, given: '".concat(element, "'"));
        }

        result.push(element);
      }
    }

    return result;
  }

  throw new TypeError("Bookmark should either be a string or a string array, given: '".concat(value, "'"));
}
/**
 * Recursively flattens an array so that the result becomes a single array
 * of values, which does not include any sub-arrays
 *
 * @param {Array} value
 */


function flattenArray(values) {
  return values.reduce(function (dest, value) {
    return Array.isArray(value) ? dest.concat(flattenArray(value)) : dest.concat(value);
  }, []);
}

},{"./util":288,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/defineProperty":8,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/interopRequireWildcard":13}],243:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _baseBuf = _interopRequireDefault(require("../buf/base-buf"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var HeapBuffer =
/*#__PURE__*/
function (_BaseBuffer) {
  (0, _inherits2["default"])(HeapBuffer, _BaseBuffer);

  function HeapBuffer(arg) {
    var _this;

    (0, _classCallCheck2["default"])(this, HeapBuffer);
    var buffer = arg instanceof ArrayBuffer ? arg : new ArrayBuffer(arg);
    _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(HeapBuffer).call(this, buffer.byteLength));
    _this._buffer = buffer;
    _this._view = new DataView(_this._buffer);
    return _this;
  }

  (0, _createClass2["default"])(HeapBuffer, [{
    key: "putUInt8",
    value: function putUInt8(position, val) {
      this._view.setUint8(position, val);
    }
  }, {
    key: "getUInt8",
    value: function getUInt8(position) {
      return this._view.getUint8(position);
    }
  }, {
    key: "putInt8",
    value: function putInt8(position, val) {
      this._view.setInt8(position, val);
    }
  }, {
    key: "getInt8",
    value: function getInt8(position) {
      return this._view.getInt8(position);
    }
  }, {
    key: "getFloat64",
    value: function getFloat64(position) {
      return this._view.getFloat64(position);
    }
  }, {
    key: "putFloat64",
    value: function putFloat64(position, val) {
      this._view.setFloat64(position, val);
    }
  }, {
    key: "getSlice",
    value: function getSlice(start, length) {
      if (this._buffer.slice) {
        return new HeapBuffer(this._buffer.slice(start, start + length));
      } else {
        // Some platforms (eg. phantomjs) don't support slice, so fall back to a copy
        // We do this rather than return a SliceBuffer, because sliceBuffer cannot
        // be passed to native network write ops etc - we need ArrayBuffer for that
        var copy = new HeapBuffer(length);

        for (var i = 0; i < length; i++) {
          copy.putUInt8(i, this.getUInt8(i + start));
        }

        return copy;
      }
    }
    /**
     * Specific to HeapBuffer, this gets a DataView from the
     * current position and of the specified length.
     */

  }, {
    key: "readView",
    value: function readView(length) {
      return new DataView(this._buffer, this._updatePos(length), length);
    }
  }]);
  return HeapBuffer;
}(_baseBuf["default"]);

exports["default"] = HeapBuffer;

},{"../buf/base-buf":248,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":19}],244:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _browserBuf = _interopRequireDefault(require("./browser-buf"));

var _error = require("../../error");

var _util = require("../util");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Just to be sure that these values are with us even after WebSocket is injected
// for tests.
var WS_CONNECTING = 0;
var WS_OPEN = 1;
var WS_CLOSING = 2;
var WS_CLOSED = 3;
/**
 * Create a new WebSocketChannel to be used in web browsers.
 * @access private
 */

var WebSocketChannel =
/*#__PURE__*/
function () {
  /**
   * Create new instance
   * @param {ChannelConfig} config - configuration for this channel.
   * @param {function(): string} protocolSupplier - function that detects protocol of the web page. Should only be used in tests.
   */
  function WebSocketChannel(config) {
    var protocolSupplier = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : detectWebPageProtocol;
    var socketFactory = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (url) {
      return new WebSocket(url);
    };
    (0, _classCallCheck2["default"])(this, WebSocketChannel);
    this._open = true;
    this._pending = [];
    this._error = null;
    this._handleConnectionError = this._handleConnectionError.bind(this);
    this._config = config;

    var _determineWebSocketSc = determineWebSocketScheme(config, protocolSupplier),
        scheme = _determineWebSocketSc.scheme,
        error = _determineWebSocketSc.error;

    if (error) {
      this._error = error;
      return;
    }

    this._ws = createWebSocket(scheme, config.address, socketFactory);
    this._ws.binaryType = 'arraybuffer';
    var self = this; // All connection errors are not sent to the error handler
    // we must also check for dirty close calls

    this._ws.onclose = function (e) {
      if (e && !e.wasClean) {
        self._handleConnectionError();
      }
    };

    this._ws.onopen = function () {
      // Connected! Cancel the connection timeout
      self._clearConnectionTimeout(); // Drain all pending messages


      var pending = self._pending;
      self._pending = null;

      for (var i = 0; i < pending.length; i++) {
        self.write(pending[i]);
      }
    };

    this._ws.onmessage = function (event) {
      if (self.onmessage) {
        var b = new _browserBuf["default"](event.data);
        self.onmessage(b);
      }
    };

    this._ws.onerror = this._handleConnectionError;
    this._connectionTimeoutFired = false;
    this._connectionTimeoutId = this._setupConnectionTimeout();
  }

  (0, _createClass2["default"])(WebSocketChannel, [{
    key: "_handleConnectionError",
    value: function _handleConnectionError() {
      if (this._connectionTimeoutFired) {
        // timeout fired - not connected within configured time
        this._error = (0, _error.newError)("Failed to establish connection in ".concat(this._config.connectionTimeout, "ms"), this._config.connectionErrorCode);

        if (this.onerror) {
          this.onerror(this._error);
        }

        return;
      } // onerror triggers on websocket close as well.. don't get me started.


      if (this._open) {
        // http://stackoverflow.com/questions/25779831/how-to-catch-websocket-connection-to-ws-xxxnn-failed-connection-closed-be
        this._error = (0, _error.newError)('WebSocket connection failure. Due to security ' + 'constraints in your web browser, the reason for the failure is not available ' + 'to this Neo4j Driver. Please use your browsers development console to determine ' + 'the root cause of the failure. Common reasons include the database being ' + 'unavailable, using the wrong connection URL or temporary network problems. ' + 'If you have enabled encryption, ensure your browser is configured to trust the ' + 'certificate Neo4j is configured to use. WebSocket `readyState` is: ' + this._ws.readyState, this._config.connectionErrorCode);

        if (this.onerror) {
          this.onerror(this._error);
        }
      }
    }
    /**
     * Write the passed in buffer to connection
     * @param {HeapBuffer} buffer - Buffer to write
     */

  }, {
    key: "write",
    value: function write(buffer) {
      // If there is a pending queue, push this on that queue. This means
      // we are not yet connected, so we queue things locally.
      if (this._pending !== null) {
        this._pending.push(buffer);
      } else if (buffer instanceof _browserBuf["default"]) {
        try {
          this._ws.send(buffer._buffer);
        } catch (error) {
          if (this._ws.readyState !== WS_OPEN) {
            // Websocket has been closed
            this._handleConnectionError();
          } else {
            // Some other error occured
            throw error;
          }
        }
      } else {
        throw (0, _error.newError)("Don't know how to send buffer: " + buffer);
      }
    }
    /**
     * Close the connection
     * @returns {Promise} A promise that will be resolved after channel is closed
     */

  }, {
    key: "close",
    value: function close() {
      var _this = this;

      return new Promise(function (resolve, reject) {
        if (_this._ws && _this._ws.readyState !== WS_CLOSED) {
          _this._open = false;

          _this._clearConnectionTimeout();

          _this._ws.onclose = function () {
            return resolve();
          };

          _this._ws.close();
        } else {
          resolve();
        }
      });
    }
    /**
     * Set connection timeout on the given WebSocket, if configured.
     * @return {number} the timeout id or null.
     * @private
     */

  }, {
    key: "_setupConnectionTimeout",
    value: function _setupConnectionTimeout() {
      var _this2 = this;

      var timeout = this._config.connectionTimeout;

      if (timeout) {
        var webSocket = this._ws;
        return setTimeout(function () {
          if (webSocket.readyState !== WS_OPEN) {
            _this2._connectionTimeoutFired = true;
            webSocket.close();
          }
        }, timeout);
      }

      return null;
    }
    /**
     * Remove active connection timeout, if any.
     * @private
     */

  }, {
    key: "_clearConnectionTimeout",
    value: function _clearConnectionTimeout() {
      var timeoutId = this._connectionTimeoutId;

      if (timeoutId || timeoutId === 0) {
        this._connectionTimeoutFired = false;
        this._connectionTimeoutId = null;
        clearTimeout(timeoutId);
      }
    }
  }]);
  return WebSocketChannel;
}();

exports["default"] = WebSocketChannel;

function createWebSocket(scheme, address, socketFactory) {
  var url = scheme + '://' + address.asHostPort();

  try {
    return socketFactory(url);
  } catch (error) {
    if (isIPv6AddressIssueOnWindows(error, address)) {
      // WebSocket in IE and Edge browsers on Windows do not support regular IPv6 address syntax because they contain ':'.
      // It's an invalid character for UNC (https://en.wikipedia.org/wiki/IPv6_address#Literal_IPv6_addresses_in_UNC_path_names)
      // and Windows requires IPv6 to be changes in the following way:
      //   1) replace all ':' with '-'
      //   2) replace '%' with 's' for link-local address
      //   3) append '.ipv6-literal.net' suffix
      // only then resulting string can be considered a valid IPv6 address. Yes, this is extremely weird!
      // For more details see:
      //   https://social.msdn.microsoft.com/Forums/ie/en-US/06cca73b-63c2-4bf9-899b-b229c50449ff/whether-ie10-websocket-support-ipv6?forum=iewebdevelopment
      //   https://www.itdojo.com/ipv6-addresses-and-unc-path-names-overcoming-illegal/
      // Creation of WebSocket with unconverted address results in SyntaxError without message or stacktrace.
      // That is why here we "catch" SyntaxError and rewrite IPv6 address if needed.
      var windowsFriendlyUrl = asWindowsFriendlyIPv6Address(scheme, address);
      return socketFactory(windowsFriendlyUrl);
    } else {
      throw error;
    }
  }
}

function isIPv6AddressIssueOnWindows(error, address) {
  return error.name === 'SyntaxError' && isIPv6Address(address.asHostPort());
}

function isIPv6Address(hostAndPort) {
  return hostAndPort.charAt(0) === '[' && hostAndPort.indexOf(']') !== -1;
}

function asWindowsFriendlyIPv6Address(scheme, address) {
  // replace all ':' with '-'
  var hostWithoutColons = address.host().replace(new RegExp(':', 'g'), '-'); // replace '%' with 's' for link-local IPv6 address like 'fe80::1%lo0'

  var hostWithoutPercent = hostWithoutColons.replace('%', 's'); // append magic '.ipv6-literal.net' suffix

  var ipv6Host = hostWithoutPercent + '.ipv6-literal.net';
  return "".concat(scheme, "://").concat(ipv6Host, ":").concat(address.port());
}
/**
 * @param {ChannelConfig} config - configuration for the channel.
 * @param {function(): string} protocolSupplier - function that detects protocol of the web page.
 * @return {{scheme: string|null, error: Neo4jError|null}} object containing either scheme or error.
 */


function determineWebSocketScheme(config, protocolSupplier) {
  var encryptionOn = isEncryptionExplicitlyTurnedOn(config);
  var encryptionOff = isEncryptionExplicitlyTurnedOff(config);
  var trust = config.trust;
  var secureProtocol = isProtocolSecure(protocolSupplier);
  verifyEncryptionSettings(encryptionOn, encryptionOff, secureProtocol);

  if (encryptionOff) {
    // encryption explicitly turned off in the config
    return {
      scheme: 'ws',
      error: null
    };
  }

  if (secureProtocol) {
    // driver is used in a secure https web page, use 'wss'
    return {
      scheme: 'wss',
      error: null
    };
  }

  if (encryptionOn) {
    // encryption explicitly requested in the config
    if (!trust || trust === 'TRUST_SYSTEM_CA_SIGNED_CERTIFICATES') {
      // trust strategy not specified or the only supported strategy is specified
      return {
        scheme: 'wss',
        error: null
      };
    } else {
      var error = (0, _error.newError)('The browser version of this driver only supports one trust ' + "strategy, 'TRUST_SYSTEM_CA_SIGNED_CERTIFICATES'. " + trust + ' is not supported. Please ' + 'either use TRUST_SYSTEM_CA_SIGNED_CERTIFICATES or disable encryption by setting ' + '`encrypted:"' + _util.ENCRYPTION_OFF + '"` in the driver configuration.');
      return {
        scheme: null,
        error: error
      };
    }
  } // default to unencrypted web socket


  return {
    scheme: 'ws',
    error: null
  };
}
/**
 * @param {ChannelConfig} config - configuration for the channel.
 * @return {boolean} `true` if encryption enabled in the config, `false` otherwise.
 */


function isEncryptionExplicitlyTurnedOn(config) {
  return config.encrypted === true || config.encrypted === _util.ENCRYPTION_ON;
}
/**
 * @param {ChannelConfig} config - configuration for the channel.
 * @return {boolean} `true` if encryption disabled in the config, `false` otherwise.
 */


function isEncryptionExplicitlyTurnedOff(config) {
  return config.encrypted === false || config.encrypted === _util.ENCRYPTION_OFF;
}
/**
 * @param {function(): string} protocolSupplier - function that detects protocol of the web page.
 * @return {boolean} `true` if protocol returned by the given function is secure, `false` otherwise.
 */


function isProtocolSecure(protocolSupplier) {
  var protocol = typeof protocolSupplier === 'function' ? protocolSupplier() : '';
  return protocol && protocol.toLowerCase().indexOf('https') >= 0;
}

function verifyEncryptionSettings(encryptionOn, encryptionOff, secureProtocol) {
  if (secureProtocol === null) {// do nothing sice the protocol could not be identified
  } else if (encryptionOn && !secureProtocol) {
    // encryption explicitly turned on for a driver used on a HTTP web page
    console.warn('Neo4j driver is configured to use secure WebSocket on a HTTP web page. ' + 'WebSockets might not work in a mixed content environment. ' + 'Please consider configuring driver to not use encryption.');
  } else if (encryptionOff && secureProtocol) {
    // encryption explicitly turned off for a driver used on a HTTPS web page
    console.warn('Neo4j driver is configured to use insecure WebSocket on a HTTPS web page. ' + 'WebSockets might not work in a mixed content environment. ' + 'Please consider configuring driver to use encryption.');
  }
}

function detectWebPageProtocol() {
  return typeof window !== 'undefined' && window.location ? window.location.protocol : null;
}

},{"../../error":231,"../util":288,"./browser-buf":243,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":12}],245:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _baseHostNameResolver = _interopRequireDefault(require("../resolver/base-host-name-resolver"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var BrowserHostNameResolver =
/*#__PURE__*/
function (_BaseHostNameResolver) {
  (0, _inherits2["default"])(BrowserHostNameResolver, _BaseHostNameResolver);

  function BrowserHostNameResolver() {
    (0, _classCallCheck2["default"])(this, BrowserHostNameResolver);
    return (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(BrowserHostNameResolver).apply(this, arguments));
  }

  (0, _createClass2["default"])(BrowserHostNameResolver, [{
    key: "resolve",
    value: function resolve(address) {
      return this._resolveToItself(address);
    }
  }]);
  return BrowserHostNameResolver;
}(_baseHostNameResolver["default"]);

exports["default"] = BrowserHostNameResolver;

},{"../resolver/base-host-name-resolver":275,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":19}],246:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _browserBuf = _interopRequireDefault(require("../browser/browser-buf"));

var _textEncodingUtf = require("text-encoding-utf-8");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var encoder = new _textEncodingUtf.TextEncoder('utf-8');
var decoder = new _textEncodingUtf.TextDecoder('utf-8');

function encode(str) {
  return new _browserBuf["default"](encoder.encode(str).buffer);
}

function decode(buffer, length) {
  if (buffer instanceof _browserBuf["default"]) {
    return decoder.decode(buffer.readView(Math.min(length, buffer.length - buffer.position)));
  } else {
    // Copy the given buffer into a regular buffer and decode that
    var tmpBuf = new _browserBuf["default"](length);

    for (var i = 0; i < length; i++) {
      tmpBuf.writeUInt8(buffer.readUInt8());
    }

    tmpBuf.reset();
    return decoder.decode(tmpBuf.readView(length));
  }
}

var _default = {
  encode: encode,
  decode: decode
};
exports["default"] = _default;

},{"../browser/browser-buf":243,"@babel/runtime/helpers/interopRequireDefault":12,"text-encoding-utf-8":228}],247:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.utf8 = exports.HostNameResolver = exports.Channel = exports.alloc = void 0;

var _browserBuf = _interopRequireDefault(require("./browser-buf"));

var _browserChannel = _interopRequireDefault(require("./browser-channel"));

var _browserHostNameResolver = _interopRequireDefault(require("./browser-host-name-resolver"));

var _browserUtf = _interopRequireDefault(require("./browser-utf8"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*

This module exports a set of components to be used in browser environment.
They are not compatible with NodeJS environment.
All files import/require APIs from `node/index.js` by default.
Such imports are replaced at build time with `browser/index.js` when building a browser bundle.

NOTE: exports in this module should have exactly the same names/structure as exports in `node/index.js`.

 */
var alloc = function alloc(arg) {
  return new _browserBuf["default"](arg);
};

exports.alloc = alloc;
var Channel = _browserChannel["default"];
exports.Channel = Channel;
var HostNameResolver = _browserHostNameResolver["default"];
exports.HostNameResolver = HostNameResolver;
var utf8 = _browserUtf["default"];
exports.utf8 = utf8;

},{"./browser-buf":243,"./browser-channel":244,"./browser-host-name-resolver":245,"./browser-utf8":246,"@babel/runtime/helpers/interopRequireDefault":12}],248:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Common base with default implementation for most buffer methods.
 * Buffers are stateful - they track a current "position", this helps greatly
 * when reading and writing from them incrementally. You can also ignore the
 * stateful read/write methods.
 * readXXX and writeXXX-methods move the inner position of the buffer.
 * putXXX and getXXX-methods do not.
 * @access private
 */
var BaseBuffer =
/*#__PURE__*/
function () {
  /**
   * Create a instance with the injected size.
   * @constructor
   * @param {Integer} size
   */
  function BaseBuffer(size) {
    (0, _classCallCheck2["default"])(this, BaseBuffer);
    this.position = 0;
    this.length = size;
  }

  (0, _createClass2["default"])(BaseBuffer, [{
    key: "getUInt8",
    value: function getUInt8(position) {
      throw new Error('Not implemented');
    }
  }, {
    key: "getInt8",
    value: function getInt8(position) {
      throw new Error('Not implemented');
    }
  }, {
    key: "getFloat64",
    value: function getFloat64(position) {
      throw new Error('Not implemented');
    }
  }, {
    key: "putUInt8",
    value: function putUInt8(position, val) {
      throw new Error('Not implemented');
    }
  }, {
    key: "putInt8",
    value: function putInt8(position, val) {
      throw new Error('Not implemented');
    }
  }, {
    key: "putFloat64",
    value: function putFloat64(position, val) {
      throw new Error('Not implemented');
    }
    /**
     * @param p
     */

  }, {
    key: "getInt16",
    value: function getInt16(p) {
      return this.getInt8(p) << 8 | this.getUInt8(p + 1);
    }
    /**
     * @param p
     */

  }, {
    key: "getUInt16",
    value: function getUInt16(p) {
      return this.getUInt8(p) << 8 | this.getUInt8(p + 1);
    }
    /**
     * @param p
     */

  }, {
    key: "getInt32",
    value: function getInt32(p) {
      return this.getInt8(p) << 24 | this.getUInt8(p + 1) << 16 | this.getUInt8(p + 2) << 8 | this.getUInt8(p + 3);
    }
    /**
     * @param p
     */

  }, {
    key: "getUInt32",
    value: function getUInt32(p) {
      return this.getUInt8(p) << 24 | this.getUInt8(p + 1) << 16 | this.getUInt8(p + 2) << 8 | this.getUInt8(p + 3);
    }
    /**
     * @param p
     */

  }, {
    key: "getInt64",
    value: function getInt64(p) {
      return this.getInt8(p) << 56 | this.getUInt8(p + 1) << 48 | this.getUInt8(p + 2) << 40 | this.getUInt8(p + 3) << 32 | this.getUInt8(p + 4) << 24 | this.getUInt8(p + 5) << 16 | this.getUInt8(p + 6) << 8 | this.getUInt8(p + 7);
    }
    /**
     * Get a slice of this buffer. This method does not copy any data,
     * but simply provides a slice view of this buffer
     * @param start
     * @param length
     */

  }, {
    key: "getSlice",
    value: function getSlice(start, length) {
      return new SliceBuffer(start, length, this);
    }
    /**
     * @param p
     * @param val
     */

  }, {
    key: "putInt16",
    value: function putInt16(p, val) {
      this.putInt8(p, val >> 8);
      this.putUInt8(p + 1, val & 0xff);
    }
    /**
     * @param p
     * @param val
     */

  }, {
    key: "putUInt16",
    value: function putUInt16(p, val) {
      this.putUInt8(p, val >> 8 & 0xff);
      this.putUInt8(p + 1, val & 0xff);
    }
    /**
     * @param p
     * @param val
     */

  }, {
    key: "putInt32",
    value: function putInt32(p, val) {
      this.putInt8(p, val >> 24);
      this.putUInt8(p + 1, val >> 16 & 0xff);
      this.putUInt8(p + 2, val >> 8 & 0xff);
      this.putUInt8(p + 3, val & 0xff);
    }
    /**
     * @param p
     * @param val
     */

  }, {
    key: "putUInt32",
    value: function putUInt32(p, val) {
      this.putUInt8(p, val >> 24 & 0xff);
      this.putUInt8(p + 1, val >> 16 & 0xff);
      this.putUInt8(p + 2, val >> 8 & 0xff);
      this.putUInt8(p + 3, val & 0xff);
    }
    /**
     * @param p
     * @param val
     */

  }, {
    key: "putInt64",
    value: function putInt64(p, val) {
      this.putInt8(p, val >> 48);
      this.putUInt8(p + 1, val >> 42 & 0xff);
      this.putUInt8(p + 2, val >> 36 & 0xff);
      this.putUInt8(p + 3, val >> 30 & 0xff);
      this.putUInt8(p + 4, val >> 24 & 0xff);
      this.putUInt8(p + 5, val >> 16 & 0xff);
      this.putUInt8(p + 6, val >> 8 & 0xff);
      this.putUInt8(p + 7, val & 0xff);
    }
    /**
     * @param position
     * @param other
     */

  }, {
    key: "putBytes",
    value: function putBytes(position, other) {
      for (var i = 0, end = other.remaining(); i < end; i++) {
        this.putUInt8(position + i, other.readUInt8());
      }
    }
    /**
     * Read from state position.
     */

  }, {
    key: "readUInt8",
    value: function readUInt8() {
      return this.getUInt8(this._updatePos(1));
    }
    /**
     * Read from state position.
     */

  }, {
    key: "readInt8",
    value: function readInt8() {
      return this.getInt8(this._updatePos(1));
    }
    /**
     * Read from state position.
     */

  }, {
    key: "readUInt16",
    value: function readUInt16() {
      return this.getUInt16(this._updatePos(2));
    }
    /**
     * Read from state position.
     */

  }, {
    key: "readUInt32",
    value: function readUInt32() {
      return this.getUInt32(this._updatePos(4));
    }
    /**
     * Read from state position.
     */

  }, {
    key: "readInt16",
    value: function readInt16() {
      return this.getInt16(this._updatePos(2));
    }
    /**
     * Read from state position.
     */

  }, {
    key: "readInt32",
    value: function readInt32() {
      return this.getInt32(this._updatePos(4));
    }
    /**
     * Read from state position.
     */

  }, {
    key: "readInt64",
    value: function readInt64() {
      return this.getInt32(this._updatePos(8));
    }
    /**
     * Read from state position.
     */

  }, {
    key: "readFloat64",
    value: function readFloat64() {
      return this.getFloat64(this._updatePos(8));
    }
    /**
     * Write to state position.
     * @param val
     */

  }, {
    key: "writeUInt8",
    value: function writeUInt8(val) {
      this.putUInt8(this._updatePos(1), val);
    }
    /**
     * Write to state position.
     * @param val
     */

  }, {
    key: "writeInt8",
    value: function writeInt8(val) {
      this.putInt8(this._updatePos(1), val);
    }
    /**
     * Write to state position.
     * @param val
     */

  }, {
    key: "writeInt16",
    value: function writeInt16(val) {
      this.putInt16(this._updatePos(2), val);
    }
    /**
     * Write to state position.
     * @param val
     */

  }, {
    key: "writeInt32",
    value: function writeInt32(val) {
      this.putInt32(this._updatePos(4), val);
    }
    /**
     * Write to state position.
     * @param val
     */

  }, {
    key: "writeUInt32",
    value: function writeUInt32(val) {
      this.putUInt32(this._updatePos(4), val);
    }
    /**
     * Write to state position.
     * @param val
     */

  }, {
    key: "writeInt64",
    value: function writeInt64(val) {
      this.putInt64(this._updatePos(8), val);
    }
    /**
     * Write to state position.
     * @param val
     */

  }, {
    key: "writeFloat64",
    value: function writeFloat64(val) {
      this.putFloat64(this._updatePos(8), val);
    }
    /**
     * Write to state position.
     * @param val
     */

  }, {
    key: "writeBytes",
    value: function writeBytes(val) {
      this.putBytes(this._updatePos(val.remaining()), val);
    }
    /**
     * Get a slice of this buffer. This method does not copy any data,
     * but simply provides a slice view of this buffer
     * @param length
     */

  }, {
    key: "readSlice",
    value: function readSlice(length) {
      return this.getSlice(this._updatePos(length), length);
    }
  }, {
    key: "_updatePos",
    value: function _updatePos(length) {
      var p = this.position;
      this.position += length;
      return p;
    }
    /**
     * Get remaining
     */

  }, {
    key: "remaining",
    value: function remaining() {
      return this.length - this.position;
    }
    /**
     * Has remaining
     */

  }, {
    key: "hasRemaining",
    value: function hasRemaining() {
      return this.remaining() > 0;
    }
    /**
     * Reset position state
     */

  }, {
    key: "reset",
    value: function reset() {
      this.position = 0;
    }
    /**
     * Get string representation of buffer and it's state.
     * @return {string} Buffer as a string
     */

  }, {
    key: "toString",
    value: function toString() {
      return this.constructor.name + '( position=' + this.position + ' )\n  ' + this.toHex();
    }
    /**
     * Get string representation of buffer.
     * @return {string} Buffer as a string
     */

  }, {
    key: "toHex",
    value: function toHex() {
      var out = '';

      for (var i = 0; i < this.length; i++) {
        var hexByte = this.getUInt8(i).toString(16);

        if (hexByte.length === 1) {
          hexByte = '0' + hexByte;
        }

        out += hexByte;

        if (i !== this.length - 1) {
          out += ' ';
        }
      }

      return out;
    }
  }]);
  return BaseBuffer;
}();
/**
 * Represents a view as slice of another buffer.
 * @access private
 */


exports["default"] = BaseBuffer;

var SliceBuffer =
/*#__PURE__*/
function (_BaseBuffer) {
  (0, _inherits2["default"])(SliceBuffer, _BaseBuffer);

  function SliceBuffer(start, length, inner) {
    var _this;

    (0, _classCallCheck2["default"])(this, SliceBuffer);
    _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(SliceBuffer).call(this, length));
    _this._start = start;
    _this._inner = inner;
    return _this;
  }

  (0, _createClass2["default"])(SliceBuffer, [{
    key: "putUInt8",
    value: function putUInt8(position, val) {
      this._inner.putUInt8(this._start + position, val);
    }
  }, {
    key: "getUInt8",
    value: function getUInt8(position) {
      return this._inner.getUInt8(this._start + position);
    }
  }, {
    key: "putInt8",
    value: function putInt8(position, val) {
      this._inner.putInt8(this._start + position, val);
    }
  }, {
    key: "putFloat64",
    value: function putFloat64(position, val) {
      this._inner.putFloat64(this._start + position, val);
    }
  }, {
    key: "getInt8",
    value: function getInt8(position) {
      return this._inner.getInt8(this._start + position);
    }
  }, {
    key: "getFloat64",
    value: function getFloat64(position) {
      return this._inner.getFloat64(this._start + position);
    }
  }]);
  return SliceBuffer;
}(BaseBuffer);

},{"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":19}],249:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _baseBuf = _interopRequireDefault(require("./base-buf"));

var _node = require('../browser');

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Buffer that combines multiple buffers, exposing them as one single buffer.
 */
var CombinedBuffer =
/*#__PURE__*/
function (_BaseBuffer) {
  (0, _inherits2["default"])(CombinedBuffer, _BaseBuffer);

  function CombinedBuffer(buffers) {
    var _this;

    (0, _classCallCheck2["default"])(this, CombinedBuffer);
    var length = 0;

    for (var i = 0; i < buffers.length; i++) {
      length += buffers[i].length;
    }

    _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(CombinedBuffer).call(this, length));
    _this._buffers = buffers;
    return _this;
  }

  (0, _createClass2["default"])(CombinedBuffer, [{
    key: "getUInt8",
    value: function getUInt8(position) {
      // Surely there's a faster way to do this.. some sort of lookup table thing?
      for (var i = 0; i < this._buffers.length; i++) {
        var buffer = this._buffers[i]; // If the position is not in the current buffer, skip the current buffer

        if (position >= buffer.length) {
          position -= buffer.length;
        } else {
          return buffer.getUInt8(position);
        }
      }
    }
  }, {
    key: "getInt8",
    value: function getInt8(position) {
      // Surely there's a faster way to do this.. some sort of lookup table thing?
      for (var i = 0; i < this._buffers.length; i++) {
        var buffer = this._buffers[i]; // If the position is not in the current buffer, skip the current buffer

        if (position >= buffer.length) {
          position -= buffer.length;
        } else {
          return buffer.getInt8(position);
        }
      }
    }
  }, {
    key: "getFloat64",
    value: function getFloat64(position) {
      // At some point, a more efficient impl. For now, we copy the 8 bytes
      // we want to read and depend on the platform impl of IEEE 754.
      var b = (0, _node.alloc)(8);

      for (var i = 0; i < 8; i++) {
        b.putUInt8(i, this.getUInt8(position + i));
      }

      return b.getFloat64(0);
    }
  }]);
  return CombinedBuffer;
}(_baseBuf["default"]);

exports["default"] = CombinedBuffer;

},{"../browser":247,"./base-buf":248,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":19}],250:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _error = require("../error");

var _util = require("./util");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var DEFAULT_CONNECTION_TIMEOUT_MILLIS = 30000; // 30 seconds by default

var ALLOWED_VALUES_ENCRYPTED = [null, undefined, true, false, _util.ENCRYPTION_ON, _util.ENCRYPTION_OFF];
var ALLOWED_VALUES_TRUST = [null, undefined, 'TRUST_ALL_CERTIFICATES', 'TRUST_CUSTOM_CA_SIGNED_CERTIFICATES', 'TRUST_SYSTEM_CA_SIGNED_CERTIFICATES'];

var ChannelConfig =
/**
 * @constructor
 * @param {ServerAddress} address the address for the channel to connect to.
 * @param {Object} driverConfig the driver config provided by the user when driver is created.
 * @param {string} connectionErrorCode the default error code to use on connection errors.
 */
function ChannelConfig(address, driverConfig, connectionErrorCode) {
  (0, _classCallCheck2["default"])(this, ChannelConfig);
  this.address = address;
  this.encrypted = extractEncrypted(driverConfig);
  this.trust = extractTrust(driverConfig);
  this.trustedCertificates = extractTrustedCertificates(driverConfig);
  this.knownHostsPath = extractKnownHostsPath(driverConfig);
  this.connectionErrorCode = connectionErrorCode || _error.SERVICE_UNAVAILABLE;
  this.connectionTimeout = extractConnectionTimeout(driverConfig);
};

exports["default"] = ChannelConfig;

function extractEncrypted(driverConfig) {
  var value = driverConfig.encrypted;

  if (ALLOWED_VALUES_ENCRYPTED.indexOf(value) === -1) {
    throw (0, _error.newError)("Illegal value of the encrypted setting ".concat(value, ". Expected one of ").concat(ALLOWED_VALUES_ENCRYPTED));
  }

  return value;
}

function extractTrust(driverConfig) {
  var value = driverConfig.trust;

  if (ALLOWED_VALUES_TRUST.indexOf(value) === -1) {
    throw (0, _error.newError)("Illegal value of the trust setting ".concat(value, ". Expected one of ").concat(ALLOWED_VALUES_TRUST));
  }

  return value;
}

function extractTrustedCertificates(driverConfig) {
  return driverConfig.trustedCertificates || [];
}

function extractKnownHostsPath(driverConfig) {
  return driverConfig.knownHosts || null;
}

function extractConnectionTimeout(driverConfig) {
  var configuredTimeout = parseInt(driverConfig.connectionTimeout, 10);

  if (configuredTimeout === 0) {
    // timeout explicitly configured to 0
    return null;
  } else if (configuredTimeout && configuredTimeout < 0) {
    // timeout explicitly configured to a negative value
    return null;
  } else if (!configuredTimeout) {
    // timeout not configured, use default value
    return DEFAULT_CONNECTION_TIMEOUT_MILLIS;
  } else {
    // timeout configured, use the provided value
    return configuredTimeout;
  }
}

},{"../error":231,"./util":288,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/interopRequireDefault":12}],251:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Dechunker = exports.Chunker = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _baseBuf = _interopRequireDefault(require("./buf/base-buf"));

var _node = require('./browser');

var _combinedBuf = _interopRequireDefault(require("./buf/combined-buf"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var _CHUNK_HEADER_SIZE = 2;
var _MESSAGE_BOUNDARY = 0x00;
var _DEFAULT_BUFFER_SIZE = 1400; // http://stackoverflow.com/questions/2613734/maximum-packet-size-for-a-tcp-connection

/**
 * Looks like a writable buffer, chunks output transparently into a channel below.
 * @access private
 */

var Chunker =
/*#__PURE__*/
function (_BaseBuffer) {
  (0, _inherits2["default"])(Chunker, _BaseBuffer);

  function Chunker(channel, bufferSize) {
    var _this;

    (0, _classCallCheck2["default"])(this, Chunker);
    _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(Chunker).call(this, 0));
    _this._bufferSize = bufferSize || _DEFAULT_BUFFER_SIZE;
    _this._ch = channel;
    _this._buffer = (0, _node.alloc)(_this._bufferSize);
    _this._currentChunkStart = 0;
    _this._chunkOpen = false;
    return _this;
  }

  (0, _createClass2["default"])(Chunker, [{
    key: "putUInt8",
    value: function putUInt8(position, val) {
      this._ensure(1);

      this._buffer.writeUInt8(val);
    }
  }, {
    key: "putInt8",
    value: function putInt8(position, val) {
      this._ensure(1);

      this._buffer.writeInt8(val);
    }
  }, {
    key: "putFloat64",
    value: function putFloat64(position, val) {
      this._ensure(8);

      this._buffer.writeFloat64(val);
    }
  }, {
    key: "putBytes",
    value: function putBytes(position, data) {
      // TODO: If data is larger than our chunk size or so, we're very likely better off just passing this buffer on
      // rather than doing the copy here TODO: *however* note that we need some way to find out when the data has been
      // written (and thus the buffer can be re-used) if we take that approach
      while (data.remaining() > 0) {
        // Ensure there is an open chunk, and that it has at least one byte of space left
        this._ensure(1);

        if (this._buffer.remaining() > data.remaining()) {
          this._buffer.writeBytes(data);
        } else {
          this._buffer.writeBytes(data.readSlice(this._buffer.remaining()));
        }
      }

      return this;
    }
  }, {
    key: "flush",
    value: function flush() {
      if (this._buffer.position > 0) {
        this._closeChunkIfOpen(); // Local copy and clear the buffer field. This ensures that the buffer is not re-released if the flush call fails


        var out = this._buffer;
        this._buffer = null;

        this._ch.write(out.getSlice(0, out.position)); // Alloc a new output buffer. We assume we're using NodeJS's buffer pooling under the hood here!


        this._buffer = (0, _node.alloc)(this._bufferSize);
        this._chunkOpen = false;
      }

      return this;
    }
    /**
     * Bolt messages are encoded in one or more chunks, and the boundary between two messages
     * is encoded as a 0-length chunk, `00 00`. This inserts such a message boundary, closing
     * any currently open chunk as needed
     */

  }, {
    key: "messageBoundary",
    value: function messageBoundary() {
      this._closeChunkIfOpen();

      if (this._buffer.remaining() < _CHUNK_HEADER_SIZE) {
        this.flush();
      } // Write message boundary


      this._buffer.writeInt16(_MESSAGE_BOUNDARY);
    }
    /** Ensure at least the given size is available for writing */

  }, {
    key: "_ensure",
    value: function _ensure(size) {
      var toWriteSize = this._chunkOpen ? size : size + _CHUNK_HEADER_SIZE;

      if (this._buffer.remaining() < toWriteSize) {
        this.flush();
      }

      if (!this._chunkOpen) {
        this._currentChunkStart = this._buffer.position;
        this._buffer.position = this._buffer.position + _CHUNK_HEADER_SIZE;
        this._chunkOpen = true;
      }
    }
  }, {
    key: "_closeChunkIfOpen",
    value: function _closeChunkIfOpen() {
      if (this._chunkOpen) {
        var chunkSize = this._buffer.position - (this._currentChunkStart + _CHUNK_HEADER_SIZE);

        this._buffer.putUInt16(this._currentChunkStart, chunkSize);

        this._chunkOpen = false;
      }
    }
  }]);
  return Chunker;
}(_baseBuf["default"]);
/**
 * Combines chunks until a complete message is gathered up, and then forwards that
 * message to an 'onmessage' listener.
 * @access private
 */


exports.Chunker = Chunker;

var Dechunker =
/*#__PURE__*/
function () {
  function Dechunker() {
    (0, _classCallCheck2["default"])(this, Dechunker);
    this._currentMessage = [];
    this._partialChunkHeader = 0;
    this._state = this.AWAITING_CHUNK;
  }

  (0, _createClass2["default"])(Dechunker, [{
    key: "AWAITING_CHUNK",
    value: function AWAITING_CHUNK(buf) {
      if (buf.remaining() >= 2) {
        // Whole header available, read that
        return this._onHeader(buf.readUInt16());
      } else {
        // Only one byte available, read that and wait for the second byte
        this._partialChunkHeader = buf.readUInt8() << 8;
        return this.IN_HEADER;
      }
    }
  }, {
    key: "IN_HEADER",
    value: function IN_HEADER(buf) {
      // First header byte read, now we read the next one
      return this._onHeader((this._partialChunkHeader | buf.readUInt8()) & 0xffff);
    }
  }, {
    key: "IN_CHUNK",
    value: function IN_CHUNK(buf) {
      if (this._chunkSize <= buf.remaining()) {
        // Current packet is larger than current chunk, or same size:
        this._currentMessage.push(buf.readSlice(this._chunkSize));

        return this.AWAITING_CHUNK;
      } else {
        // Current packet is smaller than the chunk we're reading, split the current chunk itself up
        this._chunkSize -= buf.remaining();

        this._currentMessage.push(buf.readSlice(buf.remaining()));

        return this.IN_CHUNK;
      }
    }
  }, {
    key: "CLOSED",
    value: function CLOSED(buf) {} // no-op

    /** Called when a complete chunk header has been received */

  }, {
    key: "_onHeader",
    value: function _onHeader(header) {
      if (header === 0) {
        // Message boundary
        var message;

        switch (this._currentMessage.length) {
          case 0:
            // Keep alive chunk, sent by server to keep network alive.
            return this.AWAITING_CHUNK;

          case 1:
            // All data in one chunk, this signals the end of that chunk.
            message = this._currentMessage[0];
            break;

          default:
            // A large chunk of data received, this signals that the last chunk has been received.
            message = new _combinedBuf["default"](this._currentMessage);
            break;
        }

        this._currentMessage = [];
        this.onmessage(message);
        return this.AWAITING_CHUNK;
      } else {
        this._chunkSize = header;
        return this.IN_CHUNK;
      }
    }
  }, {
    key: "write",
    value: function write(buf) {
      while (buf.hasRemaining()) {
        this._state = this._state(buf);
      }
    }
  }]);
  return Dechunker;
}();

exports.Dechunker = Dechunker;

},{"./browser":247,"./buf/base-buf":248,"./buf/combined-buf":249,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":19}],252:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _node = require('./browser');

var _chunking = require("./chunking");

var _error = require("../error");

var _channelConfig = _interopRequireDefault(require("./channel-config"));

var _protocolHandshaker = _interopRequireDefault(require("./protocol-handshaker"));

var _connection = _interopRequireDefault(require("./connection"));

var _boltProtocolV = _interopRequireDefault(require("./bolt-protocol-v1"));

var _streamObservers = require("./stream-observers");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Signature bytes for each response message type
var SUCCESS = 0x70; // 0111 0000 // SUCCESS <metadata>

var RECORD = 0x71; // 0111 0001 // RECORD <value>

var IGNORED = 0x7e; // 0111 1110 // IGNORED <metadata>

var FAILURE = 0x7f; // 0111 1111 // FAILURE <metadata>

function NO_OP() {}

var NO_OP_OBSERVER = {
  onNext: NO_OP,
  onCompleted: NO_OP,
  onError: NO_OP
};
var idGenerator = 0;

var ChannelConnection =
/*#__PURE__*/
function (_Connection) {
  (0, _inherits2["default"])(ChannelConnection, _Connection);

  /**
   * @constructor
   * @param {Channel} channel - channel with a 'write' function and a 'onmessage' callback property.
   * @param {ConnectionErrorHandler} errorHandler the error handler.
   * @param {ServerAddress} address - the server address to connect to.
   * @param {Logger} log - the configured logger.
   * @param {boolean} disableLosslessIntegers if this connection should convert all received integers to native JS numbers.
   */
  function ChannelConnection(channel, errorHandler, address, log) {
    var _this;

    var disableLosslessIntegers = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
    var serversideRouting = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
    (0, _classCallCheck2["default"])(this, ChannelConnection);
    _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(ChannelConnection).call(this, errorHandler));
    _this._id = idGenerator++;
    _this._address = address;
    _this._server = {
      address: address.asHostPort()
    };
    _this.creationTimestamp = Date.now();
    _this._disableLosslessIntegers = disableLosslessIntegers;
    _this._pendingObservers = [];
    _this._currentObserver = undefined;
    _this._ch = channel;
    _this._dechunker = new _chunking.Dechunker();
    _this._chunker = new _chunking.Chunker(channel);
    _this._log = log;
    _this._serversideRouting = serversideRouting; // connection from the database, returned in response for HELLO message and might not be available

    _this._dbConnectionId = null; // bolt protocol is initially not initialized

    /**
     * @private
     * @type {BoltProtocol}
     */

    _this._protocol = null; // error extracted from a FAILURE message

    _this._currentFailure = null; // Set to true on fatal errors, to get this out of connection pool.

    _this._isBroken = false;

    if (_this._log.isDebugEnabled()) {
      _this._log.debug("".concat((0, _assertThisInitialized2["default"])(_this), " created towards ").concat(address));
    }

    return _this;
  }
  /**
   * Crete new connection to the provided address. Returned connection is not connected.
   * @param {ServerAddress} address - the Bolt endpoint to connect to.
   * @param {Object} config - the driver configuration.
   * @param {ConnectionErrorHandler} errorHandler - the error handler for connection errors.
   * @param {Logger} log - configured logger.
   * @return {Connection} - new connection.
   */


  (0, _createClass2["default"])(ChannelConnection, [{
    key: "connect",

    /**
     * Connect to the target address, negotiate Bolt protocol and send initialization message.
     * @param {string} userAgent the user agent for this driver.
     * @param {Object} authToken the object containing auth information.
     * @return {Promise<Connection>} promise resolved with the current connection if connection is successful. Rejected promise otherwise.
     */
    value: function connect(userAgent, authToken) {
      var _this2 = this;

      return this._negotiateProtocol().then(function () {
        return _this2._initialize(userAgent, authToken);
      });
    }
    /**
     * Execute Bolt protocol handshake to initialize the protocol version.
     * @return {Promise<Connection>} promise resolved with the current connection if handshake is successful. Rejected promise otherwise.
     */

  }, {
    key: "_negotiateProtocol",
    value: function _negotiateProtocol() {
      var _this3 = this;

      var protocolHandshaker = new _protocolHandshaker["default"](this, this._ch, this._chunker, this._disableLosslessIntegers, this._log, this._serversideRouting);
      return new Promise(function (resolve, reject) {
        var handshakeErrorHandler = function handshakeErrorHandler(error) {
          _this3._handleFatalError(error);

          reject(error);
        };

        _this3._ch.onerror = handshakeErrorHandler.bind(_this3);

        if (_this3._ch._error) {
          // channel is already broken
          handshakeErrorHandler(_this3._ch._error);
        }

        _this3._ch.onmessage = function (buffer) {
          try {
            // read the response buffer and initialize the protocol
            _this3._protocol = protocolHandshaker.createNegotiatedProtocol(buffer); // reset the error handler to just handle errors and forget about the handshake promise

            _this3._ch.onerror = _this3._handleFatalError.bind(_this3); // Ok, protocol running. Simply forward all messages to the dechunker

            _this3._ch.onmessage = function (buf) {
              return _this3._dechunker.write(buf);
            }; // setup dechunker to dechunk messages and forward them to the message handler


            _this3._dechunker.onmessage = function (buf) {
              _this3._handleMessage(_this3._protocol.unpacker().unpack(buf));
            }; // forward all pending bytes to the dechunker


            if (buffer.hasRemaining()) {
              _this3._dechunker.write(buffer.readSlice(buffer.remaining()));
            }

            resolve(_this3);
          } catch (e) {
            _this3._handleFatalError(e);

            reject(e);
          }
        };

        protocolHandshaker.writeHandshakeRequest();
      });
    }
    /**
     * Perform protocol-specific initialization which includes authentication.
     * @param {string} userAgent the user agent for this driver.
     * @param {Object} authToken the object containing auth information.
     * @return {Promise<Connection>} promise resolved with the current connection if initialization is successful. Rejected promise otherwise.
     */

  }, {
    key: "_initialize",
    value: function _initialize(userAgent, authToken) {
      var _this4 = this;

      var self = this;
      return new Promise(function (resolve, reject) {
        _this4._protocol.initialize({
          userAgent: userAgent,
          authToken: authToken,
          onError: function onError(err) {
            return reject(err);
          },
          onComplete: function onComplete() {
            return resolve(self);
          }
        });
      });
    }
    /**
     * Get the Bolt protocol for the connection.
     * @return {BoltProtocol} the protocol.
     */

  }, {
    key: "protocol",
    value: function protocol() {
      return this._protocol;
    }
  }, {
    key: "write",

    /**
     * Write a message to the network channel.
     * @param {RequestMessage} message the message to write.
     * @param {ResultStreamObserver} observer the response observer.
     * @param {boolean} flush `true` if flush should happen after the message is written to the buffer.
     */
    value: function write(message, observer, flush) {
      var _this5 = this;

      var queued = this._queueObserver(observer);

      if (queued) {
        if (this._log.isDebugEnabled()) {
          this._log.debug("".concat(this, " C: ").concat(message));
        }

        this._protocol.packer().packStruct(message.signature, message.fields.map(function (field) {
          return _this5._packable(field);
        }));

        this._chunker.messageBoundary();

        if (flush) {
          this._chunker.flush();
        }
      }
    }
    /**
     * "Fatal" means the connection is dead. Only call this if something
     * happens that cannot be recovered from. This will lead to all subscribers
     * failing, and the connection getting ejected from the session pool.
     *
     * @param error an error object, forwarded to all current and future subscribers
     */

  }, {
    key: "_handleFatalError",
    value: function _handleFatalError(error) {
      this._isBroken = true;
      this._error = this.handleAndTransformError(error, this._address);

      if (this._log.isErrorEnabled()) {
        this._log.error("".concat(this, " experienced a fatal error ").concat(JSON.stringify(this._error)));
      }

      if (this._currentObserver && this._currentObserver.onError) {
        this._currentObserver.onError(this._error);
      }

      while (this._pendingObservers.length > 0) {
        var observer = this._pendingObservers.shift();

        if (observer && observer.onError) {
          observer.onError(this._error);
        }
      }
    }
  }, {
    key: "_handleMessage",
    value: function _handleMessage(msg) {
      if (this._isBroken) {
        // ignore all incoming messages when this connection is broken. all previously pending observers failed
        // with the fatal error. all future observers will fail with same fatal error.
        return;
      }

      var payload = msg.fields[0];

      switch (msg.signature) {
        case RECORD:
          if (this._log.isDebugEnabled()) {
            this._log.debug("".concat(this, " S: RECORD ").concat(JSON.stringify(msg)));
          }

          this._currentObserver.onNext(payload);

          break;

        case SUCCESS:
          if (this._log.isDebugEnabled()) {
            this._log.debug("".concat(this, " S: SUCCESS ").concat(JSON.stringify(msg)));
          }

          try {
            var metadata = this._protocol.transformMetadata(payload);

            this._currentObserver.onCompleted(metadata);
          } finally {
            this._updateCurrentObserver();
          }

          break;

        case FAILURE:
          if (this._log.isDebugEnabled()) {
            this._log.debug("".concat(this, " S: FAILURE ").concat(JSON.stringify(msg)));
          }

          try {
            var error = (0, _error.newError)(payload.message, payload.code);
            this._currentFailure = this.handleAndTransformError(error, this._address);

            this._currentObserver.onError(this._currentFailure);
          } finally {
            this._updateCurrentObserver(); // Things are now broken. Pending observers will get FAILURE messages routed until we are done handling this failure.


            this._resetOnFailure();
          }

          break;

        case IGNORED:
          if (this._log.isDebugEnabled()) {
            this._log.debug("".concat(this, " S: IGNORED ").concat(JSON.stringify(msg)));
          }

          try {
            if (this._currentFailure && this._currentObserver.onError) {
              this._currentObserver.onError(this._currentFailure);
            } else if (this._currentObserver.onError) {
              this._currentObserver.onError((0, _error.newError)('Ignored either because of an error or RESET'));
            }
          } finally {
            this._updateCurrentObserver();
          }

          break;

        default:
          this._handleFatalError((0, _error.newError)('Unknown Bolt protocol message: ' + msg));

      }
    }
    /**
     * Send a RESET-message to the database. Message is immediately flushed to the network.
     * @return {Promise<void>} promise resolved when SUCCESS-message response arrives, or failed when other response messages arrives.
     */

  }, {
    key: "resetAndFlush",
    value: function resetAndFlush() {
      var _this6 = this;

      return new Promise(function (resolve, reject) {
        _this6._protocol.reset({
          onError: function onError(error) {
            if (_this6._isBroken) {
              // handling a fatal error, no need to raise a protocol violation
              reject(error);
            } else {
              var neo4jError = _this6._handleProtocolError('Received FAILURE as a response for RESET: ' + error);

              reject(neo4jError);
            }
          },
          onComplete: function onComplete() {
            resolve();
          }
        });
      });
    }
  }, {
    key: "_resetOnFailure",
    value: function _resetOnFailure() {
      var _this7 = this;

      this._protocol.reset({
        onError: function onError() {
          _this7._currentFailure = null;
        },
        onComplete: function onComplete() {
          _this7._currentFailure = null;
        }
      });
    }
  }, {
    key: "_queueObserver",
    value: function _queueObserver(observer) {
      if (this._isBroken) {
        if (observer && observer.onError) {
          observer.onError(this._error);
        }

        return false;
      }

      observer = observer || NO_OP_OBSERVER;
      observer.onCompleted = observer.onCompleted || NO_OP;
      observer.onError = observer.onError || NO_OP;
      observer.onNext = observer.onNext || NO_OP;

      if (this._currentObserver === undefined) {
        this._currentObserver = observer;
      } else {
        this._pendingObservers.push(observer);
      }

      return true;
    }
    /*
     * Pop next pending observer form the list of observers and make it current observer.
     * @protected
     */

  }, {
    key: "_updateCurrentObserver",
    value: function _updateCurrentObserver() {
      this._currentObserver = this._pendingObservers.shift();
    }
    /** Check if this connection is in working condition */

  }, {
    key: "isOpen",
    value: function isOpen() {
      return !this._isBroken && this._ch._open;
    }
    /**
     * Call close on the channel.
     * @returns {Promise<void>} - A promise that will be resolved when the underlying channel is closed.
     */

  }, {
    key: "close",
    value: function () {
      var _close = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee() {
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (this._log.isDebugEnabled()) {
                  this._log.debug("".concat(this, " closing"));
                }

                if (this._protocol && this.isOpen()) {
                  // protocol has been initialized and this connection is healthy
                  // notify the database about the upcoming close of the connection
                  this._protocol.prepareToClose();
                }

                _context.next = 4;
                return this._ch.close();

              case 4:
                if (this._log.isDebugEnabled()) {
                  this._log.debug("".concat(this, " closed"));
                }

              case 5:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function close() {
        return _close.apply(this, arguments);
      }

      return close;
    }()
  }, {
    key: "toString",
    value: function toString() {
      return "Connection [".concat(this.id, "][").concat(this.databaseId || '', "]");
    }
  }, {
    key: "_packable",
    value: function _packable(value) {
      return this._protocol.packer().packable(value);
    }
  }, {
    key: "_handleProtocolError",
    value: function _handleProtocolError(message) {
      this._currentFailure = null;

      this._updateCurrentObserver();

      var error = (0, _error.newError)(message, _error.PROTOCOL_ERROR);

      this._handleFatalError(error);

      return error;
    }
  }, {
    key: "id",
    get: function get() {
      return this._id;
    }
  }, {
    key: "databaseId",
    get: function get() {
      return this._dbConnectionId;
    },
    set: function set(value) {
      this._dbConnectionId = value;
    }
  }, {
    key: "address",
    get: function get() {
      return this._address;
    }
    /**
     * Get the version of the connected server.
     * Available only after initialization
     *
     * @returns {ServerVersion} version
     */

  }, {
    key: "version",
    get: function get() {
      return this._server.version;
    },
    set: function set(value) {
      this._server.version = value;
    }
  }, {
    key: "server",
    get: function get() {
      return this._server;
    }
  }], [{
    key: "create",
    value: function create(address, config, errorHandler, log) {
      var serversideRouting = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
      var channelConfig = new _channelConfig["default"](address, config, errorHandler.errorCode());
      return new ChannelConnection(new _node.Channel(channelConfig), errorHandler, address, log, config.disableLosslessIntegers, serversideRouting);
    }
  }]);
  return ChannelConnection;
}(_connection["default"]);

exports["default"] = ChannelConnection;

},{"../error":231,"./bolt-protocol-v1":236,"./browser":247,"./channel-config":250,"./chunking":251,"./connection":262,"./protocol-handshaker":272,"./stream-observers":283,"@babel/runtime/helpers/assertThisInitialized":3,"@babel/runtime/helpers/asyncToGenerator":4,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":19,"@babel/runtime/regenerator":27}],253:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _connection = _interopRequireDefault(require("./connection"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var DelegateConnection =
/*#__PURE__*/
function (_Connection) {
  (0, _inherits2["default"])(DelegateConnection, _Connection);

  /**
   * @param delegate {Connection} the delegated connection
   * @param errorHandler {ConnectionErrorHandler} the error handler
   */
  function DelegateConnection(delegate, errorHandler) {
    var _this;

    (0, _classCallCheck2["default"])(this, DelegateConnection);
    _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(DelegateConnection).call(this, errorHandler));

    if (errorHandler) {
      _this._originalErrorHandler = delegate._errorHandler;
      delegate._errorHandler = _this._errorHandler;
    }

    _this._delegate = delegate;
    return _this;
  }

  (0, _createClass2["default"])(DelegateConnection, [{
    key: "isOpen",
    value: function isOpen() {
      return this._delegate.isOpen();
    }
  }, {
    key: "protocol",
    value: function protocol() {
      return this._delegate.protocol();
    }
  }, {
    key: "connect",
    value: function connect(userAgent, authToken) {
      return this._delegate.connect(userAgent, authToken);
    }
  }, {
    key: "write",
    value: function write(message, observer, flush) {
      return this._delegate.write(message, observer, flush);
    }
  }, {
    key: "resetAndFlush",
    value: function resetAndFlush() {
      return this._delegate.resetAndFlush();
    }
  }, {
    key: "close",
    value: function close() {
      return this._delegate.close();
    }
  }, {
    key: "_release",
    value: function _release() {
      if (this._originalErrorHandler) {
        this._delegate._errorHandler = this._originalErrorHandler;
      }

      return this._delegate._release();
    }
  }, {
    key: "id",
    get: function get() {
      return this._delegate.id;
    }
  }, {
    key: "databaseId",
    get: function get() {
      return this._delegate.databaseId;
    },
    set: function set(value) {
      this._delegate.databaseId = value;
    }
  }, {
    key: "server",
    get: function get() {
      return this._delegate.server;
    }
  }, {
    key: "address",
    get: function get() {
      return this._delegate.address;
    }
  }, {
    key: "version",
    get: function get() {
      return this._delegate.version;
    },
    set: function set(value) {
      this._delegate.version = value;
    }
  }]);
  return DelegateConnection;
}(_connection["default"]);

exports["default"] = DelegateConnection;

},{"./connection":262,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":19}],254:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _error = require("../error");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var ConnectionErrorHandler =
/*#__PURE__*/
function () {
  function ConnectionErrorHandler(errorCode, handleUnavailability, handleWriteFailure) {
    (0, _classCallCheck2["default"])(this, ConnectionErrorHandler);
    this._errorCode = errorCode;
    this._handleUnavailability = handleUnavailability || noOpHandler;
    this._handleWriteFailure = handleWriteFailure || noOpHandler;
  }
  /**
   * Error code to use for network errors.
   * @return {string} the error code.
   */


  (0, _createClass2["default"])(ConnectionErrorHandler, [{
    key: "errorCode",
    value: function errorCode() {
      return this._errorCode;
    }
    /**
     * Handle and transform the error.
     * @param {Neo4jError} error the original error.
     * @param {ServerAddress} address the address of the connection where the error happened.
     * @return {Neo4jError} new error that should be propagated to the user.
     */

  }, {
    key: "handleAndTransformError",
    value: function handleAndTransformError(error, address) {
      if (isAvailabilityError(error)) {
        return this._handleUnavailability(error, address);
      }

      if (isFailureToWrite(error)) {
        return this._handleWriteFailure(error, address);
      }

      return error;
    }
  }]);
  return ConnectionErrorHandler;
}();

exports["default"] = ConnectionErrorHandler;

function isAvailabilityError(error) {
  if (error) {
    return error.code === _error.SESSION_EXPIRED || error.code === _error.SERVICE_UNAVAILABLE || error.code === 'Neo.TransientError.General.DatabaseUnavailable';
  }

  return false;
}

function isFailureToWrite(error) {
  if (error) {
    return error.code === 'Neo.ClientError.Cluster.NotALeader' || error.code === 'Neo.ClientError.General.ForbiddenOnReadOnlyDatabase';
  }

  return false;
}

function noOpHandler(error) {
  return error;
}

},{"../error":231,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":12}],255:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _connectionHolder = _interopRequireDefault(require("./connection-holder"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Provides a interaction with a ConnectionHolder without change it state by
 * releasing or initilizing
 */
var ReadOnlyConnectionHolder =
/*#__PURE__*/
function (_ConnectionHolder) {
  (0, _inherits2["default"])(ReadOnlyConnectionHolder, _ConnectionHolder);

  /**
   * Contructor
   * @param {ConnectionHolder} connectionHolder the connection holder which will treat the requests
   */
  function ReadOnlyConnectionHolder(connectionHolder) {
    var _this;

    (0, _classCallCheck2["default"])(this, ReadOnlyConnectionHolder);
    _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(ReadOnlyConnectionHolder).call(this, {
      mode: connectionHolder._mode,
      database: connectionHolder._database,
      bookmark: connectionHolder._bookmark,
      connectionProvider: connectionHolder._connectionProvider
    }));
    _this._connectionHolder = connectionHolder;
    return _this;
  }
  /**
   * Return the true if the connection is suppose to be initilized with the command.
   *
   * @return {boolean}
   */


  (0, _createClass2["default"])(ReadOnlyConnectionHolder, [{
    key: "initializeConnection",
    value: function initializeConnection() {
      if (this._connectionHolder._referenceCount === 0) {
        return false;
      }

      return true;
    }
    /**
     * Get the current connection promise.
     * @return {Promise<Connection>} promise resolved with the current connection.
     */

  }, {
    key: "getConnection",
    value: function getConnection() {
      return this._connectionHolder.getConnection();
    }
    /**
     * Get the current connection promise, doesn't performs the release
     * @return {Promise<Connection>} promise with the resolved current connection
     */

  }, {
    key: "releaseConnection",
    value: function releaseConnection() {
      return this._connectionHolder.getConnection()["catch"](function () {
        return Promise.resolve();
      });
    }
    /**
     * Get the current connection promise, doesn't performs the connection close
     * @return {Promise<Connection>} promise with the resolved current connection
     */

  }, {
    key: "close",
    value: function close() {
      return this._connectionHolder.getConnection()["catch"](function () {
        return function () {
          return Promise.resolve();
        };
      });
    }
  }]);
  return ReadOnlyConnectionHolder;
}(_connectionHolder["default"]);

exports["default"] = ReadOnlyConnectionHolder;

},{"./connection-holder":256,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":19}],256:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EMPTY_CONNECTION_HOLDER = exports["default"] = void 0;

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _error = require("../error");

var _util = require("./util");

var _constants = require("./constants");

var _bookmark = _interopRequireDefault(require("./bookmark"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Utility to lazily initialize connections and return them back to the pool when unused.
 */
var ConnectionHolder =
/*#__PURE__*/
function () {
  /**
   * @constructor
   * @param {string} mode - the access mode for new connection holder.
   * @param {string} database - the target database name.
   * @param {ConnectionProvider} connectionProvider - the connection provider to acquire connections from.
   */
  function ConnectionHolder() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$mode = _ref.mode,
        mode = _ref$mode === void 0 ? _constants.ACCESS_MODE_WRITE : _ref$mode,
        _ref$database = _ref.database,
        database = _ref$database === void 0 ? '' : _ref$database,
        bookmark = _ref.bookmark,
        connectionProvider = _ref.connectionProvider;

    (0, _classCallCheck2["default"])(this, ConnectionHolder);
    this._mode = mode;
    this._database = database ? (0, _util.assertString)(database, 'database') : '';
    this._bookmark = bookmark || _bookmark["default"].empty();
    this._connectionProvider = connectionProvider;
    this._referenceCount = 0;
    this._connectionPromise = Promise.resolve(null);
  }
  /**
   * Returns the assigned access mode.
   * @returns {string} access mode
   */


  (0, _createClass2["default"])(ConnectionHolder, [{
    key: "mode",
    value: function mode() {
      return this._mode;
    }
    /**
     * Returns the target database name
     * @returns {string} the database name
     */

  }, {
    key: "database",
    value: function database() {
      return this._database;
    }
    /**
     * Make this holder initialize new connection if none exists already.
     * @return {boolean}
     */

  }, {
    key: "initializeConnection",
    value: function initializeConnection() {
      if (this._referenceCount === 0) {
        this._connectionPromise = this._connectionProvider.acquireConnection({
          accessMode: this._mode,
          database: this._database,
          bookmark: this._bookmark
        });
      } else {
        this._referenceCount++;
        return false;
      }

      this._referenceCount++;
      return true;
    }
    /**
     * Get the current connection promise.
     * @return {Promise<Connection>} promise resolved with the current connection.
     */

  }, {
    key: "getConnection",
    value: function getConnection() {
      return this._connectionPromise;
    }
    /**
     * Notify this holder that single party does not require current connection any more.
     * @return {Promise<Connection>} promise resolved with the current connection, never a rejected promise.
     */

  }, {
    key: "releaseConnection",
    value: function releaseConnection() {
      if (this._referenceCount === 0) {
        return this._connectionPromise;
      }

      this._referenceCount--;

      if (this._referenceCount === 0) {
        return this._releaseConnection();
      }

      return this._connectionPromise;
    }
    /**
     * Closes this holder and releases current connection (if any) despite any existing users.
     * @return {Promise<Connection>} promise resolved when current connection is released to the pool.
     */

  }, {
    key: "close",
    value: function close() {
      if (this._referenceCount === 0) {
        return this._connectionPromise;
      }

      this._referenceCount = 0;
      return this._releaseConnection();
    }
    /**
     * Return the current pooled connection instance to the connection pool.
     * We don't pool Session instances, to avoid users using the Session after they've called close.
     * The `Session` object is just a thin wrapper around Connection anyway, so it makes little difference.
     * @return {Promise} - promise resolved then connection is returned to the pool.
     * @private
     */

  }, {
    key: "_releaseConnection",
    value: function _releaseConnection() {
      this._connectionPromise = this._connectionPromise.then(function (connection) {
        if (connection) {
          return connection.resetAndFlush()["catch"](ignoreError).then(function () {
            return connection._release();
          });
        } else {
          return Promise.resolve();
        }
      })["catch"](ignoreError);
      return this._connectionPromise;
    }
  }]);
  return ConnectionHolder;
}();

exports["default"] = ConnectionHolder;

var EmptyConnectionHolder =
/*#__PURE__*/
function (_ConnectionHolder) {
  (0, _inherits2["default"])(EmptyConnectionHolder, _ConnectionHolder);

  function EmptyConnectionHolder() {
    (0, _classCallCheck2["default"])(this, EmptyConnectionHolder);
    return (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(EmptyConnectionHolder).apply(this, arguments));
  }

  (0, _createClass2["default"])(EmptyConnectionHolder, [{
    key: "initializeConnection",
    value: function initializeConnection() {
      // nothing to initialize
      return true;
    }
  }, {
    key: "getConnection",
    value: function getConnection() {
      return Promise.reject((0, _error.newError)('This connection holder does not serve connections'));
    }
  }, {
    key: "releaseConnection",
    value: function releaseConnection() {
      return Promise.resolve();
    }
  }, {
    key: "close",
    value: function close() {
      return Promise.resolve();
    }
  }]);
  return EmptyConnectionHolder;
}(ConnectionHolder); // eslint-disable-next-line handle-callback-err


function ignoreError(error) {}
/**
 * Connection holder that does not manage any connections.
 * @type {ConnectionHolder}
 */


var EMPTY_CONNECTION_HOLDER = new EmptyConnectionHolder();
exports.EMPTY_CONNECTION_HOLDER = EMPTY_CONNECTION_HOLDER;

},{"../error":231,"./bookmark":242,"./constants":264,"./util":288,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":19}],257:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _connectionProviderPooled = _interopRequireDefault(require("./connection-provider-pooled"));

var _connectionDelegate = _interopRequireDefault(require("./connection-delegate"));

var _connectionChannel = _interopRequireDefault(require("./connection-channel"));

var _constants = require("./constants");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var DirectConnectionProvider =
/*#__PURE__*/
function (_PooledConnectionProv) {
  (0, _inherits2["default"])(DirectConnectionProvider, _PooledConnectionProv);

  function DirectConnectionProvider(_ref) {
    var _this;

    var id = _ref.id,
        config = _ref.config,
        log = _ref.log,
        address = _ref.address,
        userAgent = _ref.userAgent,
        authToken = _ref.authToken;
    (0, _classCallCheck2["default"])(this, DirectConnectionProvider);
    _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(DirectConnectionProvider).call(this, {
      id: id,
      config: config,
      log: log,
      userAgent: userAgent,
      authToken: authToken
    }));
    _this._address = address;
    return _this;
  }
  /**
   * See {@link ConnectionProvider} for more information about this method and
   * its arguments.
   */


  (0, _createClass2["default"])(DirectConnectionProvider, [{
    key: "acquireConnection",
    value: function acquireConnection() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          accessMode = _ref2.accessMode,
          database = _ref2.database,
          bookmarks = _ref2.bookmarks;

      return this._connectionPool.acquire(this._address).then(function (connection) {
        return new _connectionDelegate["default"](connection, null);
      });
    }
  }, {
    key: "_hasProtocolVersion",
    value: function () {
      var _hasProtocolVersion2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee(versionPredicate) {
        var connection, protocol;
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                connection = _connectionChannel["default"].create(this._address, this._config, this._createConnectionErrorHandler(), this._log);
                _context.prev = 1;
                _context.next = 4;
                return connection._negotiateProtocol();

              case 4:
                protocol = connection.protocol();

                if (!protocol) {
                  _context.next = 7;
                  break;
                }

                return _context.abrupt("return", versionPredicate(protocol.version));

              case 7:
                return _context.abrupt("return", false);

              case 8:
                _context.prev = 8;
                _context.next = 11;
                return connection.close();

              case 11:
                return _context.finish(8);

              case 12:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[1,, 8, 12]]);
      }));

      function _hasProtocolVersion(_x) {
        return _hasProtocolVersion2.apply(this, arguments);
      }

      return _hasProtocolVersion;
    }()
  }, {
    key: "supportsMultiDb",
    value: function () {
      var _supportsMultiDb = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee2() {
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this._hasProtocolVersion(function (version) {
                  return version >= _constants.BOLT_PROTOCOL_V4_0;
                });

              case 2:
                return _context2.abrupt("return", _context2.sent);

              case 3:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function supportsMultiDb() {
        return _supportsMultiDb.apply(this, arguments);
      }

      return supportsMultiDb;
    }()
  }, {
    key: "supportsTransactionConfig",
    value: function () {
      var _supportsTransactionConfig = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee3() {
        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this._hasProtocolVersion(function (version) {
                  return version >= _constants.BOLT_PROTOCOL_V3;
                });

              case 2:
                return _context3.abrupt("return", _context3.sent);

              case 3:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function supportsTransactionConfig() {
        return _supportsTransactionConfig.apply(this, arguments);
      }

      return supportsTransactionConfig;
    }()
  }]);
  return DirectConnectionProvider;
}(_connectionProviderPooled["default"]);

exports["default"] = DirectConnectionProvider;

},{"./connection-channel":252,"./connection-delegate":253,"./connection-provider-pooled":258,"./constants":264,"@babel/runtime/helpers/asyncToGenerator":4,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":19,"@babel/runtime/regenerator":27}],258:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _connectionChannel = _interopRequireDefault(require("./connection-channel"));

var _pool = _interopRequireDefault(require("./pool"));

var _poolConfig = _interopRequireDefault(require("./pool-config"));

var _connectionErrorHandler = _interopRequireDefault(require("./connection-error-handler"));

var _error = require("../error");

var _connectionProvider = _interopRequireDefault(require("./connection-provider"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var PooledConnectionProvider =
/*#__PURE__*/
function (_ConnectionProvider) {
  (0, _inherits2["default"])(PooledConnectionProvider, _ConnectionProvider);

  function PooledConnectionProvider(_ref) {
    var _this;

    var id = _ref.id,
        config = _ref.config,
        log = _ref.log,
        userAgent = _ref.userAgent,
        authToken = _ref.authToken;
    var createChannelConnectionHook = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    (0, _classCallCheck2["default"])(this, PooledConnectionProvider);
    _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(PooledConnectionProvider).call(this));
    _this._id = id;
    _this._config = config;
    _this._log = log;
    _this._userAgent = userAgent;
    _this._authToken = authToken;

    _this._createChannelConnection = createChannelConnectionHook || function (address) {
      return _connectionChannel["default"].create(address, _this._config, _this._createConnectionErrorHandler(), _this._log);
    };

    _this._connectionPool = new _pool["default"]({
      create: _this._createConnection.bind((0, _assertThisInitialized2["default"])(_this)),
      destroy: _this._destroyConnection.bind((0, _assertThisInitialized2["default"])(_this)),
      validate: _this._validateConnection.bind((0, _assertThisInitialized2["default"])(_this)),
      installIdleObserver: PooledConnectionProvider._installIdleObserverOnConnection.bind((0, _assertThisInitialized2["default"])(_this)),
      removeIdleObserver: PooledConnectionProvider._removeIdleObserverOnConnection.bind((0, _assertThisInitialized2["default"])(_this)),
      config: _poolConfig["default"].fromDriverConfig(config),
      log: _this._log
    });
    _this._openConnections = {};
    return _this;
  }

  (0, _createClass2["default"])(PooledConnectionProvider, [{
    key: "_createConnectionErrorHandler",
    value: function _createConnectionErrorHandler() {
      return new _connectionErrorHandler["default"](_error.SERVICE_UNAVAILABLE);
    }
    /**
     * Create a new connection and initialize it.
     * @return {Promise<Connection>} promise resolved with a new connection or rejected when failed to connect.
     * @access private
     */

  }, {
    key: "_createConnection",
    value: function _createConnection(address, release) {
      var _this2 = this;

      var connection = this._createChannelConnection(address);

      connection._release = function () {
        return release(address, connection);
      };

      this._openConnections[connection.id] = connection;
      return connection.connect(this._userAgent, this._authToken)["catch"](function (error) {
        // let's destroy this connection
        _this2._destroyConnection(connection); // propagate the error because connection failed to connect / initialize


        throw error;
      });
    }
    /**
     * Check that a connection is usable
     * @return {boolean} true if the connection is open
     * @access private
     **/

  }, {
    key: "_validateConnection",
    value: function _validateConnection(conn) {
      if (!conn.isOpen()) {
        return false;
      }

      var maxConnectionLifetime = this._config.maxConnectionLifetime;
      var lifetime = Date.now() - conn.creationTimestamp;
      return lifetime <= maxConnectionLifetime;
    }
    /**
     * Dispose of a connection.
     * @return {Connection} the connection to dispose.
     * @access private
     */

  }, {
    key: "_destroyConnection",
    value: function _destroyConnection(conn) {
      delete this._openConnections[conn.id];
      return conn.close();
    }
  }, {
    key: "close",
    value: function () {
      var _close = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee() {
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this._connectionPool.close();

              case 2:
                _context.next = 4;
                return Promise.all(Object.values(this._openConnections).map(function (c) {
                  return c.close();
                }));

              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function close() {
        return _close.apply(this, arguments);
      }

      return close;
    }()
  }], [{
    key: "_installIdleObserverOnConnection",
    value: function _installIdleObserverOnConnection(conn, observer) {
      conn._queueObserver(observer);
    }
  }, {
    key: "_removeIdleObserverOnConnection",
    value: function _removeIdleObserverOnConnection(conn) {
      conn._updateCurrentObserver();
    }
  }]);
  return PooledConnectionProvider;
}(_connectionProvider["default"]);

exports["default"] = PooledConnectionProvider;

},{"../error":231,"./connection-channel":252,"./connection-error-handler":254,"./connection-provider":261,"./pool":271,"./pool-config":270,"@babel/runtime/helpers/assertThisInitialized":3,"@babel/runtime/helpers/asyncToGenerator":4,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":19,"@babel/runtime/regenerator":27}],259:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _error = require("../error");

var _driver = require("../driver");

var _session = _interopRequireDefault(require("../session"));

var _routingTable = _interopRequireDefault(require("./routing-table"));

var _rediscovery = _interopRequireDefault(require("./rediscovery"));

var _routingUtil = _interopRequireDefault(require("./routing-util"));

var _node = require('./browser');

var _connectionProviderSingle = _interopRequireDefault(require("./connection-provider-single"));

var _connectionProviderPooled = _interopRequireDefault(require("./connection-provider-pooled"));

var _connectionErrorHandler = _interopRequireDefault(require("./connection-error-handler"));

var _connectionDelegate = _interopRequireDefault(require("./connection-delegate"));

var _leastConnectedLoadBalancingStrategy = _interopRequireDefault(require("./least-connected-load-balancing-strategy"));

var _bookmark = _interopRequireDefault(require("./bookmark"));

var _connectionChannel = _interopRequireDefault(require("./connection-channel"));

var _integer = require("../integer");

var _constants = require("./constants");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var UNAUTHORIZED_ERROR_CODE = 'Neo.ClientError.Security.Unauthorized';
var DATABASE_NOT_FOUND_ERROR_CODE = 'Neo.ClientError.Database.DatabaseNotFound';
var SYSTEM_DB_NAME = 'system';
var DEFAULT_DB_NAME = '';
var DEFAULT_ROUTING_TABLE_PURGE_DELAY = (0, _integer["int"])(30000);

var RoutingConnectionProvider =
/*#__PURE__*/
function (_PooledConnectionProv) {
  (0, _inherits2["default"])(RoutingConnectionProvider, _PooledConnectionProv);

  function RoutingConnectionProvider(_ref) {
    var _this;

    var id = _ref.id,
        address = _ref.address,
        routingContext = _ref.routingContext,
        hostNameResolver = _ref.hostNameResolver,
        config = _ref.config,
        log = _ref.log,
        userAgent = _ref.userAgent,
        authToken = _ref.authToken,
        routingTablePurgeDelay = _ref.routingTablePurgeDelay;
    (0, _classCallCheck2["default"])(this, RoutingConnectionProvider);
    _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(RoutingConnectionProvider).call(this, {
      id: id,
      config: config,
      log: log,
      userAgent: userAgent,
      authToken: authToken
    }, function (address) {
      return _connectionChannel["default"].create(address, _this._config, _this._createConnectionErrorHandler(), _this._log, routingContext || {});
    }));
    _this._seedRouter = address;
    _this._routingTables = {};
    _this._rediscovery = new _rediscovery["default"](new _routingUtil["default"](routingContext, address.toString()));
    _this._loadBalancingStrategy = new _leastConnectedLoadBalancingStrategy["default"](_this._connectionPool);
    _this._hostNameResolver = hostNameResolver;
    _this._dnsResolver = new _node.HostNameResolver();
    _this._log = log;
    _this._useSeedRouter = true;
    _this._routingTablePurgeDelay = routingTablePurgeDelay ? (0, _integer["int"])(routingTablePurgeDelay) : DEFAULT_ROUTING_TABLE_PURGE_DELAY;
    return _this;
  }

  (0, _createClass2["default"])(RoutingConnectionProvider, [{
    key: "_createConnectionErrorHandler",
    value: function _createConnectionErrorHandler() {
      // connection errors mean SERVICE_UNAVAILABLE for direct driver but for routing driver they should only
      // result in SESSION_EXPIRED because there might still exist other servers capable of serving the request
      return new _connectionErrorHandler["default"](_error.SESSION_EXPIRED);
    }
  }, {
    key: "_handleUnavailability",
    value: function _handleUnavailability(error, address, database) {
      this._log.warn("Routing driver ".concat(this._id, " will forget ").concat(address, " for database '").concat(database, "' because of an error ").concat(error.code, " '").concat(error.message, "'"));

      this.forget(address, database || '');
      return error;
    }
  }, {
    key: "_handleWriteFailure",
    value: function _handleWriteFailure(error, address, database) {
      this._log.warn("Routing driver ".concat(this._id, " will forget writer ").concat(address, " for database '").concat(database, "' because of an error ").concat(error.code, " '").concat(error.message, "'"));

      this.forgetWriter(address, database || '');
      return (0, _error.newError)('No longer possible to write to server at ' + address, _error.SESSION_EXPIRED);
    }
    /**
     * See {@link ConnectionProvider} for more information about this method and
     * its arguments.
     */

  }, {
    key: "acquireConnection",
    value: function () {
      var _acquireConnection = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee() {
        var _this2 = this;

        var _ref2,
            accessMode,
            database,
            bookmark,
            name,
            address,
            databaseSpecificErrorHandler,
            routingTable,
            connection,
            transformed,
            _args = arguments;

        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _ref2 = _args.length > 0 && _args[0] !== undefined ? _args[0] : {}, accessMode = _ref2.accessMode, database = _ref2.database, bookmark = _ref2.bookmark;
                databaseSpecificErrorHandler = new _connectionErrorHandler["default"](_error.SESSION_EXPIRED, function (error, address) {
                  return _this2._handleUnavailability(error, address, database);
                }, function (error, address) {
                  return _this2._handleWriteFailure(error, address, database);
                });
                _context.next = 4;
                return this._freshRoutingTable({
                  accessMode: accessMode,
                  database: database || DEFAULT_DB_NAME,
                  bookmark: bookmark
                });

              case 4:
                routingTable = _context.sent;

                if (!(accessMode === _driver.READ)) {
                  _context.next = 10;
                  break;
                }

                address = this._loadBalancingStrategy.selectReader(routingTable.readers);
                name = 'read';
                _context.next = 16;
                break;

              case 10:
                if (!(accessMode === _driver.WRITE)) {
                  _context.next = 15;
                  break;
                }

                address = this._loadBalancingStrategy.selectWriter(routingTable.writers);
                name = 'write';
                _context.next = 16;
                break;

              case 15:
                throw (0, _error.newError)('Illegal mode ' + accessMode);

              case 16:
                if (address) {
                  _context.next = 18;
                  break;
                }

                throw (0, _error.newError)("Failed to obtain connection towards ".concat(name, " server. Known routing table is: ").concat(routingTable), _error.SESSION_EXPIRED);

              case 18:
                _context.prev = 18;
                _context.next = 21;
                return this._acquireConnectionToServer(address, name, routingTable);

              case 21:
                connection = _context.sent;
                return _context.abrupt("return", new _connectionDelegate["default"](connection, databaseSpecificErrorHandler));

              case 25:
                _context.prev = 25;
                _context.t0 = _context["catch"](18);
                transformed = databaseSpecificErrorHandler.handleAndTransformError(_context.t0, address);
                throw transformed;

              case 29:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[18, 25]]);
      }));

      function acquireConnection() {
        return _acquireConnection.apply(this, arguments);
      }

      return acquireConnection;
    }()
  }, {
    key: "_hasProtocolVersion",
    value: function () {
      var _hasProtocolVersion2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee2(versionPredicate) {
        var addresses, lastError, i, connection, protocol;
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this._resolveSeedRouter(this._seedRouter);

              case 2:
                addresses = _context2.sent;
                i = 0;

              case 4:
                if (!(i < addresses.length)) {
                  _context2.next = 25;
                  break;
                }

                connection = _connectionChannel["default"].create(addresses[i], this._config, this._createConnectionErrorHandler(), this._log);
                _context2.prev = 6;
                _context2.next = 9;
                return connection._negotiateProtocol();

              case 9:
                protocol = connection.protocol();

                if (!protocol) {
                  _context2.next = 12;
                  break;
                }

                return _context2.abrupt("return", versionPredicate(protocol.version));

              case 12:
                return _context2.abrupt("return", false);

              case 15:
                _context2.prev = 15;
                _context2.t0 = _context2["catch"](6);
                lastError = _context2.t0;

              case 18:
                _context2.prev = 18;
                _context2.next = 21;
                return connection.close();

              case 21:
                return _context2.finish(18);

              case 22:
                i++;
                _context2.next = 4;
                break;

              case 25:
                if (!lastError) {
                  _context2.next = 27;
                  break;
                }

                throw lastError;

              case 27:
                return _context2.abrupt("return", false);

              case 28:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[6, 15, 18, 22]]);
      }));

      function _hasProtocolVersion(_x) {
        return _hasProtocolVersion2.apply(this, arguments);
      }

      return _hasProtocolVersion;
    }()
  }, {
    key: "supportsMultiDb",
    value: function () {
      var _supportsMultiDb = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee3() {
        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this._hasProtocolVersion(function (version) {
                  return version >= _constants.BOLT_PROTOCOL_V4_0;
                });

              case 2:
                return _context3.abrupt("return", _context3.sent);

              case 3:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function supportsMultiDb() {
        return _supportsMultiDb.apply(this, arguments);
      }

      return supportsMultiDb;
    }()
  }, {
    key: "supportsTransactionConfig",
    value: function () {
      var _supportsTransactionConfig = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee4() {
        return _regenerator["default"].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this._hasProtocolVersion(function (version) {
                  return version >= _constants.BOLT_PROTOCOL_V3;
                });

              case 2:
                return _context4.abrupt("return", _context4.sent);

              case 3:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function supportsTransactionConfig() {
        return _supportsTransactionConfig.apply(this, arguments);
      }

      return supportsTransactionConfig;
    }()
  }, {
    key: "forget",
    value: function forget(address, database) {
      if (database || database === '') {
        this._routingTables[database].forget(address);
      } else {
        Object.values(this._routingTables).forEach(function (routingTable) {
          return routingTable.forget(address);
        });
      } // We're firing and forgetting this operation explicitly and listening for any
      // errors to avoid unhandled promise rejection


      this._connectionPool.purge(address)["catch"](function () {});
    }
  }, {
    key: "forgetWriter",
    value: function forgetWriter(address, database) {
      if (database || database === '') {
        this._routingTables[database].forgetWriter(address);
      } else {
        Object.values(this._routingTables).forEach(function (routingTable) {
          return routingTable.forgetWriter(address);
        });
      }
    }
  }, {
    key: "_acquireConnectionToServer",
    value: function _acquireConnectionToServer(address, serverName, routingTable) {
      return this._connectionPool.acquire(address);
    }
  }, {
    key: "_freshRoutingTable",
    value: function _freshRoutingTable() {
      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          accessMode = _ref3.accessMode,
          database = _ref3.database,
          bookmark = _ref3.bookmark;

      var currentRoutingTable = this._routingTables[database] || new _routingTable["default"]({
        database: database
      });

      if (!currentRoutingTable.isStaleFor(accessMode)) {
        return currentRoutingTable;
      }

      this._log.info("Routing table is stale for database: \"".concat(database, "\" and access mode: \"").concat(accessMode, "\": ").concat(currentRoutingTable));

      return this._refreshRoutingTable(currentRoutingTable, bookmark);
    }
  }, {
    key: "_refreshRoutingTable",
    value: function _refreshRoutingTable(currentRoutingTable, bookmark) {
      var knownRouters = currentRoutingTable.routers;

      if (this._useSeedRouter) {
        return this._fetchRoutingTableFromSeedRouterFallbackToKnownRouters(knownRouters, currentRoutingTable, bookmark);
      }

      return this._fetchRoutingTableFromKnownRoutersFallbackToSeedRouter(knownRouters, currentRoutingTable, bookmark);
    }
  }, {
    key: "_fetchRoutingTableFromSeedRouterFallbackToKnownRouters",
    value: function () {
      var _fetchRoutingTableFromSeedRouterFallbackToKnownRouters2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee5(knownRouters, currentRoutingTable, bookmark) {
        var seenRouters, newRoutingTable;
        return _regenerator["default"].wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                // we start with seed router, no routers were probed before
                seenRouters = [];
                _context5.next = 3;
                return this._fetchRoutingTableUsingSeedRouter(seenRouters, this._seedRouter, currentRoutingTable, bookmark);

              case 3:
                newRoutingTable = _context5.sent;

                if (!newRoutingTable) {
                  _context5.next = 8;
                  break;
                }

                this._useSeedRouter = false;
                _context5.next = 11;
                break;

              case 8:
                _context5.next = 10;
                return this._fetchRoutingTableUsingKnownRouters(knownRouters, currentRoutingTable, bookmark);

              case 10:
                newRoutingTable = _context5.sent;

              case 11:
                _context5.next = 13;
                return this._applyRoutingTableIfPossible(currentRoutingTable, newRoutingTable);

              case 13:
                return _context5.abrupt("return", _context5.sent);

              case 14:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function _fetchRoutingTableFromSeedRouterFallbackToKnownRouters(_x2, _x3, _x4) {
        return _fetchRoutingTableFromSeedRouterFallbackToKnownRouters2.apply(this, arguments);
      }

      return _fetchRoutingTableFromSeedRouterFallbackToKnownRouters;
    }()
  }, {
    key: "_fetchRoutingTableFromKnownRoutersFallbackToSeedRouter",
    value: function () {
      var _fetchRoutingTableFromKnownRoutersFallbackToSeedRouter2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee6(knownRouters, currentRoutingTable, bookmark) {
        var newRoutingTable;
        return _regenerator["default"].wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return this._fetchRoutingTableUsingKnownRouters(knownRouters, currentRoutingTable, bookmark);

              case 2:
                newRoutingTable = _context6.sent;

                if (newRoutingTable) {
                  _context6.next = 7;
                  break;
                }

                _context6.next = 6;
                return this._fetchRoutingTableUsingSeedRouter(knownRouters, this._seedRouter, currentRoutingTable, bookmark);

              case 6:
                newRoutingTable = _context6.sent;

              case 7:
                _context6.next = 9;
                return this._applyRoutingTableIfPossible(currentRoutingTable, newRoutingTable);

              case 9:
                return _context6.abrupt("return", _context6.sent);

              case 10:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function _fetchRoutingTableFromKnownRoutersFallbackToSeedRouter(_x5, _x6, _x7) {
        return _fetchRoutingTableFromKnownRoutersFallbackToSeedRouter2.apply(this, arguments);
      }

      return _fetchRoutingTableFromKnownRoutersFallbackToSeedRouter;
    }()
  }, {
    key: "_fetchRoutingTableUsingKnownRouters",
    value: function () {
      var _fetchRoutingTableUsingKnownRouters2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee7(knownRouters, currentRoutingTable, bookmark) {
        var newRoutingTable, lastRouterIndex;
        return _regenerator["default"].wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return this._fetchRoutingTable(knownRouters, currentRoutingTable, bookmark);

              case 2:
                newRoutingTable = _context7.sent;

                if (!newRoutingTable) {
                  _context7.next = 5;
                  break;
                }

                return _context7.abrupt("return", newRoutingTable);

              case 5:
                // returned routing table was undefined, this means a connection error happened and the last known
                // router did not return a valid routing table, so we need to forget it
                lastRouterIndex = knownRouters.length - 1;

                RoutingConnectionProvider._forgetRouter(currentRoutingTable, knownRouters, lastRouterIndex);

                return _context7.abrupt("return", null);

              case 8:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function _fetchRoutingTableUsingKnownRouters(_x8, _x9, _x10) {
        return _fetchRoutingTableUsingKnownRouters2.apply(this, arguments);
      }

      return _fetchRoutingTableUsingKnownRouters;
    }()
  }, {
    key: "_fetchRoutingTableUsingSeedRouter",
    value: function () {
      var _fetchRoutingTableUsingSeedRouter2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee8(seenRouters, seedRouter, routingTable, bookmark) {
        var resolvedAddresses, newAddresses;
        return _regenerator["default"].wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return this._resolveSeedRouter(seedRouter);

              case 2:
                resolvedAddresses = _context8.sent;
                // filter out all addresses that we've already tried
                newAddresses = resolvedAddresses.filter(function (address) {
                  return seenRouters.indexOf(address) < 0;
                });
                _context8.next = 6;
                return this._fetchRoutingTable(newAddresses, routingTable, bookmark);

              case 6:
                return _context8.abrupt("return", _context8.sent);

              case 7:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function _fetchRoutingTableUsingSeedRouter(_x11, _x12, _x13, _x14) {
        return _fetchRoutingTableUsingSeedRouter2.apply(this, arguments);
      }

      return _fetchRoutingTableUsingSeedRouter;
    }()
  }, {
    key: "_resolveSeedRouter",
    value: function () {
      var _resolveSeedRouter2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee9(seedRouter) {
        var _this3 = this;

        var resolvedAddresses, dnsResolvedAddresses;
        return _regenerator["default"].wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return this._hostNameResolver.resolve(seedRouter);

              case 2:
                resolvedAddresses = _context9.sent;
                _context9.next = 5;
                return Promise.all(resolvedAddresses.map(function (address) {
                  return _this3._dnsResolver.resolve(address);
                }));

              case 5:
                dnsResolvedAddresses = _context9.sent;
                return _context9.abrupt("return", [].concat.apply([], dnsResolvedAddresses));

              case 7:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function _resolveSeedRouter(_x15) {
        return _resolveSeedRouter2.apply(this, arguments);
      }

      return _resolveSeedRouter;
    }()
  }, {
    key: "_fetchRoutingTable",
    value: function _fetchRoutingTable(routerAddresses, routingTable, bookmark) {
      var _this4 = this;

      return routerAddresses.reduce(
      /*#__PURE__*/
      function () {
        var _ref4 = (0, _asyncToGenerator2["default"])(
        /*#__PURE__*/
        _regenerator["default"].mark(function _callee10(refreshedTablePromise, currentRouter, currentIndex) {
          var newRoutingTable, previousRouterIndex, session;
          return _regenerator["default"].wrap(function _callee10$(_context10) {
            while (1) {
              switch (_context10.prev = _context10.next) {
                case 0:
                  _context10.next = 2;
                  return refreshedTablePromise;

                case 2:
                  newRoutingTable = _context10.sent;

                  if (!newRoutingTable) {
                    _context10.next = 7;
                    break;
                  }

                  return _context10.abrupt("return", newRoutingTable);

                case 7:
                  // returned routing table was undefined, this means a connection error happened and we need to forget the
                  // previous router and try the next one
                  previousRouterIndex = currentIndex - 1;

                  RoutingConnectionProvider._forgetRouter(routingTable, routerAddresses, previousRouterIndex);

                case 9:
                  _context10.next = 11;
                  return _this4._createSessionForRediscovery(currentRouter, bookmark);

                case 11:
                  session = _context10.sent;

                  if (!session) {
                    _context10.next = 27;
                    break;
                  }

                  _context10.prev = 13;
                  _context10.next = 16;
                  return _this4._rediscovery.lookupRoutingTableOnRouter(session, routingTable.database, currentRouter);

                case 16:
                  return _context10.abrupt("return", _context10.sent);

                case 19:
                  _context10.prev = 19;
                  _context10.t0 = _context10["catch"](13);

                  if (!(_context10.t0 && _context10.t0.code === DATABASE_NOT_FOUND_ERROR_CODE)) {
                    _context10.next = 23;
                    break;
                  }

                  throw _context10.t0;

                case 23:
                  _this4._log.warn("unable to fetch routing table because of an error ".concat(_context10.t0));

                  return _context10.abrupt("return", null);

                case 25:
                  _context10.next = 28;
                  break;

                case 27:
                  return _context10.abrupt("return", null);

                case 28:
                case "end":
                  return _context10.stop();
              }
            }
          }, _callee10, null, [[13, 19]]);
        }));

        return function (_x16, _x17, _x18) {
          return _ref4.apply(this, arguments);
        };
      }(), Promise.resolve(null));
    }
  }, {
    key: "_createSessionForRediscovery",
    value: function () {
      var _createSessionForRediscovery2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee11(routerAddress, bookmark) {
        var connection, connectionProvider, protocolVersion;
        return _regenerator["default"].wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                _context11.prev = 0;
                _context11.next = 3;
                return this._connectionPool.acquire(routerAddress);

              case 3:
                connection = _context11.sent;
                connectionProvider = new _connectionProviderSingle["default"](connection);
                protocolVersion = connection.protocol().version;

                if (!(protocolVersion < 4.0)) {
                  _context11.next = 8;
                  break;
                }

                return _context11.abrupt("return", new _session["default"]({
                  mode: _driver.WRITE,
                  bookmark: _bookmark["default"].empty(),
                  connectionProvider: connectionProvider
                }));

              case 8:
                return _context11.abrupt("return", new _session["default"]({
                  mode: _driver.READ,
                  database: SYSTEM_DB_NAME,
                  bookmark: bookmark,
                  connectionProvider: connectionProvider
                }));

              case 11:
                _context11.prev = 11;
                _context11.t0 = _context11["catch"](0);

                if (!(_context11.t0 && _context11.t0.code === UNAUTHORIZED_ERROR_CODE)) {
                  _context11.next = 15;
                  break;
                }

                throw _context11.t0;

              case 15:
                return _context11.abrupt("return", null);

              case 16:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this, [[0, 11]]);
      }));

      function _createSessionForRediscovery(_x19, _x20) {
        return _createSessionForRediscovery2.apply(this, arguments);
      }

      return _createSessionForRediscovery;
    }()
  }, {
    key: "_applyRoutingTableIfPossible",
    value: function () {
      var _applyRoutingTableIfPossible2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee12(currentRoutingTable, newRoutingTable) {
        return _regenerator["default"].wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                if (newRoutingTable) {
                  _context12.next = 2;
                  break;
                }

                throw (0, _error.newError)("Could not perform discovery. No routing servers available. Known routing table: ".concat(currentRoutingTable), _error.SERVICE_UNAVAILABLE);

              case 2:
                if (newRoutingTable.writers.length === 0) {
                  // use seed router next time. this is important when cluster is partitioned. it tries to make sure driver
                  // does not always get routing table without writers because it talks exclusively to a minority partition
                  this._useSeedRouter = true;
                }

                _context12.next = 5;
                return this._updateRoutingTable(newRoutingTable);

              case 5:
                return _context12.abrupt("return", newRoutingTable);

              case 6:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function _applyRoutingTableIfPossible(_x21, _x22) {
        return _applyRoutingTableIfPossible2.apply(this, arguments);
      }

      return _applyRoutingTableIfPossible;
    }()
  }, {
    key: "_updateRoutingTable",
    value: function () {
      var _updateRoutingTable2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee13(newRoutingTable) {
        var _this5 = this;

        return _regenerator["default"].wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                _context13.next = 2;
                return this._connectionPool.keepAll(newRoutingTable.allServers());

              case 2:
                // filter out expired to purge (expired for a pre-configured amount of time) routing table entries
                Object.values(this._routingTables).forEach(function (value) {
                  if (value.isExpiredFor(_this5._routingTablePurgeDelay)) {
                    delete _this5._routingTables[value.database];
                  }
                }); // make this driver instance aware of the new table

                this._routingTables[newRoutingTable.database] = newRoutingTable;

                this._log.info("Updated routing table ".concat(newRoutingTable));

              case 5:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function _updateRoutingTable(_x23) {
        return _updateRoutingTable2.apply(this, arguments);
      }

      return _updateRoutingTable;
    }()
  }], [{
    key: "_forgetRouter",
    value: function _forgetRouter(routingTable, routersArray, routerIndex) {
      var address = routersArray[routerIndex];

      if (routingTable && address) {
        routingTable.forgetRouter(address);
      }
    }
  }]);
  return RoutingConnectionProvider;
}(_connectionProviderPooled["default"]);

exports["default"] = RoutingConnectionProvider;

},{"../driver":230,"../error":231,"../integer":234,"../session":295,"./bookmark":242,"./browser":247,"./connection-channel":252,"./connection-delegate":253,"./connection-error-handler":254,"./connection-provider-pooled":258,"./connection-provider-single":260,"./constants":264,"./least-connected-load-balancing-strategy":265,"./rediscovery":273,"./routing-table":279,"./routing-util":280,"@babel/runtime/helpers/asyncToGenerator":4,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":19,"@babel/runtime/regenerator":27}],260:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _connectionProvider = _interopRequireDefault(require("./connection-provider"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var SingleConnectionProvider =
/*#__PURE__*/
function (_ConnectionProvider) {
  (0, _inherits2["default"])(SingleConnectionProvider, _ConnectionProvider);

  function SingleConnectionProvider(connection) {
    var _this;

    (0, _classCallCheck2["default"])(this, SingleConnectionProvider);
    _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(SingleConnectionProvider).call(this));
    _this._connection = connection;
    return _this;
  }
  /**
   * See {@link ConnectionProvider} for more information about this method and
   * its arguments.
   */


  (0, _createClass2["default"])(SingleConnectionProvider, [{
    key: "acquireConnection",
    value: function acquireConnection() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          accessMode = _ref.accessMode,
          database = _ref.database,
          bookmarks = _ref.bookmarks;

      var connection = this._connection;
      this._connection = null;
      return Promise.resolve(connection);
    }
  }]);
  return SingleConnectionProvider;
}(_connectionProvider["default"]);

exports["default"] = SingleConnectionProvider;

},{"./connection-provider":261,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":19}],261:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _bookmark = _interopRequireDefault(require("./bookmark"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var ConnectionProvider =
/*#__PURE__*/
function () {
  function ConnectionProvider() {
    (0, _classCallCheck2["default"])(this, ConnectionProvider);
  }

  (0, _createClass2["default"])(ConnectionProvider, [{
    key: "acquireConnection",

    /**
     * This method acquires a connection against the specified database.
     *
     * Access mode and Bookmarks only applies to routing driver. Access mode only
     * differentiates the target server for the connection, where WRITE selects a
     * WRITER server, whereas READ selects a READ server. Bookmarks, when specified,
     * is only passed to the routing discovery procedure, for the system database to
     * synchronize on creation of databases and is never used in direct drivers.
     *
     * @param {object} param - object parameter
     * @param {string} param.accessMode - the access mode for the to-be-acquired connection
     * @param {string} param.database - the target database for the to-be-acquired connection
     * @param {Bookmark} param.bookmarks - the bookmarks to send to routing discovery
     */
    value: function acquireConnection() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          accessMode = _ref.accessMode,
          database = _ref.database,
          bookmarks = _ref.bookmarks;

      throw new Error('not implemented');
    }
    /**
     * This method checks whether the backend database supports multi database functionality
     * by checking protocol handshake result.
     *
     * @returns {Promise<boolean>}
     */

  }, {
    key: "supportsMultiDb",
    value: function supportsMultiDb() {
      throw new Error('not implemented');
    }
    /**
     * This method checks whether the backend database supports transaction config functionality
     * by checking protocol handshake result.
     *
     * @returns {Promise<boolean>}
     */

  }, {
    key: "supportsTransactionConfig",
    value: function supportsTransactionConfig() {
      throw new Error('not implemented');
    }
    /**
     * Closes this connection provider along with its internals (connections, pools, etc.)
     *
     * @returns {Promise<void>}
     */

  }, {
    key: "close",
    value: function close() {
      throw new Error('not implemented');
    }
  }]);
  return ConnectionProvider;
}();

exports["default"] = ConnectionProvider;

},{"./bookmark":242,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":12}],262:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _streamObservers = require("./stream-observers");

var _boltProtocolV = _interopRequireDefault(require("./bolt-protocol-v1"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Connection =
/*#__PURE__*/
function () {
  /**
   * @param {ConnectionErrorHandler} errorHandler the error handler
   */
  function Connection(errorHandler) {
    (0, _classCallCheck2["default"])(this, Connection);
    this._errorHandler = errorHandler;
  }

  (0, _createClass2["default"])(Connection, [{
    key: "isOpen",

    /**
     * @returns {boolean} whether this connection is in a working condition
     */
    value: function isOpen() {
      throw new Error('not implemented');
    }
    /**
     * @returns {BoltProtocol} the underlying bolt protocol assigned to this connection
     */

  }, {
    key: "protocol",
    value: function protocol() {
      throw new Error('not implemented');
    }
    /**
     * @returns {ServerAddress} the server address this connection is opened against
     */

  }, {
    key: "connect",

    /**
     * Connect to the target address, negotiate Bolt protocol and send initialization message.
     * @param {string} userAgent the user agent for this driver.
     * @param {Object} authToken the object containing auth information.
     * @return {Promise<Connection>} promise resolved with the current connection if connection is successful. Rejected promise otherwise.
     */
    value: function connect(userAgent, authToken) {
      throw new Error('not implemented');
    }
    /**
     * Write a message to the network channel.
     * @param {RequestMessage} message the message to write.
     * @param {ResultStreamObserver} observer the response observer.
     * @param {boolean} flush `true` if flush should happen after the message is written to the buffer.
     */

  }, {
    key: "write",
    value: function write(message, observer, flush) {
      throw new Error('not implemented');
    }
    /**
     * Send a RESET-message to the database. Message is immediately flushed to the network.
     * @return {Promise<void>} promise resolved when SUCCESS-message response arrives, or failed when other response messages arrives.
     */

  }, {
    key: "resetAndFlush",
    value: function resetAndFlush() {
      throw new Error('not implemented');
    }
    /**
     * Call close on the channel.
     * @returns {Promise<void>} - A promise that will be resolved when the connection is closed.
     *
     */

  }, {
    key: "close",
    value: function close() {
      throw new Error('not implemented');
    }
    /**
     *
     * @param error
     * @param address
     * @returns {Neo4jError|*}
     */

  }, {
    key: "handleAndTransformError",
    value: function handleAndTransformError(error, address) {
      if (this._errorHandler) {
        return this._errorHandler.handleAndTransformError(error, address);
      }

      return error;
    }
  }, {
    key: "id",
    get: function get() {
      throw new Error('not implemented');
    }
  }, {
    key: "databaseId",
    get: function get() {
      throw new Error('not implemented');
    },
    set: function set(value) {
      throw new Error('not implemented');
    }
  }, {
    key: "address",
    get: function get() {
      throw new Error('not implemented');
    }
    /**
     * @returns {ServerVersion} the version of the server this connection is connected to
     */

  }, {
    key: "version",
    get: function get() {
      throw new Error('not implemented');
    },
    set: function set(value) {
      throw new Error('not implemented');
    }
  }, {
    key: "server",
    get: function get() {
      throw new Error('not implemented');
    }
  }]);
  return Connection;
}();

exports["default"] = Connection;

},{"./bolt-protocol-v1":236,"./stream-observers":283,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":12}],263:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _connectionHolder = _interopRequireDefault(require("./connection-holder"));

var _driver = require("../driver");

var _streamObservers = require("./stream-observers");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Verifies connectivity using the given connection provider.
 */
var ConnectivityVerifier =
/*#__PURE__*/
function () {
  /**
   * @constructor
   * @param {ConnectionProvider} connectionProvider the provider to obtain connections from.
   */
  function ConnectivityVerifier(connectionProvider) {
    (0, _classCallCheck2["default"])(this, ConnectivityVerifier);
    this._connectionProvider = connectionProvider;
  }
  /**
   * Try to obtain a working connection from the connection provider.
   * @returns {Promise<object>} promise resolved with server info or rejected with error.
   */


  (0, _createClass2["default"])(ConnectivityVerifier, [{
    key: "verify",
    value: function verify() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$database = _ref.database,
          database = _ref$database === void 0 ? '' : _ref$database;

      return acquireAndReleaseDummyConnection(this._connectionProvider, database);
    }
  }]);
  return ConnectivityVerifier;
}();
/**
 * @private
 * @param {ConnectionProvider} connectionProvider the provider to obtain connections from.
 * @return {Promise<object>} promise resolved with server info or rejected with error.
 */


exports["default"] = ConnectivityVerifier;

function acquireAndReleaseDummyConnection(connectionProvider, database) {
  var connectionHolder = new _connectionHolder["default"]({
    mode: _driver.READ,
    database: database,
    connectionProvider: connectionProvider
  });
  connectionHolder.initializeConnection();
  return connectionHolder.getConnection().then(function (connection) {
    // able to establish a connection
    return connectionHolder.close().then(function () {
      return connection.server;
    });
  })["catch"](function (error) {
    // failed to establish a connection
    return connectionHolder.close()["catch"](function (ignoredError) {// ignore connection release error
    }).then(function () {
      return Promise.reject(error);
    });
  });
}

},{"../driver":230,"./connection-holder":256,"./stream-observers":283,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":12}],264:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BOLT_PROTOCOL_V4_2 = exports.BOLT_PROTOCOL_V4_1 = exports.BOLT_PROTOCOL_V4_0 = exports.BOLT_PROTOCOL_V3 = exports.BOLT_PROTOCOL_V2 = exports.BOLT_PROTOCOL_V1 = exports.ACCESS_MODE_WRITE = exports.ACCESS_MODE_READ = void 0;

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var ACCESS_MODE_READ = 'READ';
exports.ACCESS_MODE_READ = ACCESS_MODE_READ;
var ACCESS_MODE_WRITE = 'WRITE';
exports.ACCESS_MODE_WRITE = ACCESS_MODE_WRITE;
var BOLT_PROTOCOL_V1 = 1;
exports.BOLT_PROTOCOL_V1 = BOLT_PROTOCOL_V1;
var BOLT_PROTOCOL_V2 = 2;
exports.BOLT_PROTOCOL_V2 = BOLT_PROTOCOL_V2;
var BOLT_PROTOCOL_V3 = 3;
exports.BOLT_PROTOCOL_V3 = BOLT_PROTOCOL_V3;
var BOLT_PROTOCOL_V4_0 = 4.0;
exports.BOLT_PROTOCOL_V4_0 = BOLT_PROTOCOL_V4_0;
var BOLT_PROTOCOL_V4_1 = 4.1;
exports.BOLT_PROTOCOL_V4_1 = BOLT_PROTOCOL_V4_1;
var BOLT_PROTOCOL_V4_2 = 4.2;
exports.BOLT_PROTOCOL_V4_2 = BOLT_PROTOCOL_V4_2;

},{}],265:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _roundRobinArrayIndex = _interopRequireDefault(require("./round-robin-array-index"));

var _loadBalancingStrategy = _interopRequireDefault(require("./load-balancing-strategy"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var LeastConnectedLoadBalancingStrategy =
/*#__PURE__*/
function (_LoadBalancingStrateg) {
  (0, _inherits2["default"])(LeastConnectedLoadBalancingStrategy, _LoadBalancingStrateg);

  /**
   * @constructor
   * @param {Pool} connectionPool the connection pool of this driver.
   */
  function LeastConnectedLoadBalancingStrategy(connectionPool) {
    var _this;

    (0, _classCallCheck2["default"])(this, LeastConnectedLoadBalancingStrategy);
    _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(LeastConnectedLoadBalancingStrategy).call(this));
    _this._readersIndex = new _roundRobinArrayIndex["default"]();
    _this._writersIndex = new _roundRobinArrayIndex["default"]();
    _this._connectionPool = connectionPool;
    return _this;
  }
  /**
   * @inheritDoc
   */


  (0, _createClass2["default"])(LeastConnectedLoadBalancingStrategy, [{
    key: "selectReader",
    value: function selectReader(knownReaders) {
      return this._select(knownReaders, this._readersIndex);
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "selectWriter",
    value: function selectWriter(knownWriters) {
      return this._select(knownWriters, this._writersIndex);
    }
  }, {
    key: "_select",
    value: function _select(addresses, roundRobinIndex) {
      var length = addresses.length;

      if (length === 0) {
        return null;
      } // choose start index for iteration in round-robin fashion


      var startIndex = roundRobinIndex.next(length);
      var index = startIndex;
      var leastConnectedAddress = null;
      var leastActiveConnections = Number.MAX_SAFE_INTEGER; // iterate over the array to find least connected address

      do {
        var address = addresses[index];

        var activeConnections = this._connectionPool.activeResourceCount(address);

        if (activeConnections < leastActiveConnections) {
          leastConnectedAddress = address;
          leastActiveConnections = activeConnections;
        } // loop over to the start of the array when end is reached


        if (index === length - 1) {
          index = 0;
        } else {
          index++;
        }
      } while (index !== startIndex);

      return leastConnectedAddress;
    }
  }]);
  return LeastConnectedLoadBalancingStrategy;
}(_loadBalancingStrategy["default"]);

exports["default"] = LeastConnectedLoadBalancingStrategy;

},{"./load-balancing-strategy":266,"./round-robin-array-index":278,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":19}],266:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * A facility to select most appropriate reader or writer among the given addresses for request processing.
 */
var LoadBalancingStrategy =
/*#__PURE__*/
function () {
  function LoadBalancingStrategy() {
    (0, _classCallCheck2["default"])(this, LoadBalancingStrategy);
  }

  (0, _createClass2["default"])(LoadBalancingStrategy, [{
    key: "selectReader",

    /**
     * Select next most appropriate reader from the list of given readers.
     * @param {string[]} knownReaders an array of currently known readers to select from.
     * @return {string} most appropriate reader or `null` if given array is empty.
     */
    value: function selectReader(knownReaders) {
      throw new Error('Abstract function');
    }
    /**
     * Select next most appropriate writer from the list of given writers.
     * @param {string[]} knownWriters an array of currently known writers to select from.
     * @return {string} most appropriate writer or `null` if given array is empty.
     */

  }, {
    key: "selectWriter",
    value: function selectWriter(knownWriters) {
      throw new Error('Abstract function');
    }
  }]);
  return LoadBalancingStrategy;
}();

exports["default"] = LoadBalancingStrategy;

},{"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":12}],267:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _error = require("../error");

var _levels;

var ERROR = 'error';
var WARN = 'warn';
var INFO = 'info';
var DEBUG = 'debug';
var DEFAULT_LEVEL = INFO;
var levels = (_levels = {}, (0, _defineProperty2["default"])(_levels, ERROR, 0), (0, _defineProperty2["default"])(_levels, WARN, 1), (0, _defineProperty2["default"])(_levels, INFO, 2), (0, _defineProperty2["default"])(_levels, DEBUG, 3), _levels);
/**
 * Logger used by the driver to notify about various internal events. Single logger should be used per driver.
 */

var Logger =
/*#__PURE__*/
function () {
  /**
   * @constructor
   * @param {string} level the enabled logging level.
   * @param {function(level: string, message: string)} loggerFunction the function to write the log level and message.
   */
  function Logger(level, loggerFunction) {
    (0, _classCallCheck2["default"])(this, Logger);
    this._level = level;
    this._loggerFunction = loggerFunction;
  }
  /**
   * Create a new logger based on the given driver configuration.
   * @param {Object} driverConfig the driver configuration as supplied by the user.
   * @return {Logger} a new logger instance or a no-op logger when not configured.
   */


  (0, _createClass2["default"])(Logger, [{
    key: "isErrorEnabled",

    /**
     * Check if error logging is enabled, i.e. it is not a no-op implementation.
     * @return {boolean} `true` when enabled, `false` otherwise.
     */
    value: function isErrorEnabled() {
      return isLevelEnabled(this._level, ERROR);
    }
    /**
     * Log an error message.
     * @param {string} message the message to log.
     */

  }, {
    key: "error",
    value: function error(message) {
      if (this.isErrorEnabled()) {
        this._loggerFunction(ERROR, message);
      }
    }
    /**
     * Check if warn logging is enabled, i.e. it is not a no-op implementation.
     * @return {boolean} `true` when enabled, `false` otherwise.
     */

  }, {
    key: "isWarnEnabled",
    value: function isWarnEnabled() {
      return isLevelEnabled(this._level, WARN);
    }
    /**
     * Log an warning message.
     * @param {string} message the message to log.
     */

  }, {
    key: "warn",
    value: function warn(message) {
      if (this.isWarnEnabled()) {
        this._loggerFunction(WARN, message);
      }
    }
    /**
     * Check if info logging is enabled, i.e. it is not a no-op implementation.
     * @return {boolean} `true` when enabled, `false` otherwise.
     */

  }, {
    key: "isInfoEnabled",
    value: function isInfoEnabled() {
      return isLevelEnabled(this._level, INFO);
    }
    /**
     * Log an info message.
     * @param {string} message the message to log.
     */

  }, {
    key: "info",
    value: function info(message) {
      if (this.isInfoEnabled()) {
        this._loggerFunction(INFO, message);
      }
    }
    /**
     * Check if debug logging is enabled, i.e. it is not a no-op implementation.
     * @return {boolean} `true` when enabled, `false` otherwise.
     */

  }, {
    key: "isDebugEnabled",
    value: function isDebugEnabled() {
      return isLevelEnabled(this._level, DEBUG);
    }
    /**
     * Log a debug message.
     * @param {string} message the message to log.
     */

  }, {
    key: "debug",
    value: function debug(message) {
      if (this.isDebugEnabled()) {
        this._loggerFunction(DEBUG, message);
      }
    }
  }], [{
    key: "create",
    value: function create(driverConfig) {
      if (driverConfig && driverConfig.logging) {
        var loggingConfig = driverConfig.logging;
        var level = extractConfiguredLevel(loggingConfig);
        var loggerFunction = extractConfiguredLogger(loggingConfig);
        return new Logger(level, loggerFunction);
      }

      return this.noOp();
    }
    /**
     * Create a no-op logger implementation.
     * @return {Logger} the no-op logger implementation.
     */

  }, {
    key: "noOp",
    value: function noOp() {
      return noOpLogger;
    }
  }]);
  return Logger;
}();

var NoOpLogger =
/*#__PURE__*/
function (_Logger) {
  (0, _inherits2["default"])(NoOpLogger, _Logger);

  function NoOpLogger() {
    (0, _classCallCheck2["default"])(this, NoOpLogger);
    return (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(NoOpLogger).call(this, null, null));
  }

  (0, _createClass2["default"])(NoOpLogger, [{
    key: "isErrorEnabled",
    value: function isErrorEnabled() {
      return false;
    }
  }, {
    key: "error",
    value: function error(message) {}
  }, {
    key: "isWarnEnabled",
    value: function isWarnEnabled() {
      return false;
    }
  }, {
    key: "warn",
    value: function warn(message) {}
  }, {
    key: "isInfoEnabled",
    value: function isInfoEnabled() {
      return false;
    }
  }, {
    key: "info",
    value: function info(message) {}
  }, {
    key: "isDebugEnabled",
    value: function isDebugEnabled() {
      return false;
    }
  }, {
    key: "debug",
    value: function debug(message) {}
  }]);
  return NoOpLogger;
}(Logger);

var noOpLogger = new NoOpLogger();
/**
 * Check if the given logging level is enabled.
 * @param {string} configuredLevel the configured level.
 * @param {string} targetLevel the level to check.
 * @return {boolean} value of `true` when enabled, `false` otherwise.
 */

function isLevelEnabled(configuredLevel, targetLevel) {
  return levels[configuredLevel] >= levels[targetLevel];
}
/**
 * Extract the configured logging level from the driver's logging configuration.
 * @param {Object} loggingConfig the logging configuration.
 * @return {string} the configured log level or default when none configured.
 */


function extractConfiguredLevel(loggingConfig) {
  if (loggingConfig && loggingConfig.level) {
    var configuredLevel = loggingConfig.level;
    var value = levels[configuredLevel];

    if (!value && value !== 0) {
      throw (0, _error.newError)("Illegal logging level: ".concat(configuredLevel, ". Supported levels are: ").concat(Object.keys(levels)));
    }

    return configuredLevel;
  }

  return DEFAULT_LEVEL;
}
/**
 * Extract the configured logger function from the driver's logging configuration.
 * @param {Object} loggingConfig the logging configuration.
 * @return {function(level: string, message: string)} the configured logging function.
 */


function extractConfiguredLogger(loggingConfig) {
  if (loggingConfig && loggingConfig.logger) {
    var configuredLogger = loggingConfig.logger;

    if (configuredLogger && typeof configuredLogger === 'function') {
      return configuredLogger;
    }
  }

  throw (0, _error.newError)("Illegal logger function: ".concat(loggingConfig.logger));
}

var _default = Logger;
exports["default"] = _default;

},{"../error":231,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/defineProperty":8,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":19}],268:[function(require,module,exports){
"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Structure = exports.Unpacker = exports.Packer = void 0;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _node = require('./browser');

var _integer = _interopRequireWildcard(require("../integer"));

var _error = require("../error");

var _graphTypes = require("../graph-types");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var TINY_STRING = 0x80;
var TINY_LIST = 0x90;
var TINY_MAP = 0xa0;
var TINY_STRUCT = 0xb0;
var NULL = 0xc0;
var FLOAT_64 = 0xc1;
var FALSE = 0xc2;
var TRUE = 0xc3;
var INT_8 = 0xc8;
var INT_16 = 0xc9;
var INT_32 = 0xca;
var INT_64 = 0xcb;
var STRING_8 = 0xd0;
var STRING_16 = 0xd1;
var STRING_32 = 0xd2;
var LIST_8 = 0xd4;
var LIST_16 = 0xd5;
var LIST_32 = 0xd6;
var BYTES_8 = 0xcc;
var BYTES_16 = 0xcd;
var BYTES_32 = 0xce;
var MAP_8 = 0xd8;
var MAP_16 = 0xd9;
var MAP_32 = 0xda;
var STRUCT_8 = 0xdc;
var STRUCT_16 = 0xdd;
var NODE = 0x4e;
var NODE_STRUCT_SIZE = 3;
var RELATIONSHIP = 0x52;
var RELATIONSHIP_STRUCT_SIZE = 5;
var UNBOUND_RELATIONSHIP = 0x72;
var UNBOUND_RELATIONSHIP_STRUCT_SIZE = 3;
var PATH = 0x50;
var PATH_STRUCT_SIZE = 3;
/**
 * A Structure have a signature and fields.
 * @access private
 */

var Structure =
/*#__PURE__*/
function () {
  /**
   * Create new instance
   */
  function Structure(signature, fields) {
    (0, _classCallCheck2["default"])(this, Structure);
    this.signature = signature;
    this.fields = fields;
  }

  (0, _createClass2["default"])(Structure, [{
    key: "toString",
    value: function toString() {
      var fieldStr = '';

      for (var i = 0; i < this.fields.length; i++) {
        if (i > 0) {
          fieldStr += ', ';
        }

        fieldStr += this.fields[i];
      }

      return 'Structure(' + this.signature + ', [' + fieldStr + '])';
    }
  }]);
  return Structure;
}();
/**
 * Class to pack
 * @access private
 */


exports.Structure = Structure;

var Packer =
/*#__PURE__*/
function () {
  /**
   * @constructor
   * @param {Chunker} channel the chunker backed by a network channel.
   */
  function Packer(channel) {
    (0, _classCallCheck2["default"])(this, Packer);
    this._ch = channel;
    this._byteArraysSupported = true;
  }
  /**
   * Creates a packable function out of the provided value
   * @param x the value to pack
   * @returns Function
   */


  (0, _createClass2["default"])(Packer, [{
    key: "packable",
    value: function packable(x) {
      var _this = this;

      if (x === null) {
        return function () {
          return _this._ch.writeUInt8(NULL);
        };
      } else if (x === true) {
        return function () {
          return _this._ch.writeUInt8(TRUE);
        };
      } else if (x === false) {
        return function () {
          return _this._ch.writeUInt8(FALSE);
        };
      } else if (typeof x === 'number') {
        return function () {
          return _this.packFloat(x);
        };
      } else if (typeof x === 'string') {
        return function () {
          return _this.packString(x);
        };
      } else if ((0, _integer.isInt)(x)) {
        return function () {
          return _this.packInteger(x);
        };
      } else if (x instanceof Int8Array) {
        return function () {
          return _this.packBytes(x);
        };
      } else if (x instanceof Array) {
        return function () {
          _this.packListHeader(x.length);

          for (var _i = 0; _i < x.length; _i++) {
            _this.packable(x[_i] === undefined ? null : x[_i])();
          }
        };
      } else if (isIterable(x)) {
        return this.packableIterable(x);
      } else if (x instanceof _graphTypes.Node) {
        return this._nonPackableValue("It is not allowed to pass nodes in query parameters, given: ".concat(x));
      } else if (x instanceof _graphTypes.Relationship) {
        return this._nonPackableValue("It is not allowed to pass relationships in query parameters, given: ".concat(x));
      } else if (x instanceof _graphTypes.Path) {
        return this._nonPackableValue("It is not allowed to pass paths in query parameters, given: ".concat(x));
      } else if (x instanceof Structure) {
        var packableFields = [];

        for (var i = 0; i < x.fields.length; i++) {
          packableFields[i] = this.packable(x.fields[i]);
        }

        return function () {
          return _this.packStruct(x.signature, packableFields);
        };
      } else if ((0, _typeof2["default"])(x) === 'object') {
        return function () {
          var keys = Object.keys(x);
          var count = 0;

          for (var _i2 = 0; _i2 < keys.length; _i2++) {
            if (x[keys[_i2]] !== undefined) {
              count++;
            }
          }

          _this.packMapHeader(count);

          for (var _i3 = 0; _i3 < keys.length; _i3++) {
            var key = keys[_i3];

            if (x[key] !== undefined) {
              _this.packString(key);

              _this.packable(x[key])();
            }
          }
        };
      } else {
        return this._nonPackableValue("Unable to pack the given value: ".concat(x));
      }
    }
  }, {
    key: "packableIterable",
    value: function packableIterable(iterable) {
      try {
        var array = Array.from(iterable);
        return this.packable(array);
      } catch (e) {
        // handle errors from iterable to array conversion
        throw (0, _error.newError)("Cannot pack given iterable, ".concat(e.message, ": ").concat(iterable));
      }
    }
    /**
     * Packs a struct
     * @param signature the signature of the struct
     * @param packableFields the fields of the struct, make sure you call `packable on all fields`
     */

  }, {
    key: "packStruct",
    value: function packStruct(signature, packableFields) {
      packableFields = packableFields || [];
      this.packStructHeader(packableFields.length, signature);

      for (var i = 0; i < packableFields.length; i++) {
        packableFields[i]();
      }
    }
  }, {
    key: "packInteger",
    value: function packInteger(x) {
      var high = x.high;
      var low = x.low;

      if (x.greaterThanOrEqual(-0x10) && x.lessThan(0x80)) {
        this._ch.writeInt8(low);
      } else if (x.greaterThanOrEqual(-0x80) && x.lessThan(-0x10)) {
        this._ch.writeUInt8(INT_8);

        this._ch.writeInt8(low);
      } else if (x.greaterThanOrEqual(-0x8000) && x.lessThan(0x8000)) {
        this._ch.writeUInt8(INT_16);

        this._ch.writeInt16(low);
      } else if (x.greaterThanOrEqual(-0x80000000) && x.lessThan(0x80000000)) {
        this._ch.writeUInt8(INT_32);

        this._ch.writeInt32(low);
      } else {
        this._ch.writeUInt8(INT_64);

        this._ch.writeInt32(high);

        this._ch.writeInt32(low);
      }
    }
  }, {
    key: "packFloat",
    value: function packFloat(x) {
      this._ch.writeUInt8(FLOAT_64);

      this._ch.writeFloat64(x);
    }
  }, {
    key: "packString",
    value: function packString(x) {
      var bytes = _node.utf8.encode(x);

      var size = bytes.length;

      if (size < 0x10) {
        this._ch.writeUInt8(TINY_STRING | size);

        this._ch.writeBytes(bytes);
      } else if (size < 0x100) {
        this._ch.writeUInt8(STRING_8);

        this._ch.writeUInt8(size);

        this._ch.writeBytes(bytes);
      } else if (size < 0x10000) {
        this._ch.writeUInt8(STRING_16);

        this._ch.writeUInt8(size / 256 >> 0);

        this._ch.writeUInt8(size % 256);

        this._ch.writeBytes(bytes);
      } else if (size < 0x100000000) {
        this._ch.writeUInt8(STRING_32);

        this._ch.writeUInt8((size / 16777216 >> 0) % 256);

        this._ch.writeUInt8((size / 65536 >> 0) % 256);

        this._ch.writeUInt8((size / 256 >> 0) % 256);

        this._ch.writeUInt8(size % 256);

        this._ch.writeBytes(bytes);
      } else {
        throw (0, _error.newError)('UTF-8 strings of size ' + size + ' are not supported');
      }
    }
  }, {
    key: "packListHeader",
    value: function packListHeader(size) {
      if (size < 0x10) {
        this._ch.writeUInt8(TINY_LIST | size);
      } else if (size < 0x100) {
        this._ch.writeUInt8(LIST_8);

        this._ch.writeUInt8(size);
      } else if (size < 0x10000) {
        this._ch.writeUInt8(LIST_16);

        this._ch.writeUInt8((size / 256 >> 0) % 256);

        this._ch.writeUInt8(size % 256);
      } else if (size < 0x100000000) {
        this._ch.writeUInt8(LIST_32);

        this._ch.writeUInt8((size / 16777216 >> 0) % 256);

        this._ch.writeUInt8((size / 65536 >> 0) % 256);

        this._ch.writeUInt8((size / 256 >> 0) % 256);

        this._ch.writeUInt8(size % 256);
      } else {
        throw (0, _error.newError)('Lists of size ' + size + ' are not supported');
      }
    }
  }, {
    key: "packBytes",
    value: function packBytes(array) {
      if (this._byteArraysSupported) {
        this.packBytesHeader(array.length);

        for (var i = 0; i < array.length; i++) {
          this._ch.writeInt8(array[i]);
        }
      } else {
        throw (0, _error.newError)('Byte arrays are not supported by the database this driver is connected to');
      }
    }
  }, {
    key: "packBytesHeader",
    value: function packBytesHeader(size) {
      if (size < 0x100) {
        this._ch.writeUInt8(BYTES_8);

        this._ch.writeUInt8(size);
      } else if (size < 0x10000) {
        this._ch.writeUInt8(BYTES_16);

        this._ch.writeUInt8((size / 256 >> 0) % 256);

        this._ch.writeUInt8(size % 256);
      } else if (size < 0x100000000) {
        this._ch.writeUInt8(BYTES_32);

        this._ch.writeUInt8((size / 16777216 >> 0) % 256);

        this._ch.writeUInt8((size / 65536 >> 0) % 256);

        this._ch.writeUInt8((size / 256 >> 0) % 256);

        this._ch.writeUInt8(size % 256);
      } else {
        throw (0, _error.newError)('Byte arrays of size ' + size + ' are not supported');
      }
    }
  }, {
    key: "packMapHeader",
    value: function packMapHeader(size) {
      if (size < 0x10) {
        this._ch.writeUInt8(TINY_MAP | size);
      } else if (size < 0x100) {
        this._ch.writeUInt8(MAP_8);

        this._ch.writeUInt8(size);
      } else if (size < 0x10000) {
        this._ch.writeUInt8(MAP_16);

        this._ch.writeUInt8(size / 256 >> 0);

        this._ch.writeUInt8(size % 256);
      } else if (size < 0x100000000) {
        this._ch.writeUInt8(MAP_32);

        this._ch.writeUInt8((size / 16777216 >> 0) % 256);

        this._ch.writeUInt8((size / 65536 >> 0) % 256);

        this._ch.writeUInt8((size / 256 >> 0) % 256);

        this._ch.writeUInt8(size % 256);
      } else {
        throw (0, _error.newError)('Maps of size ' + size + ' are not supported');
      }
    }
  }, {
    key: "packStructHeader",
    value: function packStructHeader(size, signature) {
      if (size < 0x10) {
        this._ch.writeUInt8(TINY_STRUCT | size);

        this._ch.writeUInt8(signature);
      } else if (size < 0x100) {
        this._ch.writeUInt8(STRUCT_8);

        this._ch.writeUInt8(size);

        this._ch.writeUInt8(signature);
      } else if (size < 0x10000) {
        this._ch.writeUInt8(STRUCT_16);

        this._ch.writeUInt8(size / 256 >> 0);

        this._ch.writeUInt8(size % 256);
      } else {
        throw (0, _error.newError)('Structures of size ' + size + ' are not supported');
      }
    }
  }, {
    key: "disableByteArrays",
    value: function disableByteArrays() {
      this._byteArraysSupported = false;
    }
  }, {
    key: "_nonPackableValue",
    value: function _nonPackableValue(message) {
      return function () {
        throw (0, _error.newError)(message, _error.PROTOCOL_ERROR);
      };
    }
  }]);
  return Packer;
}();
/**
 * Class to unpack
 * @access private
 */


exports.Packer = Packer;

var Unpacker =
/*#__PURE__*/
function () {
  /**
   * @constructor
   * @param {boolean} disableLosslessIntegers if this unpacker should convert all received integers to native JS numbers.
   */
  function Unpacker() {
    var disableLosslessIntegers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    (0, _classCallCheck2["default"])(this, Unpacker);
    this._disableLosslessIntegers = disableLosslessIntegers;
  }

  (0, _createClass2["default"])(Unpacker, [{
    key: "unpack",
    value: function unpack(buffer) {
      var marker = buffer.readUInt8();
      var markerHigh = marker & 0xf0;
      var markerLow = marker & 0x0f;

      if (marker === NULL) {
        return null;
      }

      var _boolean = this._unpackBoolean(marker);

      if (_boolean !== null) {
        return _boolean;
      }

      var numberOrInteger = this._unpackNumberOrInteger(marker, buffer);

      if (numberOrInteger !== null) {
        if (this._disableLosslessIntegers && (0, _integer.isInt)(numberOrInteger)) {
          return numberOrInteger.toNumberOrInfinity();
        }

        return numberOrInteger;
      }

      var string = this._unpackString(marker, markerHigh, markerLow, buffer);

      if (string !== null) {
        return string;
      }

      var list = this._unpackList(marker, markerHigh, markerLow, buffer);

      if (list !== null) {
        return list;
      }

      var byteArray = this._unpackByteArray(marker, buffer);

      if (byteArray !== null) {
        return byteArray;
      }

      var map = this._unpackMap(marker, markerHigh, markerLow, buffer);

      if (map !== null) {
        return map;
      }

      var struct = this._unpackStruct(marker, markerHigh, markerLow, buffer);

      if (struct !== null) {
        return struct;
      }

      throw (0, _error.newError)('Unknown packed value with marker ' + marker.toString(16));
    }
  }, {
    key: "unpackInteger",
    value: function unpackInteger(buffer) {
      var marker = buffer.readUInt8();

      var result = this._unpackInteger(marker, buffer);

      if (result == null) {
        throw (0, _error.newError)('Unable to unpack integer value with marker ' + marker.toString(16));
      }

      return result;
    }
  }, {
    key: "_unpackBoolean",
    value: function _unpackBoolean(marker) {
      if (marker === TRUE) {
        return true;
      } else if (marker === FALSE) {
        return false;
      } else {
        return null;
      }
    }
  }, {
    key: "_unpackNumberOrInteger",
    value: function _unpackNumberOrInteger(marker, buffer) {
      if (marker === FLOAT_64) {
        return buffer.readFloat64();
      } else {
        return this._unpackInteger(marker, buffer);
      }
    }
  }, {
    key: "_unpackInteger",
    value: function _unpackInteger(marker, buffer) {
      if (marker >= 0 && marker < 128) {
        return (0, _integer["int"])(marker);
      } else if (marker >= 240 && marker < 256) {
        return (0, _integer["int"])(marker - 256);
      } else if (marker === INT_8) {
        return (0, _integer["int"])(buffer.readInt8());
      } else if (marker === INT_16) {
        return (0, _integer["int"])(buffer.readInt16());
      } else if (marker === INT_32) {
        var b = buffer.readInt32();
        return (0, _integer["int"])(b);
      } else if (marker === INT_64) {
        var high = buffer.readInt32();
        var low = buffer.readInt32();
        return new _integer["default"](low, high);
      } else {
        return null;
      }
    }
  }, {
    key: "_unpackString",
    value: function _unpackString(marker, markerHigh, markerLow, buffer) {
      if (markerHigh === TINY_STRING) {
        return _node.utf8.decode(buffer, markerLow);
      } else if (marker === STRING_8) {
        return _node.utf8.decode(buffer, buffer.readUInt8());
      } else if (marker === STRING_16) {
        return _node.utf8.decode(buffer, buffer.readUInt16());
      } else if (marker === STRING_32) {
        return _node.utf8.decode(buffer, buffer.readUInt32());
      } else {
        return null;
      }
    }
  }, {
    key: "_unpackList",
    value: function _unpackList(marker, markerHigh, markerLow, buffer) {
      if (markerHigh === TINY_LIST) {
        return this._unpackListWithSize(markerLow, buffer);
      } else if (marker === LIST_8) {
        return this._unpackListWithSize(buffer.readUInt8(), buffer);
      } else if (marker === LIST_16) {
        return this._unpackListWithSize(buffer.readUInt16(), buffer);
      } else if (marker === LIST_32) {
        return this._unpackListWithSize(buffer.readUInt32(), buffer);
      } else {
        return null;
      }
    }
  }, {
    key: "_unpackListWithSize",
    value: function _unpackListWithSize(size, buffer) {
      var value = [];

      for (var i = 0; i < size; i++) {
        value.push(this.unpack(buffer));
      }

      return value;
    }
  }, {
    key: "_unpackByteArray",
    value: function _unpackByteArray(marker, buffer) {
      if (marker === BYTES_8) {
        return this._unpackByteArrayWithSize(buffer.readUInt8(), buffer);
      } else if (marker === BYTES_16) {
        return this._unpackByteArrayWithSize(buffer.readUInt16(), buffer);
      } else if (marker === BYTES_32) {
        return this._unpackByteArrayWithSize(buffer.readUInt32(), buffer);
      } else {
        return null;
      }
    }
  }, {
    key: "_unpackByteArrayWithSize",
    value: function _unpackByteArrayWithSize(size, buffer) {
      var value = new Int8Array(size);

      for (var i = 0; i < size; i++) {
        value[i] = buffer.readInt8();
      }

      return value;
    }
  }, {
    key: "_unpackMap",
    value: function _unpackMap(marker, markerHigh, markerLow, buffer) {
      if (markerHigh === TINY_MAP) {
        return this._unpackMapWithSize(markerLow, buffer);
      } else if (marker === MAP_8) {
        return this._unpackMapWithSize(buffer.readUInt8(), buffer);
      } else if (marker === MAP_16) {
        return this._unpackMapWithSize(buffer.readUInt16(), buffer);
      } else if (marker === MAP_32) {
        return this._unpackMapWithSize(buffer.readUInt32(), buffer);
      } else {
        return null;
      }
    }
  }, {
    key: "_unpackMapWithSize",
    value: function _unpackMapWithSize(size, buffer) {
      var value = {};

      for (var i = 0; i < size; i++) {
        var key = this.unpack(buffer);
        value[key] = this.unpack(buffer);
      }

      return value;
    }
  }, {
    key: "_unpackStruct",
    value: function _unpackStruct(marker, markerHigh, markerLow, buffer) {
      if (markerHigh === TINY_STRUCT) {
        return this._unpackStructWithSize(markerLow, buffer);
      } else if (marker === STRUCT_8) {
        return this._unpackStructWithSize(buffer.readUInt8(), buffer);
      } else if (marker === STRUCT_16) {
        return this._unpackStructWithSize(buffer.readUInt16(), buffer);
      } else {
        return null;
      }
    }
  }, {
    key: "_unpackStructWithSize",
    value: function _unpackStructWithSize(structSize, buffer) {
      var signature = buffer.readUInt8();

      if (signature === NODE) {
        return this._unpackNode(structSize, buffer);
      } else if (signature === RELATIONSHIP) {
        return this._unpackRelationship(structSize, buffer);
      } else if (signature === UNBOUND_RELATIONSHIP) {
        return this._unpackUnboundRelationship(structSize, buffer);
      } else if (signature === PATH) {
        return this._unpackPath(structSize, buffer);
      } else {
        return this._unpackUnknownStruct(signature, structSize, buffer);
      }
    }
  }, {
    key: "_unpackNode",
    value: function _unpackNode(structSize, buffer) {
      this._verifyStructSize('Node', NODE_STRUCT_SIZE, structSize);

      return new _graphTypes.Node(this.unpack(buffer), // Identity
      this.unpack(buffer), // Labels
      this.unpack(buffer) // Properties
      );
    }
  }, {
    key: "_unpackRelationship",
    value: function _unpackRelationship(structSize, buffer) {
      this._verifyStructSize('Relationship', RELATIONSHIP_STRUCT_SIZE, structSize);

      return new _graphTypes.Relationship(this.unpack(buffer), // Identity
      this.unpack(buffer), // Start Node Identity
      this.unpack(buffer), // End Node Identity
      this.unpack(buffer), // Type
      this.unpack(buffer) // Properties
      );
    }
  }, {
    key: "_unpackUnboundRelationship",
    value: function _unpackUnboundRelationship(structSize, buffer) {
      this._verifyStructSize('UnboundRelationship', UNBOUND_RELATIONSHIP_STRUCT_SIZE, structSize);

      return new _graphTypes.UnboundRelationship(this.unpack(buffer), // Identity
      this.unpack(buffer), // Type
      this.unpack(buffer) // Properties
      );
    }
  }, {
    key: "_unpackPath",
    value: function _unpackPath(structSize, buffer) {
      this._verifyStructSize('Path', PATH_STRUCT_SIZE, structSize);

      var nodes = this.unpack(buffer);
      var rels = this.unpack(buffer);
      var sequence = this.unpack(buffer);
      var segments = [];
      var prevNode = nodes[0];

      for (var i = 0; i < sequence.length; i += 2) {
        var nextNode = nodes[sequence[i + 1]];
        var relIndex = sequence[i];
        var rel = void 0;

        if (relIndex > 0) {
          rel = rels[relIndex - 1];

          if (rel instanceof _graphTypes.UnboundRelationship) {
            // To avoid duplication, relationships in a path do not contain
            // information about their start and end nodes, that's instead
            // inferred from the path sequence. This is us inferring (and,
            // for performance reasons remembering) the start/end of a rel.
            rels[relIndex - 1] = rel = rel.bind(prevNode.identity, nextNode.identity);
          }
        } else {
          rel = rels[-relIndex - 1];

          if (rel instanceof _graphTypes.UnboundRelationship) {
            // See above
            rels[-relIndex - 1] = rel = rel.bind(nextNode.identity, prevNode.identity);
          }
        } // Done hydrating one path segment.


        segments.push(new _graphTypes.PathSegment(prevNode, rel, nextNode));
        prevNode = nextNode;
      }

      return new _graphTypes.Path(nodes[0], nodes[nodes.length - 1], segments);
    }
  }, {
    key: "_unpackUnknownStruct",
    value: function _unpackUnknownStruct(signature, structSize, buffer) {
      var result = new Structure(signature, []);

      for (var i = 0; i < structSize; i++) {
        result.fields.push(this.unpack(buffer));
      }

      return result;
    }
  }, {
    key: "_verifyStructSize",
    value: function _verifyStructSize(structName, expectedSize, actualSize) {
      if (expectedSize !== actualSize) {
        throw (0, _error.newError)("Wrong struct size for ".concat(structName, ", expected ").concat(expectedSize, " but was ").concat(actualSize), _error.PROTOCOL_ERROR);
      }
    }
  }]);
  return Unpacker;
}();

exports.Unpacker = Unpacker;

function isIterable(obj) {
  if (obj == null) {
    return false;
  }

  return typeof obj[Symbol.iterator] === 'function';
}

},{"../error":231,"../graph-types":232,"../integer":234,"./browser":247,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/interopRequireWildcard":13,"@babel/runtime/helpers/typeof":24}],269:[function(require,module,exports){
"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Unpacker = exports.Packer = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var v1 = _interopRequireWildcard(require("./packstream-v1"));

var _spatialTypes = require("../spatial-types");

var _temporalTypes = require("../temporal-types");

var _integer = require("../integer");

var _temporalUtil = require("./temporal-util");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var POINT_2D = 0x58;
var POINT_2D_STRUCT_SIZE = 3;
var POINT_3D = 0x59;
var POINT_3D_STRUCT_SIZE = 4;
var DURATION = 0x45;
var DURATION_STRUCT_SIZE = 4;
var LOCAL_TIME = 0x74;
var LOCAL_TIME_STRUCT_SIZE = 1;
var TIME = 0x54;
var TIME_STRUCT_SIZE = 2;
var DATE = 0x44;
var DATE_STRUCT_SIZE = 1;
var LOCAL_DATE_TIME = 0x64;
var LOCAL_DATE_TIME_STRUCT_SIZE = 2;
var DATE_TIME_WITH_ZONE_OFFSET = 0x46;
var DATE_TIME_WITH_ZONE_OFFSET_STRUCT_SIZE = 3;
var DATE_TIME_WITH_ZONE_ID = 0x66;
var DATE_TIME_WITH_ZONE_ID_STRUCT_SIZE = 3;

var Packer =
/*#__PURE__*/
function (_v1$Packer) {
  (0, _inherits2["default"])(Packer, _v1$Packer);

  function Packer() {
    (0, _classCallCheck2["default"])(this, Packer);
    return (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(Packer).apply(this, arguments));
  }

  (0, _createClass2["default"])(Packer, [{
    key: "disableByteArrays",
    value: function disableByteArrays() {
      throw new Error('Bolt V2 should always support byte arrays');
    }
  }, {
    key: "packable",
    value: function packable(obj) {
      var _this = this;

      if ((0, _spatialTypes.isPoint)(obj)) {
        return function () {
          return packPoint(obj, _this);
        };
      } else if ((0, _temporalTypes.isDuration)(obj)) {
        return function () {
          return packDuration(obj, _this);
        };
      } else if ((0, _temporalTypes.isLocalTime)(obj)) {
        return function () {
          return packLocalTime(obj, _this);
        };
      } else if ((0, _temporalTypes.isTime)(obj)) {
        return function () {
          return packTime(obj, _this);
        };
      } else if ((0, _temporalTypes.isDate)(obj)) {
        return function () {
          return packDate(obj, _this);
        };
      } else if ((0, _temporalTypes.isLocalDateTime)(obj)) {
        return function () {
          return packLocalDateTime(obj, _this);
        };
      } else if ((0, _temporalTypes.isDateTime)(obj)) {
        return function () {
          return packDateTime(obj, _this);
        };
      } else {
        return (0, _get2["default"])((0, _getPrototypeOf2["default"])(Packer.prototype), "packable", this).call(this, obj);
      }
    }
  }]);
  return Packer;
}(v1.Packer);

exports.Packer = Packer;

var Unpacker =
/*#__PURE__*/
function (_v1$Unpacker) {
  (0, _inherits2["default"])(Unpacker, _v1$Unpacker);

  /**
   * @constructor
   * @param {boolean} disableLosslessIntegers if this unpacker should convert all received integers to native JS numbers.
   */
  function Unpacker() {
    var disableLosslessIntegers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    (0, _classCallCheck2["default"])(this, Unpacker);
    return (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(Unpacker).call(this, disableLosslessIntegers));
  }

  (0, _createClass2["default"])(Unpacker, [{
    key: "_unpackUnknownStruct",
    value: function _unpackUnknownStruct(signature, structSize, buffer) {
      if (signature === POINT_2D) {
        return unpackPoint2D(this, structSize, buffer);
      } else if (signature === POINT_3D) {
        return unpackPoint3D(this, structSize, buffer);
      } else if (signature === DURATION) {
        return unpackDuration(this, structSize, buffer);
      } else if (signature === LOCAL_TIME) {
        return unpackLocalTime(this, structSize, buffer, this._disableLosslessIntegers);
      } else if (signature === TIME) {
        return unpackTime(this, structSize, buffer, this._disableLosslessIntegers);
      } else if (signature === DATE) {
        return unpackDate(this, structSize, buffer, this._disableLosslessIntegers);
      } else if (signature === LOCAL_DATE_TIME) {
        return unpackLocalDateTime(this, structSize, buffer, this._disableLosslessIntegers);
      } else if (signature === DATE_TIME_WITH_ZONE_OFFSET) {
        return unpackDateTimeWithZoneOffset(this, structSize, buffer, this._disableLosslessIntegers);
      } else if (signature === DATE_TIME_WITH_ZONE_ID) {
        return unpackDateTimeWithZoneId(this, structSize, buffer, this._disableLosslessIntegers);
      } else {
        return (0, _get2["default"])((0, _getPrototypeOf2["default"])(Unpacker.prototype), "_unpackUnknownStruct", this).call(this, signature, structSize, buffer, this._disableLosslessIntegers);
      }
    }
  }]);
  return Unpacker;
}(v1.Unpacker);
/**
 * Pack given 2D or 3D point.
 * @param {Point} point the point value to pack.
 * @param {Packer} packer the packer to use.
 */


exports.Unpacker = Unpacker;

function packPoint(point, packer) {
  var is2DPoint = point.z === null || point.z === undefined;

  if (is2DPoint) {
    packPoint2D(point, packer);
  } else {
    packPoint3D(point, packer);
  }
}
/**
 * Pack given 2D point.
 * @param {Point} point the point value to pack.
 * @param {Packer} packer the packer to use.
 */


function packPoint2D(point, packer) {
  var packableStructFields = [packer.packable((0, _integer["int"])(point.srid)), packer.packable(point.x), packer.packable(point.y)];
  packer.packStruct(POINT_2D, packableStructFields);
}
/**
 * Pack given 3D point.
 * @param {Point} point the point value to pack.
 * @param {Packer} packer the packer to use.
 */


function packPoint3D(point, packer) {
  var packableStructFields = [packer.packable((0, _integer["int"])(point.srid)), packer.packable(point.x), packer.packable(point.y), packer.packable(point.z)];
  packer.packStruct(POINT_3D, packableStructFields);
}
/**
 * Unpack 2D point value using the given unpacker.
 * @param {Unpacker} unpacker the unpacker to use.
 * @param {number} structSize the retrieved struct size.
 * @param {BaseBuffer} buffer the buffer to unpack from.
 * @return {Point} the unpacked 2D point value.
 */


function unpackPoint2D(unpacker, structSize, buffer) {
  unpacker._verifyStructSize('Point2D', POINT_2D_STRUCT_SIZE, structSize);

  return new _spatialTypes.Point(unpacker.unpack(buffer), // srid
  unpacker.unpack(buffer), // x
  unpacker.unpack(buffer), // y
  undefined // z
  );
}
/**
 * Unpack 3D point value using the given unpacker.
 * @param {Unpacker} unpacker the unpacker to use.
 * @param {number} structSize the retrieved struct size.
 * @param {BaseBuffer} buffer the buffer to unpack from.
 * @return {Point} the unpacked 3D point value.
 */


function unpackPoint3D(unpacker, structSize, buffer) {
  unpacker._verifyStructSize('Point3D', POINT_3D_STRUCT_SIZE, structSize);

  return new _spatialTypes.Point(unpacker.unpack(buffer), // srid
  unpacker.unpack(buffer), // x
  unpacker.unpack(buffer), // y
  unpacker.unpack(buffer) // z
  );
}
/**
 * Pack given duration.
 * @param {Duration} value the duration value to pack.
 * @param {Packer} packer the packer to use.
 */


function packDuration(value, packer) {
  var months = (0, _integer["int"])(value.months);
  var days = (0, _integer["int"])(value.days);
  var seconds = (0, _integer["int"])(value.seconds);
  var nanoseconds = (0, _integer["int"])(value.nanoseconds);
  var packableStructFields = [packer.packable(months), packer.packable(days), packer.packable(seconds), packer.packable(nanoseconds)];
  packer.packStruct(DURATION, packableStructFields);
}
/**
 * Unpack duration value using the given unpacker.
 * @param {Unpacker} unpacker the unpacker to use.
 * @param {number} structSize the retrieved struct size.
 * @param {BaseBuffer} buffer the buffer to unpack from.
 * @return {Duration} the unpacked duration value.
 */


function unpackDuration(unpacker, structSize, buffer) {
  unpacker._verifyStructSize('Duration', DURATION_STRUCT_SIZE, structSize);

  var months = unpacker.unpack(buffer);
  var days = unpacker.unpack(buffer);
  var seconds = unpacker.unpack(buffer);
  var nanoseconds = unpacker.unpack(buffer);
  return new _temporalTypes.Duration(months, days, seconds, nanoseconds);
}
/**
 * Pack given local time.
 * @param {LocalTime} value the local time value to pack.
 * @param {Packer} packer the packer to use.
 */


function packLocalTime(value, packer) {
  var nanoOfDay = (0, _temporalUtil.localTimeToNanoOfDay)(value.hour, value.minute, value.second, value.nanosecond);
  var packableStructFields = [packer.packable(nanoOfDay)];
  packer.packStruct(LOCAL_TIME, packableStructFields);
}
/**
 * Unpack local time value using the given unpacker.
 * @param {Unpacker} unpacker the unpacker to use.
 * @param {number} structSize the retrieved struct size.
 * @param {BaseBuffer} buffer the buffer to unpack from.
 * @param {boolean} disableLosslessIntegers if integer properties in the result local time should be native JS numbers.
 * @return {LocalTime} the unpacked local time value.
 */


function unpackLocalTime(unpacker, structSize, buffer, disableLosslessIntegers) {
  unpacker._verifyStructSize('LocalTime', LOCAL_TIME_STRUCT_SIZE, structSize);

  var nanoOfDay = unpacker.unpackInteger(buffer);
  var result = (0, _temporalUtil.nanoOfDayToLocalTime)(nanoOfDay);
  return convertIntegerPropsIfNeeded(result, disableLosslessIntegers);
}
/**
 * Pack given time.
 * @param {Time} value the time value to pack.
 * @param {Packer} packer the packer to use.
 */


function packTime(value, packer) {
  var nanoOfDay = (0, _temporalUtil.localTimeToNanoOfDay)(value.hour, value.minute, value.second, value.nanosecond);
  var offsetSeconds = (0, _integer["int"])(value.timeZoneOffsetSeconds);
  var packableStructFields = [packer.packable(nanoOfDay), packer.packable(offsetSeconds)];
  packer.packStruct(TIME, packableStructFields);
}
/**
 * Unpack time value using the given unpacker.
 * @param {Unpacker} unpacker the unpacker to use.
 * @param {number} structSize the retrieved struct size.
 * @param {BaseBuffer} buffer the buffer to unpack from.
 * @param {boolean} disableLosslessIntegers if integer properties in the result time should be native JS numbers.
 * @return {Time} the unpacked time value.
 */


function unpackTime(unpacker, structSize, buffer, disableLosslessIntegers) {
  unpacker._verifyStructSize('Time', TIME_STRUCT_SIZE, structSize);

  var nanoOfDay = unpacker.unpackInteger(buffer);
  var offsetSeconds = unpacker.unpackInteger(buffer);
  var localTime = (0, _temporalUtil.nanoOfDayToLocalTime)(nanoOfDay);
  var result = new _temporalTypes.Time(localTime.hour, localTime.minute, localTime.second, localTime.nanosecond, offsetSeconds);
  return convertIntegerPropsIfNeeded(result, disableLosslessIntegers);
}
/**
 * Pack given neo4j date.
 * @param {Date} value the date value to pack.
 * @param {Packer} packer the packer to use.
 */


function packDate(value, packer) {
  var epochDay = (0, _temporalUtil.dateToEpochDay)(value.year, value.month, value.day);
  var packableStructFields = [packer.packable(epochDay)];
  packer.packStruct(DATE, packableStructFields);
}
/**
 * Unpack neo4j date value using the given unpacker.
 * @param {Unpacker} unpacker the unpacker to use.
 * @param {number} structSize the retrieved struct size.
 * @param {BaseBuffer} buffer the buffer to unpack from.
 * @param {boolean} disableLosslessIntegers if integer properties in the result date should be native JS numbers.
 * @return {Date} the unpacked neo4j date value.
 */


function unpackDate(unpacker, structSize, buffer, disableLosslessIntegers) {
  unpacker._verifyStructSize('Date', DATE_STRUCT_SIZE, structSize);

  var epochDay = unpacker.unpackInteger(buffer);
  var result = (0, _temporalUtil.epochDayToDate)(epochDay);
  return convertIntegerPropsIfNeeded(result, disableLosslessIntegers);
}
/**
 * Pack given local date time.
 * @param {LocalDateTime} value the local date time value to pack.
 * @param {Packer} packer the packer to use.
 */


function packLocalDateTime(value, packer) {
  var epochSecond = (0, _temporalUtil.localDateTimeToEpochSecond)(value.year, value.month, value.day, value.hour, value.minute, value.second, value.nanosecond);
  var nano = (0, _integer["int"])(value.nanosecond);
  var packableStructFields = [packer.packable(epochSecond), packer.packable(nano)];
  packer.packStruct(LOCAL_DATE_TIME, packableStructFields);
}
/**
 * Unpack local date time value using the given unpacker.
 * @param {Unpacker} unpacker the unpacker to use.
 * @param {number} structSize the retrieved struct size.
 * @param {BaseBuffer} buffer the buffer to unpack from.
 * @param {boolean} disableLosslessIntegers if integer properties in the result local date-time should be native JS numbers.
 * @return {LocalDateTime} the unpacked local date time value.
 */


function unpackLocalDateTime(unpacker, structSize, buffer, disableLosslessIntegers) {
  unpacker._verifyStructSize('LocalDateTime', LOCAL_DATE_TIME_STRUCT_SIZE, structSize);

  var epochSecond = unpacker.unpackInteger(buffer);
  var nano = unpacker.unpackInteger(buffer);
  var result = (0, _temporalUtil.epochSecondAndNanoToLocalDateTime)(epochSecond, nano);
  return convertIntegerPropsIfNeeded(result, disableLosslessIntegers);
}
/**
 * Pack given date time.
 * @param {DateTime} value the date time value to pack.
 * @param {Packer} packer the packer to use.
 */


function packDateTime(value, packer) {
  if (value.timeZoneId) {
    packDateTimeWithZoneId(value, packer);
  } else {
    packDateTimeWithZoneOffset(value, packer);
  }
}
/**
 * Pack given date time with zone offset.
 * @param {DateTime} value the date time value to pack.
 * @param {Packer} packer the packer to use.
 */


function packDateTimeWithZoneOffset(value, packer) {
  var epochSecond = (0, _temporalUtil.localDateTimeToEpochSecond)(value.year, value.month, value.day, value.hour, value.minute, value.second, value.nanosecond);
  var nano = (0, _integer["int"])(value.nanosecond);
  var timeZoneOffsetSeconds = (0, _integer["int"])(value.timeZoneOffsetSeconds);
  var packableStructFields = [packer.packable(epochSecond), packer.packable(nano), packer.packable(timeZoneOffsetSeconds)];
  packer.packStruct(DATE_TIME_WITH_ZONE_OFFSET, packableStructFields);
}
/**
 * Unpack date time with zone offset value using the given unpacker.
 * @param {Unpacker} unpacker the unpacker to use.
 * @param {number} structSize the retrieved struct size.
 * @param {BaseBuffer} buffer the buffer to unpack from.
 * @param {boolean} disableLosslessIntegers if integer properties in the result date-time should be native JS numbers.
 * @return {DateTime} the unpacked date time with zone offset value.
 */


function unpackDateTimeWithZoneOffset(unpacker, structSize, buffer, disableLosslessIntegers) {
  unpacker._verifyStructSize('DateTimeWithZoneOffset', DATE_TIME_WITH_ZONE_OFFSET_STRUCT_SIZE, structSize);

  var epochSecond = unpacker.unpackInteger(buffer);
  var nano = unpacker.unpackInteger(buffer);
  var timeZoneOffsetSeconds = unpacker.unpackInteger(buffer);
  var localDateTime = (0, _temporalUtil.epochSecondAndNanoToLocalDateTime)(epochSecond, nano);
  var result = new _temporalTypes.DateTime(localDateTime.year, localDateTime.month, localDateTime.day, localDateTime.hour, localDateTime.minute, localDateTime.second, localDateTime.nanosecond, timeZoneOffsetSeconds, null);
  return convertIntegerPropsIfNeeded(result, disableLosslessIntegers);
}
/**
 * Pack given date time with zone id.
 * @param {DateTime} value the date time value to pack.
 * @param {Packer} packer the packer to use.
 */


function packDateTimeWithZoneId(value, packer) {
  var epochSecond = (0, _temporalUtil.localDateTimeToEpochSecond)(value.year, value.month, value.day, value.hour, value.minute, value.second, value.nanosecond);
  var nano = (0, _integer["int"])(value.nanosecond);
  var timeZoneId = value.timeZoneId;
  var packableStructFields = [packer.packable(epochSecond), packer.packable(nano), packer.packable(timeZoneId)];
  packer.packStruct(DATE_TIME_WITH_ZONE_ID, packableStructFields);
}
/**
 * Unpack date time with zone id value using the given unpacker.
 * @param {Unpacker} unpacker the unpacker to use.
 * @param {number} structSize the retrieved struct size.
 * @param {BaseBuffer} buffer the buffer to unpack from.
 * @param {boolean} disableLosslessIntegers if integer properties in the result date-time should be native JS numbers.
 * @return {DateTime} the unpacked date time with zone id value.
 */


function unpackDateTimeWithZoneId(unpacker, structSize, buffer, disableLosslessIntegers) {
  unpacker._verifyStructSize('DateTimeWithZoneId', DATE_TIME_WITH_ZONE_ID_STRUCT_SIZE, structSize);

  var epochSecond = unpacker.unpackInteger(buffer);
  var nano = unpacker.unpackInteger(buffer);
  var timeZoneId = unpacker.unpack(buffer);
  var localDateTime = (0, _temporalUtil.epochSecondAndNanoToLocalDateTime)(epochSecond, nano);
  var result = new _temporalTypes.DateTime(localDateTime.year, localDateTime.month, localDateTime.day, localDateTime.hour, localDateTime.minute, localDateTime.second, localDateTime.nanosecond, null, timeZoneId);
  return convertIntegerPropsIfNeeded(result, disableLosslessIntegers);
}

function convertIntegerPropsIfNeeded(obj, disableLosslessIntegers) {
  if (!disableLosslessIntegers) {
    return obj;
  }

  var clone = Object.create(Object.getPrototypeOf(obj));

  for (var prop in obj) {
    if (obj.hasOwnProperty(prop)) {
      var value = obj[prop];
      clone[prop] = (0, _integer.isInt)(value) ? value.toNumberOrInfinity() : value;
    }
  }

  Object.freeze(clone);
  return clone;
}

},{"../integer":234,"../spatial-types":296,"../temporal-types":297,"./packstream-v1":268,"./temporal-util":284,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/get":9,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/interopRequireWildcard":13,"@babel/runtime/helpers/possibleConstructorReturn":19}],270:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DEFAULT_ACQUISITION_TIMEOUT = exports.DEFAULT_MAX_SIZE = exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var DEFAULT_MAX_SIZE = 100;
exports.DEFAULT_MAX_SIZE = DEFAULT_MAX_SIZE;
var DEFAULT_ACQUISITION_TIMEOUT = 60 * 1000; // 60 seconds

exports.DEFAULT_ACQUISITION_TIMEOUT = DEFAULT_ACQUISITION_TIMEOUT;

var PoolConfig =
/*#__PURE__*/
function () {
  function PoolConfig(maxSize, acquisitionTimeout) {
    (0, _classCallCheck2["default"])(this, PoolConfig);
    this.maxSize = valueOrDefault(maxSize, DEFAULT_MAX_SIZE);
    this.acquisitionTimeout = valueOrDefault(acquisitionTimeout, DEFAULT_ACQUISITION_TIMEOUT);
  }

  (0, _createClass2["default"])(PoolConfig, null, [{
    key: "defaultConfig",
    value: function defaultConfig() {
      return new PoolConfig(DEFAULT_MAX_SIZE, DEFAULT_ACQUISITION_TIMEOUT);
    }
  }, {
    key: "fromDriverConfig",
    value: function fromDriverConfig(config) {
      var maxSizeConfigured = isConfigured(config.maxConnectionPoolSize);
      var maxSize = maxSizeConfigured ? config.maxConnectionPoolSize : DEFAULT_MAX_SIZE;
      var acquisitionTimeoutConfigured = isConfigured(config.connectionAcquisitionTimeout);
      var acquisitionTimeout = acquisitionTimeoutConfigured ? config.connectionAcquisitionTimeout : DEFAULT_ACQUISITION_TIMEOUT;
      return new PoolConfig(maxSize, acquisitionTimeout);
    }
  }]);
  return PoolConfig;
}();

exports["default"] = PoolConfig;

function valueOrDefault(value, defaultValue) {
  return value === 0 || value ? value : defaultValue;
}

function isConfigured(value) {
  return value === 0 || value;
}

},{"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":12}],271:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _poolConfig = _interopRequireDefault(require("./pool-config"));

var _error = require("../error");

var _logger = _interopRequireDefault(require("./logger"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Pool =
/*#__PURE__*/
function () {
  /**
   * @param {function(address: ServerAddress, function(address: ServerAddress, resource: object): Promise<object>): Promise<object>} create
   *                an allocation function that creates a promise with a new resource. It's given an address for which to
   *                allocate the connection and a function that will return the resource to the pool if invoked, which is
   *                meant to be called on .dispose or .close or whatever mechanism the resource uses to finalize.
   * @param {function(resource: object): Promise<void>} destroy
   *                called with the resource when it is evicted from this pool
   * @param {function(resource: object): boolean} validate
   *                called at various times (like when an instance is acquired and when it is returned.
   *                If this returns false, the resource will be evicted
   * @param {function(resource: object, observer: { onError }): void} installIdleObserver
   *                called when the resource is released back to pool
   * @param {function(resource: object): void} removeIdleObserver
   *                called when the resource is acquired from the pool
   * @param {PoolConfig} config configuration for the new driver.
   * @param {Logger} log the driver logger.
   */
  function Pool() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$create = _ref.create,
        create = _ref$create === void 0 ? function (address, release) {
      return Promise.resolve();
    } : _ref$create,
        _ref$destroy = _ref.destroy,
        destroy = _ref$destroy === void 0 ? function (conn) {
      return Promise.resolve();
    } : _ref$destroy,
        _ref$validate = _ref.validate,
        validate = _ref$validate === void 0 ? function (conn) {
      return true;
    } : _ref$validate,
        _ref$installIdleObser = _ref.installIdleObserver,
        installIdleObserver = _ref$installIdleObser === void 0 ? function (conn, observer) {} : _ref$installIdleObser,
        _ref$removeIdleObserv = _ref.removeIdleObserver,
        removeIdleObserver = _ref$removeIdleObserv === void 0 ? function (conn) {} : _ref$removeIdleObserv,
        _ref$config = _ref.config,
        config = _ref$config === void 0 ? _poolConfig["default"].defaultConfig() : _ref$config,
        _ref$log = _ref.log,
        log = _ref$log === void 0 ? _logger["default"].noOp() : _ref$log;

    (0, _classCallCheck2["default"])(this, Pool);
    this._create = create;
    this._destroy = destroy;
    this._validate = validate;
    this._installIdleObserver = installIdleObserver;
    this._removeIdleObserver = removeIdleObserver;
    this._maxSize = config.maxSize;
    this._acquisitionTimeout = config.acquisitionTimeout;
    this._pools = {};
    this._pendingCreates = {};
    this._acquireRequests = {};
    this._activeResourceCounts = {};
    this._release = this._release.bind(this);
    this._log = log;
    this._closed = false;
  }
  /**
   * Acquire and idle resource fom the pool or create a new one.
   * @param {ServerAddress} address the address for which we're acquiring.
   * @return {Object} resource that is ready to use.
   */


  (0, _createClass2["default"])(Pool, [{
    key: "acquire",
    value: function acquire(address) {
      var _this = this;

      return this._acquire(address).then(function (resource) {
        var key = address.asKey();

        if (resource) {
          // New or existing resource acquired
          return resource;
        } // We're out of resources and will try to acquire later on when an existing resource is released.


        var allRequests = _this._acquireRequests;
        var requests = allRequests[key];

        if (!requests) {
          allRequests[key] = [];
        }

        return new Promise(function (resolve, reject) {
          var request;
          var timeoutId = setTimeout(function () {
            // acquisition timeout fired
            // remove request from the queue of pending requests, if it's still there
            // request might've been taken out by the release operation
            var pendingRequests = allRequests[key];

            if (pendingRequests) {
              allRequests[key] = pendingRequests.filter(function (item) {
                return item !== request;
              });
            }

            if (request.isCompleted()) {// request already resolved/rejected by the release operation; nothing to do
            } else {
              // request is still pending and needs to be failed
              var activeCount = _this.activeResourceCount(address);

              var idleCount = _this.has(address) ? _this._pools[key].length : 0;
              request.reject((0, _error.newError)("Connection acquisition timed out in ".concat(_this._acquisitionTimeout, " ms. Poos status: Active conn count = ").concat(activeCount, ", Idle conn count = ").concat(idleCount, ".")));
            }
          }, _this._acquisitionTimeout);
          request = new PendingRequest(key, resolve, reject, timeoutId, _this._log);
          allRequests[key].push(request);
        });
      });
    }
    /**
     * Destroy all idle resources for the given address.
     * @param {ServerAddress} address the address of the server to purge its pool.
     * @returns {Promise<void>} A promise that is resolved when the resources are purged
     */

  }, {
    key: "purge",
    value: function purge(address) {
      return this._purgeKey(address.asKey());
    }
    /**
     * Destroy all idle resources in this pool.
     * @returns {Promise<void>} A promise that is resolved when the resources are purged
     */

  }, {
    key: "close",
    value: function close() {
      var _this2 = this;

      this._closed = true;
      return Promise.all(Object.keys(this._pools).map(function (key) {
        return _this2._purgeKey(key);
      }));
    }
    /**
     * Keep the idle resources for the provided addresses and purge the rest.
     * @returns {Promise<void>} A promise that is resolved when the other resources are purged
     */

  }, {
    key: "keepAll",
    value: function keepAll(addresses) {
      var _this3 = this;

      var keysToKeep = addresses.map(function (a) {
        return a.asKey();
      });
      var keysPresent = Object.keys(this._pools);
      var keysToPurge = keysPresent.filter(function (k) {
        return keysToKeep.indexOf(k) === -1;
      });
      return Promise.all(keysToPurge.map(function (key) {
        return _this3._purgeKey(key);
      }));
    }
    /**
     * Check if this pool contains resources for the given address.
     * @param {ServerAddress} address the address of the server to check.
     * @return {boolean} `true` when pool contains entries for the given key, <code>false</code> otherwise.
     */

  }, {
    key: "has",
    value: function has(address) {
      return address.asKey() in this._pools;
    }
    /**
     * Get count of active (checked out of the pool) resources for the given key.
     * @param {ServerAddress} address the address of the server to check.
     * @return {number} count of resources acquired by clients.
     */

  }, {
    key: "activeResourceCount",
    value: function activeResourceCount(address) {
      return this._activeResourceCounts[address.asKey()] || 0;
    }
  }, {
    key: "_acquire",
    value: function () {
      var _acquire2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee(address) {
        var key, pool, _resource, numConnections, resource;

        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!this._closed) {
                  _context.next = 2;
                  break;
                }

                throw (0, _error.newError)('Pool is closed, it is no more able to serve requests.');

              case 2:
                key = address.asKey();
                pool = this._pools[key];

                if (!pool) {
                  pool = [];
                  this._pools[key] = pool;
                  this._pendingCreates[key] = 0;
                }

              case 5:
                if (!pool.length) {
                  _context.next = 18;
                  break;
                }

                _resource = pool.pop();

                if (!this._validate(_resource)) {
                  _context.next = 14;
                  break;
                }

                if (this._removeIdleObserver) {
                  this._removeIdleObserver(_resource);
                } // idle resource is valid and can be acquired


                resourceAcquired(key, this._activeResourceCounts);

                if (this._log.isDebugEnabled()) {
                  this._log.debug("".concat(_resource, " acquired from the pool ").concat(key));
                }

                return _context.abrupt("return", _resource);

              case 14:
                _context.next = 16;
                return this._destroy(_resource);

              case 16:
                _context.next = 5;
                break;

              case 18:
                if (!(this._maxSize > 0)) {
                  _context.next = 22;
                  break;
                }

                // Include pending creates when checking pool size since these probably will add
                // to the number when fulfilled.
                numConnections = this.activeResourceCount(address) + this._pendingCreates[key];

                if (!(numConnections >= this._maxSize)) {
                  _context.next = 22;
                  break;
                }

                return _context.abrupt("return", null);

              case 22:
                // there exist no idle valid resources, create a new one for acquisition
                // Keep track of how many pending creates there are to avoid making too many connections.
                this._pendingCreates[key] = this._pendingCreates[key] + 1;
                _context.prev = 23;
                _context.next = 26;
                return this._create(address, this._release);

              case 26:
                resource = _context.sent;
                resourceAcquired(key, this._activeResourceCounts);

                if (this._log.isDebugEnabled()) {
                  this._log.debug("".concat(resource, " created for the pool ").concat(key));
                }

              case 29:
                _context.prev = 29;
                this._pendingCreates[key] = this._pendingCreates[key] - 1;
                return _context.finish(29);

              case 32:
                return _context.abrupt("return", resource);

              case 33:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[23,, 29, 32]]);
      }));

      function _acquire(_x) {
        return _acquire2.apply(this, arguments);
      }

      return _acquire;
    }()
  }, {
    key: "_release",
    value: function () {
      var _release2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee2(address, resource) {
        var _this4 = this;

        var key, pool;
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                key = address.asKey();
                pool = this._pools[key];

                if (!pool) {
                  _context2.next = 14;
                  break;
                }

                if (this._validate(resource)) {
                  _context2.next = 9;
                  break;
                }

                if (this._log.isDebugEnabled()) {
                  this._log.debug("".concat(resource, " destroyed and can't be released to the pool ").concat(key, " because it is not functional"));
                }

                _context2.next = 7;
                return this._destroy(resource);

              case 7:
                _context2.next = 12;
                break;

              case 9:
                if (this._installIdleObserver) {
                  this._installIdleObserver(resource, {
                    onError: function onError(error) {
                      _this4._log.debug("Idle connection ".concat(resource, " destroyed because of error: ").concat(error));

                      var pool = _this4._pools[key];

                      if (pool) {
                        _this4._pools[key] = pool.filter(function (r) {
                          return r !== resource;
                        });
                      } // let's not care about background clean-ups due to errors but just trigger the destroy
                      // process for the resource, we especially catch any errors and ignore them to avoid
                      // unhandled promise rejection warnings


                      _this4._destroy(resource)["catch"](function () {});
                    }
                  });
                }

                pool.push(resource);

                if (this._log.isDebugEnabled()) {
                  this._log.debug("".concat(resource, " released to the pool ").concat(key));
                }

              case 12:
                _context2.next = 17;
                break;

              case 14:
                // key has been purged, don't put it back, just destroy the resource
                if (this._log.isDebugEnabled()) {
                  this._log.debug("".concat(resource, " destroyed and can't be released to the pool ").concat(key, " because pool has been purged"));
                }

                _context2.next = 17;
                return this._destroy(resource);

              case 17:
                resourceReleased(key, this._activeResourceCounts);

                this._processPendingAcquireRequests(address);

              case 19:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function _release(_x2, _x3) {
        return _release2.apply(this, arguments);
      }

      return _release;
    }()
  }, {
    key: "_purgeKey",
    value: function () {
      var _purgeKey2 = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee3(key) {
        var pool, resource;
        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                pool = this._pools[key] || [];

              case 1:
                if (!pool.length) {
                  _context3.next = 8;
                  break;
                }

                resource = pool.pop();

                if (this._removeIdleObserver) {
                  this._removeIdleObserver(resource);
                }

                _context3.next = 6;
                return this._destroy(resource);

              case 6:
                _context3.next = 1;
                break;

              case 8:
                delete this._pools[key];

              case 9:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function _purgeKey(_x4) {
        return _purgeKey2.apply(this, arguments);
      }

      return _purgeKey;
    }()
  }, {
    key: "_processPendingAcquireRequests",
    value: function _processPendingAcquireRequests(address) {
      var _this5 = this;

      var key = address.asKey();
      var requests = this._acquireRequests[key];

      if (requests) {
        var pendingRequest = requests.shift(); // pop a pending acquire request

        if (pendingRequest) {
          this._acquire(address)["catch"](function (error) {
            // failed to acquire/create a new connection to resolve the pending acquire request
            // propagate the error by failing the pending request
            pendingRequest.reject(error);
            return null;
          }).then(function (resource) {
            if (resource) {
              // managed to acquire a valid resource from the pool
              if (pendingRequest.isCompleted()) {
                // request has been completed, most likely failed by a timeout
                // return the acquired resource back to the pool
                _this5._release(address, resource);
              } else {
                // request is still pending and can be resolved with the newly acquired resource
                pendingRequest.resolve(resource); // resolve the pending request with the acquired resource
              }
            }
          });
        } else {
          delete this._acquireRequests[key];
        }
      }
    }
  }]);
  return Pool;
}();
/**
 * Increment active (checked out of the pool) resource counter.
 * @param {string} key the resource group identifier (server address for connections).
 * @param {Object.<string, number>} activeResourceCounts the object holding active counts per key.
 */


function resourceAcquired(key, activeResourceCounts) {
  var currentCount = activeResourceCounts[key] || 0;
  activeResourceCounts[key] = currentCount + 1;
}
/**
 * Decrement active (checked out of the pool) resource counter.
 * @param {string} key the resource group identifier (server address for connections).
 * @param {Object.<string, number>} activeResourceCounts the object holding active counts per key.
 */


function resourceReleased(key, activeResourceCounts) {
  var currentCount = activeResourceCounts[key] || 0;
  var nextCount = currentCount - 1;

  if (nextCount > 0) {
    activeResourceCounts[key] = nextCount;
  } else {
    delete activeResourceCounts[key];
  }
}

var PendingRequest =
/*#__PURE__*/
function () {
  function PendingRequest(key, resolve, reject, timeoutId, log) {
    (0, _classCallCheck2["default"])(this, PendingRequest);
    this._key = key;
    this._resolve = resolve;
    this._reject = reject;
    this._timeoutId = timeoutId;
    this._log = log;
    this._completed = false;
  }

  (0, _createClass2["default"])(PendingRequest, [{
    key: "isCompleted",
    value: function isCompleted() {
      return this._completed;
    }
  }, {
    key: "resolve",
    value: function resolve(resource) {
      if (this._completed) {
        return;
      }

      this._completed = true;
      clearTimeout(this._timeoutId);

      if (this._log.isDebugEnabled()) {
        this._log.debug("".concat(resource, " acquired from the pool ").concat(this._key));
      }

      this._resolve(resource);
    }
  }, {
    key: "reject",
    value: function reject(error) {
      if (this._completed) {
        return;
      }

      this._completed = true;
      clearTimeout(this._timeoutId);

      this._reject(error);
    }
  }]);
  return PendingRequest;
}();

var _default = Pool;
exports["default"] = _default;

},{"../error":231,"./logger":267,"./pool-config":270,"@babel/runtime/helpers/asyncToGenerator":4,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/regenerator":27}],272:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _node = require('./browser');

var _error = require("../error");

var _boltProtocolV = _interopRequireDefault(require("./bolt-protocol-v1"));

var _boltProtocolV2 = _interopRequireDefault(require("./bolt-protocol-v2"));

var _boltProtocolV3 = _interopRequireDefault(require("./bolt-protocol-v3"));

var _boltProtocolV4x = _interopRequireDefault(require("./bolt-protocol-v4x0"));

var _boltProtocolV4x2 = _interopRequireDefault(require("./bolt-protocol-v4x1"));

var _boltProtocolV4x3 = _interopRequireDefault(require("./bolt-protocol-v4x2"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var BOLT_MAGIC_PREAMBLE = 0x6060b017;

var ProtocolHandshaker =
/*#__PURE__*/
function () {
  /**
   * @constructor
   * @param {Connection} connection the connection owning this protocol.
   * @param {Channel} channel the network channel.
   * @param {Chunker} chunker the message chunker.
   * @param {boolean} disableLosslessIntegers flag to use native JS numbers.
   * @param {Logger} log the logger.
   */
  function ProtocolHandshaker(connection, channel, chunker, disableLosslessIntegers, log) {
    var serversideRouting = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
    (0, _classCallCheck2["default"])(this, ProtocolHandshaker);
    this._connection = connection;
    this._channel = channel;
    this._chunker = chunker;
    this._disableLosslessIntegers = disableLosslessIntegers;
    this._log = log;
    this._serversideRouting = serversideRouting;
  }
  /**
   * Write a Bolt handshake into the underlying network channel.
   */


  (0, _createClass2["default"])(ProtocolHandshaker, [{
    key: "writeHandshakeRequest",
    value: function writeHandshakeRequest() {
      this._channel.write(newHandshakeBuffer());
    }
    /**
     * Read the given handshake response and create the negotiated bolt protocol.
     * @param {BaseBuffer} buffer byte buffer containing the handshake response.
     * @return {BoltProtocol} bolt protocol corresponding to the version suggested by the database.
     * @throws {Neo4jError} when bolt protocol can't be instantiated.
     */

  }, {
    key: "createNegotiatedProtocol",
    value: function createNegotiatedProtocol(buffer) {
      var h = [buffer.readUInt8(), buffer.readUInt8(), buffer.readUInt8(), buffer.readUInt8()];

      if (h[0] === 0x48 && h[1] === 0x54 && h[2] === 0x54 && h[3] === 0x50) {
        throw (0, _error.newError)('Server responded HTTP. Make sure you are not trying to connect to the http endpoint ' + '(HTTP defaults to port 7474 whereas BOLT defaults to port 7687)');
      }

      var negotiatedVersion = Number(h[3] + '.' + h[2]);

      if (this._log.isDebugEnabled()) {
        this._log.debug("".concat(this._connection, " negotiated protocol version ").concat(negotiatedVersion));
      }

      return this._createProtocolWithVersion(negotiatedVersion);
    }
    /**
     * @return {BoltProtocol}
     * @private
     */

  }, {
    key: "_createProtocolWithVersion",
    value: function _createProtocolWithVersion(version) {
      switch (version) {
        case 1:
          return new _boltProtocolV["default"](this._connection, this._chunker, this._disableLosslessIntegers);

        case 2:
          return new _boltProtocolV2["default"](this._connection, this._chunker, this._disableLosslessIntegers);

        case 3:
          return new _boltProtocolV3["default"](this._connection, this._chunker, this._disableLosslessIntegers);

        case 4.0:
          return new _boltProtocolV4x["default"](this._connection, this._chunker, this._disableLosslessIntegers);

        case 4.1:
          return new _boltProtocolV4x2["default"](this._connection, this._chunker, this._disableLosslessIntegers, this._serversideRouting);

        case 4.2:
          return new _boltProtocolV4x3["default"](this._connection, this._chunker, this._disableLosslessIntegers, this._serversideRouting);

        default:
          throw (0, _error.newError)('Unknown Bolt protocol version: ' + version);
      }
    }
  }]);
  return ProtocolHandshaker;
}();
/**
 * @return {BaseBuffer}
 * @private
 */


exports["default"] = ProtocolHandshaker;

function newHandshakeBuffer() {
  var handshakeBuffer = (0, _node.alloc)(5 * 4); // magic preamble

  handshakeBuffer.writeInt32(BOLT_MAGIC_PREAMBLE); // proposed versions

  handshakeBuffer.writeInt32(2 << 8 | 4);
  handshakeBuffer.writeInt32(1 << 8 | 4);
  handshakeBuffer.writeInt32(4);
  handshakeBuffer.writeInt32(3); // reset the reader position

  handshakeBuffer.reset();
  return handshakeBuffer;
}

},{"../error":231,"./bolt-protocol-v1":236,"./bolt-protocol-v2":237,"./bolt-protocol-v3":238,"./bolt-protocol-v4x0":239,"./bolt-protocol-v4x1":240,"./bolt-protocol-v4x2":241,"./browser":247,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":12}],273:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _routingTable = _interopRequireDefault(require("./routing-table"));

var _routingUtil = _interopRequireDefault(require("./routing-util"));

var _error = require("../error");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Rediscovery =
/*#__PURE__*/
function () {
  /**
   * @constructor
   * @param {RoutingUtil} routingUtil the util to use.
   */
  function Rediscovery(routingUtil) {
    (0, _classCallCheck2["default"])(this, Rediscovery);
    this._routingUtil = routingUtil;
  }
  /**
   * Try to fetch new routing table from the given router.
   * @param {Session} session the session to use.
   * @param {string} database the database for which to lookup routing table.
   * @param {string} routerAddress the URL of the router.
   * @return {Promise<RoutingTable>} promise resolved with new routing table or null when connection error happened.
   */


  (0, _createClass2["default"])(Rediscovery, [{
    key: "lookupRoutingTableOnRouter",
    value: function () {
      var _lookupRoutingTableOnRouter = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee(session, database, routerAddress) {
        var records, record, expirationTime, _this$_routingUtil$pa, routers, readers, writers;

        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this._routingUtil.callRoutingProcedure(session, database, routerAddress);

              case 2:
                records = _context.sent;

                if (!(records === null)) {
                  _context.next = 5;
                  break;
                }

                return _context.abrupt("return", null);

              case 5:
                if (!(records.length !== 1)) {
                  _context.next = 7;
                  break;
                }

                throw (0, _error.newError)('Illegal response from router "' + routerAddress + '". ' + 'Received ' + records.length + ' records but expected only one.\n' + JSON.stringify(records), _error.PROTOCOL_ERROR);

              case 7:
                record = records[0];
                expirationTime = this._routingUtil.parseTtl(record, routerAddress);
                _this$_routingUtil$pa = this._routingUtil.parseServers(record, routerAddress), routers = _this$_routingUtil$pa.routers, readers = _this$_routingUtil$pa.readers, writers = _this$_routingUtil$pa.writers;

                Rediscovery._assertNonEmpty(routers, 'routers', routerAddress);

                Rediscovery._assertNonEmpty(readers, 'readers', routerAddress); // case with no writers is processed higher in the promise chain because only RoutingDriver knows
                // how to deal with such table and how to treat router that returned such table


                return _context.abrupt("return", new _routingTable["default"]({
                  database: database,
                  routers: routers,
                  readers: readers,
                  writers: writers,
                  expirationTime: expirationTime
                }));

              case 13:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function lookupRoutingTableOnRouter(_x, _x2, _x3) {
        return _lookupRoutingTableOnRouter.apply(this, arguments);
      }

      return lookupRoutingTableOnRouter;
    }()
  }], [{
    key: "_assertNonEmpty",
    value: function _assertNonEmpty(serverAddressesArray, serversName, routerAddress) {
      if (serverAddressesArray.length === 0) {
        throw (0, _error.newError)('Received no ' + serversName + ' from router ' + routerAddress, _error.PROTOCOL_ERROR);
      }
    }
  }]);
  return Rediscovery;
}();

exports["default"] = Rediscovery;

},{"../error":231,"./routing-table":279,"./routing-util":280,"@babel/runtime/helpers/asyncToGenerator":4,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/regenerator":27}],274:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.ALL = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _constants = require("./constants");

var _integer = require("../integer");

var _util = require("./util");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* eslint-disable no-unused-vars */
// Signature bytes for each request message type
var INIT = 0x01; // 0000 0001 // INIT <user_agent> <authentication_token>

var ACK_FAILURE = 0x0e; // 0000 1110 // ACK_FAILURE - unused

var RESET = 0x0f; // 0000 1111 // RESET

var RUN = 0x10; // 0001 0000 // RUN <query> <parameters>

var DISCARD_ALL = 0x2f; // 0010 1111 // DISCARD_ALL - unused

var PULL_ALL = 0x3f; // 0011 1111 // PULL_ALL

var HELLO = 0x01; // 0000 0001 // HELLO <metadata>

var GOODBYE = 0x02; // 0000 0010 // GOODBYE

var BEGIN = 0x11; // 0001 0001 // BEGIN <metadata>

var COMMIT = 0x12; // 0001 0010 // COMMIT

var ROLLBACK = 0x13; // 0001 0011 // ROLLBACK

var DISCARD = 0x2f; // 0010 1111 // DISCARD

var PULL = 0x3f; // 0011 1111 // PULL

var READ_MODE = 'r';
/* eslint-enable no-unused-vars */

var NO_STATEMENT_ID = -1;
var ALL = -1;
exports.ALL = ALL;

var RequestMessage =
/*#__PURE__*/
function () {
  function RequestMessage(signature, fields, toString) {
    (0, _classCallCheck2["default"])(this, RequestMessage);
    this.signature = signature;
    this.fields = fields;
    this.toString = toString;
  }
  /**
   * Create a new INIT message.
   * @param {string} clientName the client name.
   * @param {Object} authToken the authentication token.
   * @return {RequestMessage} new INIT message.
   */


  (0, _createClass2["default"])(RequestMessage, null, [{
    key: "init",
    value: function init(clientName, authToken) {
      return new RequestMessage(INIT, [clientName, authToken], function () {
        return "INIT ".concat(clientName, " {...}");
      });
    }
    /**
     * Create a new RUN message.
     * @param {string} query the cypher query.
     * @param {Object} parameters the query parameters.
     * @return {RequestMessage} new RUN message.
     */

  }, {
    key: "run",
    value: function run(query, parameters) {
      return new RequestMessage(RUN, [query, parameters], function () {
        return "RUN ".concat(query, " ").concat(JSON.stringify(parameters));
      });
    }
    /**
     * Get a PULL_ALL message.
     * @return {RequestMessage} the PULL_ALL message.
     */

  }, {
    key: "pullAll",
    value: function pullAll() {
      return PULL_ALL_MESSAGE;
    }
    /**
     * Get a RESET message.
     * @return {RequestMessage} the RESET message.
     */

  }, {
    key: "reset",
    value: function reset() {
      return RESET_MESSAGE;
    }
    /**
     * Create a new HELLO message.
     * @param {string} userAgent the user agent.
     * @param {Object} authToken the authentication token.
     * @param {Object} optional server side routing, set to routing context to turn on server side routing (> 4.1)
     * @return {RequestMessage} new HELLO message.
     */

  }, {
    key: "hello",
    value: function hello(userAgent, authToken) {
      var routing = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var metadata = Object.assign({
        user_agent: userAgent
      }, authToken);

      if (routing != null) {
        metadata.routing = routing;
      }

      return new RequestMessage(HELLO, [metadata], function () {
        return "HELLO {user_agent: '".concat(userAgent, "', ...}");
      });
    }
    /**
     * Create a new BEGIN message.
     * @param {Bookmark} bookmark the bookmark.
     * @param {TxConfig} txConfig the configuration.
     * @param {string} database the database name.
     * @param {string} mode the access mode.
     * @return {RequestMessage} new BEGIN message.
     */

  }, {
    key: "begin",
    value: function begin() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          bookmark = _ref.bookmark,
          txConfig = _ref.txConfig,
          database = _ref.database,
          mode = _ref.mode;

      var metadata = buildTxMetadata(bookmark, txConfig, database, mode);
      return new RequestMessage(BEGIN, [metadata], function () {
        return "BEGIN ".concat(JSON.stringify(metadata));
      });
    }
    /**
     * Get a COMMIT message.
     * @return {RequestMessage} the COMMIT message.
     */

  }, {
    key: "commit",
    value: function commit() {
      return COMMIT_MESSAGE;
    }
    /**
     * Get a ROLLBACK message.
     * @return {RequestMessage} the ROLLBACK message.
     */

  }, {
    key: "rollback",
    value: function rollback() {
      return ROLLBACK_MESSAGE;
    }
    /**
     * Create a new RUN message with additional metadata.
     * @param {string} query the cypher query.
     * @param {Object} parameters the query parameters.
     * @param {Bookmark} bookmark the bookmark.
     * @param {TxConfig} txConfig the configuration.
     * @param {string} database the database name.
     * @param {string} mode the access mode.
     * @return {RequestMessage} new RUN message with additional metadata.
     */

  }, {
    key: "runWithMetadata",
    value: function runWithMetadata(query, parameters) {
      var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
          bookmark = _ref2.bookmark,
          txConfig = _ref2.txConfig,
          database = _ref2.database,
          mode = _ref2.mode;

      var metadata = buildTxMetadata(bookmark, txConfig, database, mode);
      return new RequestMessage(RUN, [query, parameters, metadata], function () {
        return "RUN ".concat(query, " ").concat(JSON.stringify(parameters), " ").concat(JSON.stringify(metadata));
      });
    }
    /**
     * Get a GOODBYE message.
     * @return {RequestMessage} the GOODBYE message.
     */

  }, {
    key: "goodbye",
    value: function goodbye() {
      return GOODBYE_MESSAGE;
    }
    /**
     * Generates a new PULL message with additional metadata.
     * @param {Integer|number} stmtId
     * @param {Integer|number} n
     * @return {RequestMessage} the PULL message.
     */

  }, {
    key: "pull",
    value: function pull() {
      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref3$stmtId = _ref3.stmtId,
          stmtId = _ref3$stmtId === void 0 ? NO_STATEMENT_ID : _ref3$stmtId,
          _ref3$n = _ref3.n,
          n = _ref3$n === void 0 ? ALL : _ref3$n;

      var metadata = buildStreamMetadata(stmtId || NO_STATEMENT_ID, n || ALL);
      return new RequestMessage(PULL, [metadata], function () {
        return "PULL ".concat(JSON.stringify(metadata));
      });
    }
    /**
     * Generates a new DISCARD message with additional metadata.
     * @param {Integer|number} stmtId
     * @param {Integer|number} n
     * @return {RequestMessage} the PULL message.
     */

  }, {
    key: "discard",
    value: function discard() {
      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref4$stmtId = _ref4.stmtId,
          stmtId = _ref4$stmtId === void 0 ? NO_STATEMENT_ID : _ref4$stmtId,
          _ref4$n = _ref4.n,
          n = _ref4$n === void 0 ? ALL : _ref4$n;

      var metadata = buildStreamMetadata(stmtId || NO_STATEMENT_ID, n || ALL);
      return new RequestMessage(DISCARD, [metadata], function () {
        return "DISCARD ".concat(JSON.stringify(metadata));
      });
    }
  }]);
  return RequestMessage;
}();
/**
 * Create an object that represent transaction metadata.
 * @param {Bookmark} bookmark the bookmark.
 * @param {TxConfig} txConfig the configuration.
 * @param {string} database the database name.
 * @param {string} mode the access mode.
 * @return {Object} a metadata object.
 */


exports["default"] = RequestMessage;

function buildTxMetadata(bookmark, txConfig, database, mode) {
  var metadata = {};

  if (!bookmark.isEmpty()) {
    metadata.bookmarks = bookmark.values();
  }

  if (txConfig.timeout) {
    metadata.tx_timeout = txConfig.timeout;
  }

  if (txConfig.metadata) {
    metadata.tx_metadata = txConfig.metadata;
  }

  if (database) {
    metadata.db = (0, _util.assertString)(database, 'database');
  }

  if (mode === _constants.ACCESS_MODE_READ) {
    metadata.mode = READ_MODE;
  }

  return metadata;
}
/**
 * Create an object that represents streaming metadata.
 * @param {Integer|number} stmtId The query id to stream its results.
 * @param {Integer|number} n The number of records to stream.
 * @returns {Object} a metadata object.
 */


function buildStreamMetadata(stmtId, n) {
  var metadata = {
    n: (0, _integer["int"])(n)
  };

  if (stmtId !== NO_STATEMENT_ID) {
    metadata.qid = (0, _integer["int"])(stmtId);
  }

  return metadata;
} // constants for messages that never change


var PULL_ALL_MESSAGE = new RequestMessage(PULL_ALL, [], function () {
  return 'PULL_ALL';
});
var RESET_MESSAGE = new RequestMessage(RESET, [], function () {
  return 'RESET';
});
var COMMIT_MESSAGE = new RequestMessage(COMMIT, [], function () {
  return 'COMMIT';
});
var ROLLBACK_MESSAGE = new RequestMessage(ROLLBACK, [], function () {
  return 'ROLLBACK';
});
var GOODBYE_MESSAGE = new RequestMessage(GOODBYE, [], function () {
  return 'GOODBYE';
});

},{"../integer":234,"./constants":264,"./util":288,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":12}],275:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var BaseHostNameResolver =
/*#__PURE__*/
function () {
  function BaseHostNameResolver() {
    (0, _classCallCheck2["default"])(this, BaseHostNameResolver);
  }

  (0, _createClass2["default"])(BaseHostNameResolver, [{
    key: "resolve",
    value: function resolve() {
      throw new Error('Abstract function');
    }
    /**
     * @protected
     */

  }, {
    key: "_resolveToItself",
    value: function _resolveToItself(address) {
      return Promise.resolve([address]);
    }
  }]);
  return BaseHostNameResolver;
}();

exports["default"] = BaseHostNameResolver;

},{"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":12}],276:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _serverAddress = _interopRequireDefault(require("../server-address"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function resolveToSelf(address) {
  return Promise.resolve([address]);
}

var ConfiguredCustomResolver =
/*#__PURE__*/
function () {
  function ConfiguredCustomResolver(resolverFunction) {
    (0, _classCallCheck2["default"])(this, ConfiguredCustomResolver);
    this._resolverFunction = resolverFunction || resolveToSelf;
  }

  (0, _createClass2["default"])(ConfiguredCustomResolver, [{
    key: "resolve",
    value: function resolve(seedRouter) {
      var _this = this;

      return new Promise(function (resolve) {
        return resolve(_this._resolverFunction(seedRouter.asHostPort()));
      }).then(function (resolved) {
        if (!Array.isArray(resolved)) {
          throw new TypeError('Configured resolver function should either return an array of addresses or a Promise resolved with an array of addresses.' + "Each address is '<host>:<port>'. Got: ".concat(resolved));
        }

        return resolved.map(function (r) {
          return _serverAddress["default"].fromUrl(r);
        });
      });
    }
  }]);
  return ConfiguredCustomResolver;
}();

exports["default"] = ConfiguredCustomResolver;

},{"../server-address":281,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":12}],277:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _error = require("../error");

var _rxjs = require("rxjs");

var _operators = require("rxjs/operators");

var _logger = _interopRequireDefault(require("./logger"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var DEFAULT_MAX_RETRY_TIME_MS = 30 * 1000; // 30 seconds

var DEFAULT_INITIAL_RETRY_DELAY_MS = 1000; // 1 seconds

var DEFAULT_RETRY_DELAY_MULTIPLIER = 2.0;
var DEFAULT_RETRY_DELAY_JITTER_FACTOR = 0.2;

var RxRetryLogic =
/*#__PURE__*/
function () {
  /**
   *
   * @param {Object} args
   * @param {Logger} args.logger
   */
  function RxRetryLogic() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$maxRetryTimeout = _ref.maxRetryTimeout,
        maxRetryTimeout = _ref$maxRetryTimeout === void 0 ? DEFAULT_MAX_RETRY_TIME_MS : _ref$maxRetryTimeout,
        _ref$initialDelay = _ref.initialDelay,
        initialDelay = _ref$initialDelay === void 0 ? DEFAULT_INITIAL_RETRY_DELAY_MS : _ref$initialDelay,
        _ref$delayMultiplier = _ref.delayMultiplier,
        delayMultiplier = _ref$delayMultiplier === void 0 ? DEFAULT_RETRY_DELAY_MULTIPLIER : _ref$delayMultiplier,
        _ref$delayJitter = _ref.delayJitter,
        delayJitter = _ref$delayJitter === void 0 ? DEFAULT_RETRY_DELAY_JITTER_FACTOR : _ref$delayJitter,
        _ref$logger = _ref.logger,
        logger = _ref$logger === void 0 ? null : _ref$logger;

    (0, _classCallCheck2["default"])(this, RxRetryLogic);
    this._maxRetryTimeout = valueOrDefault(maxRetryTimeout, DEFAULT_MAX_RETRY_TIME_MS);
    this._initialDelay = valueOrDefault(initialDelay, DEFAULT_INITIAL_RETRY_DELAY_MS);
    this._delayMultiplier = valueOrDefault(delayMultiplier, DEFAULT_RETRY_DELAY_MULTIPLIER);
    this._delayJitter = valueOrDefault(delayJitter, DEFAULT_RETRY_DELAY_JITTER_FACTOR);
    this._logger = logger;
  }
  /**
   *
   * @param {Observable<Any>} work
   */


  (0, _createClass2["default"])(RxRetryLogic, [{
    key: "retry",
    value: function retry(work) {
      var _this = this;

      return work.pipe((0, _operators.retryWhen)(function (failedWork) {
        var handledExceptions = [];
        var startTime = Date.now();
        var retryCount = 1;
        var delayDuration = _this._initialDelay;
        return failedWork.pipe((0, _operators.flatMap)(function (err) {
          if (!RxRetryLogic._canRetryOn(err)) {
            return (0, _rxjs.throwError)(err);
          }

          handledExceptions.push(err);

          if (retryCount >= 2 && Date.now() - startTime >= _this._maxRetryTimeout) {
            var error = (0, _error.newError)("Failed after retried for ".concat(retryCount, " times in ").concat(_this._maxRetryTimeout, " ms. Make sure that your database is online and retry again."), _error.SERVICE_UNAVAILABLE);
            error.seenErrors = handledExceptions;
            return (0, _rxjs.throwError)(error);
          }

          var nextDelayDuration = _this._computeNextDelay(delayDuration);

          delayDuration = delayDuration * _this._delayMultiplier;
          retryCount++;

          if (_this._logger) {
            _this._logger.warn("Transaction failed and will be retried in ".concat(nextDelayDuration));
          }

          return (0, _rxjs.of)(1).pipe((0, _operators.delay)(nextDelayDuration));
        }));
      }));
    }
  }, {
    key: "_computeNextDelay",
    value: function _computeNextDelay(delay) {
      var jitter = delay * this._delayJitter;
      return delay - jitter + 2 * jitter * Math.random();
    }
  }], [{
    key: "_canRetryOn",
    value: function _canRetryOn(error) {
      return error && error.code && (error.code === _error.SERVICE_UNAVAILABLE || error.code === _error.SESSION_EXPIRED || this._isTransientError(error));
    }
  }, {
    key: "_isTransientError",
    value: function _isTransientError(error) {
      // Retries should not happen when transaction was explicitly terminated by the user.
      // Termination of transaction might result in two different error codes depending on where it was
      // terminated. These are really client errors but classification on the server is not entirely correct and
      // they are classified as transient.
      var code = error.code;

      if (code.indexOf('TransientError') >= 0) {
        if (code === 'Neo.TransientError.Transaction.Terminated' || code === 'Neo.TransientError.Transaction.LockClientStopped') {
          return false;
        }

        return true;
      }

      return false;
    }
  }]);
  return RxRetryLogic;
}();

exports["default"] = RxRetryLogic;

function valueOrDefault(value, defaultValue) {
  if (value || value === 0) {
    return value;
  }

  return defaultValue;
}

},{"../error":231,"./logger":267,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":12,"rxjs":28,"rxjs/operators":227}],278:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var RoundRobinArrayIndex =
/*#__PURE__*/
function () {
  /**
   * @constructor
   * @param {number} [initialOffset=0] the initial offset for round robin.
   */
  function RoundRobinArrayIndex(initialOffset) {
    (0, _classCallCheck2["default"])(this, RoundRobinArrayIndex);
    this._offset = initialOffset || 0;
  }
  /**
   * Get next index for an array with given length.
   * @param {number} arrayLength the array length.
   * @return {number} index in the array.
   */


  (0, _createClass2["default"])(RoundRobinArrayIndex, [{
    key: "next",
    value: function next(arrayLength) {
      if (arrayLength === 0) {
        return -1;
      }

      var nextOffset = this._offset;
      this._offset += 1;

      if (this._offset === Number.MAX_SAFE_INTEGER) {
        this._offset = 0;
      }

      return nextOffset % arrayLength;
    }
  }]);
  return RoundRobinArrayIndex;
}();

exports["default"] = RoundRobinArrayIndex;

},{"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":12}],279:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _integer = require("../integer");

var _driver = require("../driver");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var MIN_ROUTERS = 1;

var RoutingTable =
/*#__PURE__*/
function () {
  function RoutingTable() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        database = _ref.database,
        routers = _ref.routers,
        readers = _ref.readers,
        writers = _ref.writers,
        expirationTime = _ref.expirationTime;

    (0, _classCallCheck2["default"])(this, RoutingTable);
    this.database = database;
    this.databaseName = database || 'default database';
    this.routers = routers || [];
    this.readers = readers || [];
    this.writers = writers || [];
    this.expirationTime = expirationTime || (0, _integer["int"])(0);
  }

  (0, _createClass2["default"])(RoutingTable, [{
    key: "forget",
    value: function forget(address) {
      // Don't remove it from the set of routers, since that might mean we lose our ability to re-discover,
      // just remove it from the set of readers and writers, so that we don't use it for actual work without
      // performing discovery first.
      this.readers = removeFromArray(this.readers, address);
      this.writers = removeFromArray(this.writers, address);
    }
  }, {
    key: "forgetRouter",
    value: function forgetRouter(address) {
      this.routers = removeFromArray(this.routers, address);
    }
  }, {
    key: "forgetWriter",
    value: function forgetWriter(address) {
      this.writers = removeFromArray(this.writers, address);
    }
    /**
     * Check if this routing table is fresh to perform the required operation.
     * @param {string} accessMode the type of operation. Allowed values are {@link READ} and {@link WRITE}.
     * @return {boolean} `true` when this table contains servers to serve the required operation, `false` otherwise.
     */

  }, {
    key: "isStaleFor",
    value: function isStaleFor(accessMode) {
      return this.expirationTime.lessThan(Date.now()) || this.routers.length < MIN_ROUTERS || accessMode === _driver.READ && this.readers.length === 0 || accessMode === _driver.WRITE && this.writers.length === 0;
    }
    /**
     * Check if this routing table is expired for specified amount of duration
     *
     * @param {Integer} duration amount of duration in milliseconds to check for expiration
     * @returns {boolean}
     */

  }, {
    key: "isExpiredFor",
    value: function isExpiredFor(duration) {
      return this.expirationTime.add(duration).lessThan(Date.now());
    }
  }, {
    key: "allServers",
    value: function allServers() {
      return [].concat((0, _toConsumableArray2["default"])(this.routers), (0, _toConsumableArray2["default"])(this.readers), (0, _toConsumableArray2["default"])(this.writers));
    }
  }, {
    key: "toString",
    value: function toString() {
      return 'RoutingTable[' + "database=".concat(this.databaseName, ", ") + "expirationTime=".concat(this.expirationTime, ", ") + "currentTime=".concat(Date.now(), ", ") + "routers=[".concat(this.routers, "], ") + "readers=[".concat(this.readers, "], ") + "writers=[".concat(this.writers, "]]");
    }
  }]);
  return RoutingTable;
}();
/**
 * Remove all occurrences of the element in the array.
 * @param {Array} array the array to filter.
 * @param {Object} element the element to remove.
 * @return {Array} new filtered array.
 */


exports["default"] = RoutingTable;

function removeFromArray(array, element) {
  return array.filter(function (item) {
    return item.asKey() !== element.asKey();
  });
}

},{"../driver":230,"../integer":234,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/toConsumableArray":23}],280:[function(require,module,exports){
"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _error = require("../error");

var _integer = _interopRequireWildcard(require("../integer"));

var _serverVersion = require("./server-version");

var _bookmark = _interopRequireDefault(require("./bookmark"));

var _session = _interopRequireDefault(require("../session"));

var _txConfig = _interopRequireDefault(require("./tx-config"));

var _serverAddress = _interopRequireDefault(require("./server-address"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var CONTEXT = 'context';
var CALL_GET_ROUTING_TABLE = "CALL dbms.cluster.routing.getRoutingTable($".concat(CONTEXT, ")");
var DATABASE = 'database';
var CALL_GET_ROUTING_TABLE_MULTI_DB = "CALL dbms.routing.getRoutingTable($".concat(CONTEXT, ", $").concat(DATABASE, ")");
var PROCEDURE_NOT_FOUND_CODE = 'Neo.ClientError.Procedure.ProcedureNotFound';
var DATABASE_NOT_FOUND_CODE = 'Neo.ClientError.Database.DatabaseNotFound';

var RoutingUtil =
/*#__PURE__*/
function () {
  function RoutingUtil(routingContext, initialAddress) {
    (0, _classCallCheck2["default"])(this, RoutingUtil);
    this._routingContext = routingContext; // The address that the driver is connecting to, used by routing as a fallback when routing
    // and clustering isn't configured.

    this._initialAddress = initialAddress;
  }
  /**
   * Invoke routing procedure using the given session.
   * @param {Session} session the session to use.
   * @param {string} routerAddress the URL of the router.
   * @return {Promise<Record[]>} promise resolved with records returned by the procedure call or null if
   * connection error happened.
   */


  (0, _createClass2["default"])(RoutingUtil, [{
    key: "callRoutingProcedure",
    value: function () {
      var _callRoutingProcedure = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee(session, database, routerAddress) {
        var result;
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.prev = 0;
                _context.next = 3;
                return this._callAvailableRoutingProcedure(session, database);

              case 3:
                result = _context.sent;
                _context.next = 6;
                return session.close();

              case 6:
                return _context.abrupt("return", result.records);

              case 9:
                _context.prev = 9;
                _context.t0 = _context["catch"](0);

                if (!(_context.t0.code === DATABASE_NOT_FOUND_CODE)) {
                  _context.next = 15;
                  break;
                }

                throw _context.t0;

              case 15:
                if (!(_context.t0.code === PROCEDURE_NOT_FOUND_CODE)) {
                  _context.next = 19;
                  break;
                }

                throw (0, _error.newError)("Server at ".concat(routerAddress.asHostPort(), " can't perform routing. Make sure you are connecting to a causal cluster"), _error.SERVICE_UNAVAILABLE);

              case 19:
                return _context.abrupt("return", null);

              case 20:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[0, 9]]);
      }));

      function callRoutingProcedure(_x, _x2, _x3) {
        return _callRoutingProcedure.apply(this, arguments);
      }

      return callRoutingProcedure;
    }()
  }, {
    key: "parseTtl",
    value: function parseTtl(record, routerAddress) {
      try {
        var now = (0, _integer["int"])(Date.now());
        var expires = (0, _integer["int"])(record.get('ttl')).multiply(1000).add(now); // if the server uses a really big expire time like Long.MAX_VALUE this may have overflowed

        if (expires.lessThan(now)) {
          return _integer["default"].MAX_VALUE;
        }

        return expires;
      } catch (error) {
        throw (0, _error.newError)("Unable to parse TTL entry from router ".concat(routerAddress, " from record:\n").concat(JSON.stringify(record), "\nError message: ").concat(error.message), _error.PROTOCOL_ERROR);
      }
    }
  }, {
    key: "parseServers",
    value: function parseServers(record, routerAddress) {
      try {
        var servers = record.get('servers');
        var routers = [];
        var readers = [];
        var writers = [];
        servers.forEach(function (server) {
          var role = server.role;
          var addresses = server.addresses;

          if (role === 'ROUTE') {
            routers = parseArray(addresses).map(function (address) {
              return _serverAddress["default"].fromUrl(address);
            });
          } else if (role === 'WRITE') {
            writers = parseArray(addresses).map(function (address) {
              return _serverAddress["default"].fromUrl(address);
            });
          } else if (role === 'READ') {
            readers = parseArray(addresses).map(function (address) {
              return _serverAddress["default"].fromUrl(address);
            });
          } else {
            throw (0, _error.newError)('Unknown server role "' + role + '"', _error.PROTOCOL_ERROR);
          }
        });
        return {
          routers: routers,
          readers: readers,
          writers: writers
        };
      } catch (error) {
        throw (0, _error.newError)("Unable to parse servers entry from router ".concat(routerAddress, " from record:\n").concat(JSON.stringify(record), "\nError message: ").concat(error.message), _error.PROTOCOL_ERROR);
      }
    }
  }, {
    key: "_callAvailableRoutingProcedure",
    value: function _callAvailableRoutingProcedure(session, database) {
      var _this = this;

      return session._run(null, null, function (connection) {
        var query;
        var params;
        var protocolVersion = connection.protocol().version;

        if (protocolVersion >= 4.0) {
          query = CALL_GET_ROUTING_TABLE_MULTI_DB;
          params = {
            context: _this._routingContext || {},
            database: database || null
          };
          params.context.address = _this._initialAddress;
        } else {
          query = CALL_GET_ROUTING_TABLE;
          params = {
            context: _this._routingContext
          };
        }

        return connection.protocol().run(query, params, {
          bookmark: session._lastBookmark,
          txConfig: _txConfig["default"].empty(),
          mode: session._mode,
          database: session._database,
          afterComplete: session._onComplete
        });
      });
    }
  }]);
  return RoutingUtil;
}();

exports["default"] = RoutingUtil;

function parseArray(addresses) {
  if (!Array.isArray(addresses)) {
    throw new TypeError('Array expected but got: ' + addresses);
  }

  return Array.from(addresses);
}

},{"../error":231,"../integer":234,"../session":295,"./bookmark":242,"./server-address":281,"./server-version":282,"./tx-config":286,"@babel/runtime/helpers/asyncToGenerator":4,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/interopRequireWildcard":13,"@babel/runtime/regenerator":27}],281:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _util = require("./util");

var _urlUtil = _interopRequireDefault(require("./url-util"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var ServerAddress =
/*#__PURE__*/
function () {
  function ServerAddress(host, resolved, port, hostPort) {
    (0, _classCallCheck2["default"])(this, ServerAddress);
    this._host = (0, _util.assertString)(host, 'host');
    this._resolved = resolved ? (0, _util.assertString)(resolved, 'resolved') : null;
    this._port = (0, _util.assertNumber)(port, 'port');
    this._hostPort = hostPort;
    this._stringValue = resolved ? "".concat(hostPort, "(").concat(resolved, ")") : "".concat(hostPort);
  }

  (0, _createClass2["default"])(ServerAddress, [{
    key: "host",
    value: function host() {
      return this._host;
    }
  }, {
    key: "resolvedHost",
    value: function resolvedHost() {
      return this._resolved ? this._resolved : this._host;
    }
  }, {
    key: "port",
    value: function port() {
      return this._port;
    }
  }, {
    key: "resolveWith",
    value: function resolveWith(resolved) {
      return new ServerAddress(this._host, resolved, this._port, this._hostPort);
    }
  }, {
    key: "asHostPort",
    value: function asHostPort() {
      return this._hostPort;
    }
  }, {
    key: "asKey",
    value: function asKey() {
      return this._hostPort;
    }
  }, {
    key: "toString",
    value: function toString() {
      return this._stringValue;
    }
  }], [{
    key: "fromUrl",
    value: function fromUrl(url) {
      var urlParsed = _urlUtil["default"].parseDatabaseUrl(url);

      return new ServerAddress(urlParsed.host, null, urlParsed.port, urlParsed.hostAndPort);
    }
  }]);
  return ServerAddress;
}();

exports["default"] = ServerAddress;

},{"./url-util":287,"./util":288,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":12}],282:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VERSION_IN_DEV = exports.VERSION_4_0_0 = exports.VERSION_3_5_0 = exports.VERSION_3_4_0 = exports.VERSION_3_2_0 = exports.ServerVersion = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _util = require("./util");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var SERVER_VERSION_REGEX = new RegExp('^(Neo4j/)?(\\d+)\\.(\\d+)(?:\\.)?(\\d*)(\\.|-|\\+)?([0-9A-Za-z-.]*)?$');
var NEO4J_IN_DEV_VERSION_STRING = 'Neo4j/dev';

var ServerVersion =
/*#__PURE__*/
function () {
  /**
   * @constructor
   * @param {number} major the major version number.
   * @param {number} minor the minor version number.
   * @param {number} patch the patch version number.
   * @param {string} the original version string
   */
  function ServerVersion(major, minor, patch, originalVersionString) {
    (0, _classCallCheck2["default"])(this, ServerVersion);
    this.major = major;
    this.minor = minor;
    this.patch = patch;
    this._originalVersionString = originalVersionString;
  }
  /**
   * Fetch server version using the given driver.
   * @param {Driver} driver the driver to use.
   * @return {Promise<ServerVersion>} promise resolved with a {@link ServerVersion} object or rejected with error.
   */


  (0, _createClass2["default"])(ServerVersion, [{
    key: "compareTo",

    /**
     * Compare this version to the given one.
     * @param {ServerVersion} other the version to compare with.
     * @return {number} value 0 if this version is the same as the given one, value less then 0 when this version
     * was released earlier than the given one and value greater then 0 when this version was released after
     * than the given one.
     */
    value: function compareTo(other) {
      var result = compareInts(this.major, other.major);

      if (result === 0) {
        result = compareInts(this.minor, other.minor);

        if (result === 0) {
          result = compareInts(this.patch, other.patch);
        }
      }

      return result;
    }
  }, {
    key: "toString",
    value: function toString() {
      if (this._originalVersionString) {
        return this._originalVersionString;
      }

      return "".concat(this.major, ".").concat(this.minor, ".").concat(this.patch);
    }
  }], [{
    key: "fromDriver",
    value: function fromDriver(driver) {
      var session = driver.session();
      return session.run('RETURN 1').then(function (result) {
        return session.close().then(function () {
          return ServerVersion.fromString(result.summary.server.version);
        });
      });
    }
    /**
     * Parse given string to a {@link ServerVersion} object.
     * @param {string} versionStr the string to parse.
     * @return {ServerVersion} version for the given string.
     * @throws Error if given string can't be parsed.
     */

  }, {
    key: "fromString",
    value: function fromString(versionStr) {
      if (!versionStr) {
        return new ServerVersion(3, 0, 0);
      }

      (0, _util.assertString)(versionStr, 'Neo4j version string');

      if (versionStr.toLowerCase() === NEO4J_IN_DEV_VERSION_STRING.toLowerCase()) {
        return VERSION_IN_DEV;
      }

      var version = versionStr.match(SERVER_VERSION_REGEX);

      if (!version) {
        throw new Error("Unparsable Neo4j version: ".concat(versionStr));
      }

      var major = parseIntStrict(version[2]);
      var minor = parseIntStrict(version[3]);
      var patch = parseIntStrict(version[4] || 0);
      return new ServerVersion(major, minor, patch, versionStr);
    }
  }]);
  return ServerVersion;
}();

exports.ServerVersion = ServerVersion;

function parseIntStrict(str, name) {
  var value = parseInt(str, 10);

  if (!value && value !== 0) {
    throw new Error("Unparsable number ".concat(name, ": '").concat(str, "'"));
  }

  return value;
}

function compareInts(x, y) {
  return x < y ? -1 : x === y ? 0 : 1;
}

var VERSION_3_2_0 = ServerVersion.fromString('Neo4j/3.2.0');
exports.VERSION_3_2_0 = VERSION_3_2_0;
var VERSION_3_4_0 = ServerVersion.fromString('Neo4j/3.4.0');
exports.VERSION_3_4_0 = VERSION_3_4_0;
var VERSION_3_5_0 = ServerVersion.fromString('Neo4j/3.5.0');
exports.VERSION_3_5_0 = VERSION_3_5_0;
var VERSION_4_0_0 = ServerVersion.fromString('Neo4j/4.0.0');
exports.VERSION_4_0_0 = VERSION_4_0_0;
var maxVer = Number.MAX_SAFE_INTEGER;
var VERSION_IN_DEV = new ServerVersion(maxVer, maxVer, maxVer, NEO4J_IN_DEV_VERSION_STRING);
exports.VERSION_IN_DEV = VERSION_IN_DEV;

},{"./util":288,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":12}],283:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CompletedObserver = exports.FailedObserver = exports.ResetObserver = exports.LoginObserver = exports.ResultStreamObserver = exports.StreamObserver = void 0;

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _record = _interopRequireDefault(require("../record"));

var _connection = _interopRequireDefault(require("./connection"));

var _error = require("../error");

var _integer = _interopRequireDefault(require("../integer"));

var _requestMessage = require("./request-message");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var StreamObserver =
/*#__PURE__*/
function () {
  function StreamObserver() {
    (0, _classCallCheck2["default"])(this, StreamObserver);
  }

  (0, _createClass2["default"])(StreamObserver, [{
    key: "onNext",
    value: function onNext(rawRecord) {}
  }, {
    key: "onError",
    value: function onError(error) {}
  }, {
    key: "onCompleted",
    value: function onCompleted(meta) {}
  }]);
  return StreamObserver;
}();
/**
 * Handles a RUN/PULL_ALL, or RUN/DISCARD_ALL requests, maps the responses
 * in a way that a user-provided observer can see these as a clean Stream
 * of records.
 * This class will queue up incoming messages until a user-provided observer
 * for the incoming stream is registered. Thus, we keep fields around
 * for tracking head/records/tail. These are only used if there is no
 * observer registered.
 * @access private
 */


exports.StreamObserver = StreamObserver;

var ResultStreamObserver =
/*#__PURE__*/
function (_StreamObserver) {
  (0, _inherits2["default"])(ResultStreamObserver, _StreamObserver);

  /**
   *
   * @param {Object} param
   * @param {Connection} param.connection
   * @param {boolean} param.reactive
   * @param {function(connection: Connection, stmtId: number|Integer, n: number|Integer, observer: StreamObserver)} param.moreFunction -
   * @param {function(connection: Connection, stmtId: number|Integer, observer: StreamObserver)} param.discardFunction -
   * @param {number|Integer} param.fetchSize -
   * @param {function(err: Error): Promise|void} param.beforeError -
   * @param {function(err: Error): Promise|void} param.afterError -
   * @param {function(keys: string[]): Promise|void} param.beforeKeys -
   * @param {function(keys: string[]): Promise|void} param.afterKeys -
   * @param {function(metadata: Object): Promise|void} param.beforeComplete -
   * @param {function(metadata: Object): Promise|void} param.afterComplete -
   */
  function ResultStreamObserver() {
    var _this;

    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        connection = _ref.connection,
        _ref$reactive = _ref.reactive,
        reactive = _ref$reactive === void 0 ? false : _ref$reactive,
        moreFunction = _ref.moreFunction,
        discardFunction = _ref.discardFunction,
        _ref$fetchSize = _ref.fetchSize,
        fetchSize = _ref$fetchSize === void 0 ? _requestMessage.ALL : _ref$fetchSize,
        beforeError = _ref.beforeError,
        afterError = _ref.afterError,
        beforeKeys = _ref.beforeKeys,
        afterKeys = _ref.afterKeys,
        beforeComplete = _ref.beforeComplete,
        afterComplete = _ref.afterComplete;

    (0, _classCallCheck2["default"])(this, ResultStreamObserver);
    _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(ResultStreamObserver).call(this));
    _this._connection = connection;
    _this._fieldKeys = null;
    _this._fieldLookup = null;
    _this._head = null;
    _this._queuedRecords = [];
    _this._tail = null;
    _this._error = null;
    _this._observers = [];
    _this._meta = {};
    _this._beforeError = beforeError;
    _this._afterError = afterError;
    _this._beforeKeys = beforeKeys;
    _this._afterKeys = afterKeys;
    _this._beforeComplete = beforeComplete;
    _this._afterComplete = afterComplete;
    _this._queryId = null;
    _this._moreFunction = moreFunction;
    _this._discardFunction = discardFunction;
    _this._discard = false;
    _this._fetchSize = fetchSize;

    _this._setState(reactive ? _states.READY : _states.READY_STREAMING);

    _this._setupAuoPull(fetchSize);

    return _this;
  }
  /**
   * Will be called on every record that comes in and transform a raw record
   * to a Object. If user-provided observer is present, pass transformed record
   * to it's onNext method, otherwise, push to record que.
   * @param {Array} rawRecord - An array with the raw record
   */


  (0, _createClass2["default"])(ResultStreamObserver, [{
    key: "onNext",
    value: function onNext(rawRecord) {
      var record = new _record["default"](this._fieldKeys, rawRecord, this._fieldLookup);

      if (this._observers.some(function (o) {
        return o.onNext;
      })) {
        this._observers.forEach(function (o) {
          if (o.onNext) {
            o.onNext(record);
          }
        });
      } else {
        this._queuedRecords.push(record);

        if (this._queuedRecords.length > this._highRecordWatermark) {
          this._autoPull = false;
        }
      }
    }
  }, {
    key: "onCompleted",
    value: function onCompleted(meta) {
      this._state.onSuccess(this, meta);
    }
    /**
     * Will be called on errors.
     * If user-provided observer is present, pass the error
     * to it's onError method, otherwise set instance variable _error.
     * @param {Object} error - An error object
     */

  }, {
    key: "onError",
    value: function onError(error) {
      this._state.onError(this, error);
    }
    /**
     * Cancel pending record stream
     */

  }, {
    key: "cancel",
    value: function cancel() {
      this._discard = true;
    }
    /**
     * Stream observer defaults to handling responses for two messages: RUN + PULL_ALL or RUN + DISCARD_ALL.
     * Response for RUN initializes query keys. Response for PULL_ALL / DISCARD_ALL exposes the result stream.
     *
     * However, some operations can be represented as a single message which receives full metadata in a single response.
     * For example, operations to begin, commit and rollback an explicit transaction use two messages in Bolt V1 but a single message in Bolt V3.
     * Messages are `RUN "BEGIN" {}` + `PULL_ALL` in Bolt V1 and `BEGIN` in Bolt V3.
     *
     * This function prepares the observer to only handle a single response message.
     */

  }, {
    key: "prepareToHandleSingleResponse",
    value: function prepareToHandleSingleResponse() {
      this._head = [];
      this._fieldKeys = [];

      this._setState(_states.STREAMING);
    }
    /**
     * Mark this observer as if it has completed with no metadata.
     */

  }, {
    key: "markCompleted",
    value: function markCompleted() {
      this._head = [];
      this._fieldKeys = [];
      this._tail = {};

      this._setState(_states.SUCCEEDED);
    }
    /**
     * Subscribe to events with provided observer.
     * @param {Object} observer - Observer object
     * @param {function(keys: String[])} observer.onKeys - Handle stream header, field keys.
     * @param {function(record: Object)} observer.onNext - Handle records, one by one.
     * @param {function(metadata: Object)} observer.onCompleted - Handle stream tail, the metadata.
     * @param {function(error: Object)} observer.onError - Handle errors, should always be provided.
     */

  }, {
    key: "subscribe",
    value: function subscribe(observer) {
      if (this._error) {
        observer.onError(this._error);
        return;
      }

      if (this._head && observer.onKeys) {
        observer.onKeys(this._head);
      }

      if (this._queuedRecords.length > 0 && observer.onNext) {
        for (var i = 0; i < this._queuedRecords.length; i++) {
          observer.onNext(this._queuedRecords[i]);

          if (this._queuedRecords.length - i - 1 <= this._lowRecordWatermark) {
            this._autoPull = true;

            if (this._state === _states.READY) {
              this._handleStreaming();
            }
          }
        }
      }

      if (this._tail && observer.onCompleted) {
        observer.onCompleted(this._tail);
      }

      this._observers.push(observer);

      if (this._state === _states.READY) {
        this._handleStreaming();
      }
    }
  }, {
    key: "_handleHasMore",
    value: function _handleHasMore(meta) {
      // We've consumed current batch and server notified us that there're more
      // records to stream. Let's invoke more or discard function based on whether
      // the user wants to discard streaming or not
      this._setState(_states.READY); // we've done streaming


      this._handleStreaming();

      delete meta.has_more;
    }
  }, {
    key: "_handlePullSuccess",
    value: function _handlePullSuccess(meta) {
      var _this2 = this;

      this._setState(_states.SUCCEEDED);

      var completionMetadata = Object.assign(this._connection ? {
        server: this._connection.server
      } : {}, this._meta, meta);
      var beforeHandlerResult = null;

      if (this._beforeComplete) {
        beforeHandlerResult = this._beforeComplete(completionMetadata);
      }

      var continuation = function continuation() {
        // End of stream
        _this2._tail = completionMetadata;

        if (_this2._observers.some(function (o) {
          return o.onCompleted;
        })) {
          _this2._observers.forEach(function (o) {
            if (o.onCompleted) {
              o.onCompleted(completionMetadata);
            }
          });
        }

        if (_this2._afterComplete) {
          _this2._afterComplete(completionMetadata);
        }
      };

      if (beforeHandlerResult) {
        Promise.resolve(beforeHandlerResult).then(function () {
          return continuation();
        });
      } else {
        continuation();
      }
    }
  }, {
    key: "_handleRunSuccess",
    value: function _handleRunSuccess(meta, afterSuccess) {
      var _this3 = this;

      if (this._fieldKeys === null) {
        // Stream header, build a name->index field lookup table
        // to be used by records. This is an optimization to make it
        // faster to look up fields in a record by name, rather than by index.
        // Since the records we get back via Bolt are just arrays of values.
        this._fieldKeys = [];
        this._fieldLookup = {};

        if (meta.fields && meta.fields.length > 0) {
          this._fieldKeys = meta.fields;

          for (var i = 0; i < meta.fields.length; i++) {
            this._fieldLookup[meta.fields[i]] = i;
          } // remove fields key from metadata object


          delete meta.fields;
        } // Extract server generated query id for use in requestMore and discard
        // functions


        if (meta.qid) {
          this._queryId = meta.qid; // remove qid from metadata object

          delete meta.qid;
        }

        this._storeMetadataForCompletion(meta);

        var beforeHandlerResult = null;

        if (this._beforeKeys) {
          beforeHandlerResult = this._beforeKeys(this._fieldKeys);
        }

        var continuation = function continuation() {
          _this3._head = _this3._fieldKeys;

          if (_this3._observers.some(function (o) {
            return o.onKeys;
          })) {
            _this3._observers.forEach(function (o) {
              if (o.onKeys) {
                o.onKeys(_this3._fieldKeys);
              }
            });
          }

          if (_this3._afterKeys) {
            _this3._afterKeys(_this3._fieldKeys);
          }

          afterSuccess();
        };

        if (beforeHandlerResult) {
          Promise.resolve(beforeHandlerResult).then(function () {
            return continuation();
          });
        } else {
          continuation();
        }
      }
    }
  }, {
    key: "_handleError",
    value: function _handleError(error) {
      var _this4 = this;

      this._setState(_states.FAILED);

      this._error = error;
      var beforeHandlerResult = null;

      if (this._beforeError) {
        beforeHandlerResult = this._beforeError(error);
      }

      var continuation = function continuation() {
        if (_this4._observers.some(function (o) {
          return o.onError;
        })) {
          _this4._observers.forEach(function (o) {
            if (o.onError) {
              o.onError(error);
            }
          });
        }

        if (_this4._afterError) {
          _this4._afterError(error);
        }
      };

      if (beforeHandlerResult) {
        Promise.resolve(beforeHandlerResult).then(function () {
          return continuation();
        });
      } else {
        continuation();
      }
    }
  }, {
    key: "_handleStreaming",
    value: function _handleStreaming() {
      if (this._head && this._observers.some(function (o) {
        return o.onNext || o.onCompleted;
      })) {
        if (this._discard) {
          this._discardFunction(this._connection, this._queryId, this);

          this._setState(_states.STREAMING);
        } else if (this._autoPull) {
          this._moreFunction(this._connection, this._queryId, this._fetchSize, this);

          this._setState(_states.STREAMING);
        }
      }
    }
  }, {
    key: "_storeMetadataForCompletion",
    value: function _storeMetadataForCompletion(meta) {
      var keys = Object.keys(meta);
      var index = keys.length;
      var key = '';

      while (index--) {
        key = keys[index];
        this._meta[key] = meta[key];
      }
    }
  }, {
    key: "_setState",
    value: function _setState(state) {
      this._state = state;
    }
  }, {
    key: "_setupAuoPull",
    value: function _setupAuoPull(fetchSize) {
      this._autoPull = true;

      if (fetchSize === _requestMessage.ALL) {
        this._lowRecordWatermark = Number.MAX_VALUE; // we shall always lower than this number to enable auto pull

        this._highRecordWatermark = Number.MAX_VALUE; // we shall never reach this number to disable auto pull
      } else {
        this._lowRecordWatermark = 0.3 * fetchSize;
        this._highRecordWatermark = 0.7 * fetchSize;
      }
    }
  }]);
  return ResultStreamObserver;
}(StreamObserver);

exports.ResultStreamObserver = ResultStreamObserver;

var LoginObserver =
/*#__PURE__*/
function (_StreamObserver2) {
  (0, _inherits2["default"])(LoginObserver, _StreamObserver2);

  /**
   *
   * @param {Object} param -
   * @param {Connection} param.connection
   * @param {function(err: Error)} param.beforeError
   * @param {function(err: Error)} param.afterError
   * @param {function(metadata)} param.beforeComplete
   * @param {function(metadata)} param.afterComplete
   */
  function LoginObserver() {
    var _this5;

    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        connection = _ref2.connection,
        beforeError = _ref2.beforeError,
        afterError = _ref2.afterError,
        beforeComplete = _ref2.beforeComplete,
        afterComplete = _ref2.afterComplete;

    (0, _classCallCheck2["default"])(this, LoginObserver);
    _this5 = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(LoginObserver).call(this));
    _this5._connection = connection;
    _this5._beforeError = beforeError;
    _this5._afterError = afterError;
    _this5._beforeComplete = beforeComplete;
    _this5._afterComplete = afterComplete;
    return _this5;
  }

  (0, _createClass2["default"])(LoginObserver, [{
    key: "onNext",
    value: function onNext(record) {
      this.onError((0, _error.newError)('Received RECORD when initializing ' + JSON.stringify(record)));
    }
  }, {
    key: "onError",
    value: function onError(error) {
      if (this._beforeError) {
        this._beforeError(error);
      }

      this._connection._updateCurrentObserver(); // make sure this exact observer will not be called again


      this._connection._handleFatalError(error); // initialization errors are fatal


      if (this._afterError) {
        this._afterError(error);
      }
    }
  }, {
    key: "onCompleted",
    value: function onCompleted(metadata) {
      if (this._beforeComplete) {
        this._beforeComplete(metadata);
      }

      if (metadata) {
        // read server version from the response metadata, if it is available
        var serverVersion = metadata.server;

        if (!this._connection.version) {
          this._connection.version = serverVersion;
        } // read database connection id from the response metadata, if it is available


        var dbConnectionId = metadata.connection_id;

        if (!this._connection.databaseId) {
          this._connection.databaseId = dbConnectionId;
        }
      }

      if (this._afterComplete) {
        this._afterComplete(metadata);
      }
    }
  }]);
  return LoginObserver;
}(StreamObserver);

exports.LoginObserver = LoginObserver;

var ResetObserver =
/*#__PURE__*/
function (_StreamObserver3) {
  (0, _inherits2["default"])(ResetObserver, _StreamObserver3);

  /**
   *
   * @param {Object} param -
   * @param {Connection} param.connection
   * @param {function(err: Error)} param.onError
   * @param {function(metadata)} param.onComplete
   */
  function ResetObserver() {
    var _this6;

    var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        connection = _ref3.connection,
        onError = _ref3.onError,
        onComplete = _ref3.onComplete;

    (0, _classCallCheck2["default"])(this, ResetObserver);
    _this6 = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(ResetObserver).call(this));
    _this6._connection = connection;
    _this6._onError = onError;
    _this6._onComplete = onComplete;
    return _this6;
  }

  (0, _createClass2["default"])(ResetObserver, [{
    key: "onNext",
    value: function onNext(record) {
      this.onError((0, _error.newError)('Received RECORD when resetting: received record is: ' + JSON.stringify(record), _error.PROTOCOL_ERROR));
    }
  }, {
    key: "onError",
    value: function onError(error) {
      if (error.code === _error.PROTOCOL_ERROR) {
        this._connection._handleProtocolError(error.message);
      }

      if (this._onError) {
        this._onError(error);
      }
    }
  }, {
    key: "onCompleted",
    value: function onCompleted(metadata) {
      if (this._onComplete) {
        this._onComplete(metadata);
      }
    }
  }]);
  return ResetObserver;
}(StreamObserver);

exports.ResetObserver = ResetObserver;

var FailedObserver =
/*#__PURE__*/
function (_ResultStreamObserver) {
  (0, _inherits2["default"])(FailedObserver, _ResultStreamObserver);

  function FailedObserver(_ref4) {
    var _this7;

    var error = _ref4.error,
        onError = _ref4.onError;
    (0, _classCallCheck2["default"])(this, FailedObserver);
    _this7 = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(FailedObserver).call(this, {
      beforeError: onError
    }));

    _this7.onError(error);

    return _this7;
  }

  return FailedObserver;
}(ResultStreamObserver);

exports.FailedObserver = FailedObserver;

var CompletedObserver =
/*#__PURE__*/
function (_ResultStreamObserver2) {
  (0, _inherits2["default"])(CompletedObserver, _ResultStreamObserver2);

  function CompletedObserver() {
    var _this8;

    (0, _classCallCheck2["default"])(this, CompletedObserver);
    _this8 = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(CompletedObserver).call(this));
    (0, _get2["default"])((0, _getPrototypeOf2["default"])(CompletedObserver.prototype), "markCompleted", (0, _assertThisInitialized2["default"])(_this8)).call((0, _assertThisInitialized2["default"])(_this8));
    return _this8;
  }

  return CompletedObserver;
}(ResultStreamObserver);

exports.CompletedObserver = CompletedObserver;
var _states = {
  READY_STREAMING: {
    // async start state
    onSuccess: function onSuccess(streamObserver, meta) {
      streamObserver._handleRunSuccess(meta, function () {
        streamObserver._setState(_states.STREAMING);
      } // after run succeeded, async directly move to streaming
      // state
      );
    },
    onError: function onError(streamObserver, error) {
      streamObserver._handleError(error);
    },
    name: function name() {
      return 'READY_STREAMING';
    }
  },
  READY: {
    // reactive start state
    onSuccess: function onSuccess(streamObserver, meta) {
      streamObserver._handleRunSuccess(meta, function () {
        return streamObserver._handleStreaming();
      } // after run succeeded received, reactive shall start pulling
      );
    },
    onError: function onError(streamObserver, error) {
      streamObserver._handleError(error);
    },
    name: function name() {
      return 'READY';
    }
  },
  STREAMING: {
    onSuccess: function onSuccess(streamObserver, meta) {
      if (meta.has_more) {
        streamObserver._handleHasMore(meta);
      } else {
        streamObserver._handlePullSuccess(meta);
      }
    },
    onError: function onError(streamObserver, error) {
      streamObserver._handleError(error);
    },
    name: function name() {
      return 'STREAMING';
    }
  },
  FAILED: {
    onError: function onError(error) {// more errors are ignored
    },
    name: function name() {
      return 'FAILED';
    }
  },
  SUCCEEDED: {
    name: function name() {
      return 'SUCCEEDED';
    }
  }
};

},{"../error":231,"../integer":234,"../record":289,"./connection":262,"./request-message":274,"@babel/runtime/helpers/assertThisInitialized":3,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/get":9,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":19}],284:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.normalizeSecondsForDuration = normalizeSecondsForDuration;
exports.normalizeNanosecondsForDuration = normalizeNanosecondsForDuration;
exports.localTimeToNanoOfDay = localTimeToNanoOfDay;
exports.nanoOfDayToLocalTime = nanoOfDayToLocalTime;
exports.localDateTimeToEpochSecond = localDateTimeToEpochSecond;
exports.epochSecondAndNanoToLocalDateTime = epochSecondAndNanoToLocalDateTime;
exports.dateToEpochDay = dateToEpochDay;
exports.epochDayToDate = epochDayToDate;
exports.durationToIsoString = durationToIsoString;
exports.timeToIsoString = timeToIsoString;
exports.timeZoneOffsetToIsoString = timeZoneOffsetToIsoString;
exports.dateToIsoString = dateToIsoString;
exports.totalNanoseconds = totalNanoseconds;
exports.timeZoneOffsetInSeconds = timeZoneOffsetInSeconds;
exports.assertValidYear = assertValidYear;
exports.assertValidMonth = assertValidMonth;
exports.assertValidDay = assertValidDay;
exports.assertValidHour = assertValidHour;
exports.assertValidMinute = assertValidMinute;
exports.assertValidSecond = assertValidSecond;
exports.assertValidNanosecond = assertValidNanosecond;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _integer = require("../integer");

var _temporalTypes = require("../temporal-types");

var _util = require("./util");

var _error = require("../error");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
  Code in this util should be compatible with code in the database that uses JSR-310 java.time APIs.

  It is based on a library called ThreeTen (https://github.com/ThreeTen/threetenbp) which was derived
  from JSR-310 reference implementation previously hosted on GitHub. Code uses `Integer` type everywhere
  to correctly handle large integer values that are greater than `Number.MAX_SAFE_INTEGER`.

  Please consult either ThreeTen or js-joda (https://github.com/js-joda/js-joda) when working with the
  conversion functions.
 */
var ValueRange =
/*#__PURE__*/
function () {
  function ValueRange(min, max) {
    (0, _classCallCheck2["default"])(this, ValueRange);
    this._minNumber = min;
    this._maxNumber = max;
    this._minInteger = (0, _integer["int"])(min);
    this._maxInteger = (0, _integer["int"])(max);
  }

  (0, _createClass2["default"])(ValueRange, [{
    key: "contains",
    value: function contains(value) {
      if ((0, _integer.isInt)(value)) {
        return value.greaterThanOrEqual(this._minInteger) && value.lessThanOrEqual(this._maxInteger);
      } else {
        return value >= this._minNumber && value <= this._maxNumber;
      }
    }
  }, {
    key: "toString",
    value: function toString() {
      return "[".concat(this._minNumber, ", ").concat(this._maxNumber, "]");
    }
  }]);
  return ValueRange;
}();

var YEAR_RANGE = new ValueRange(-999999999, 999999999);
var MONTH_OF_YEAR_RANGE = new ValueRange(1, 12);
var DAY_OF_MONTH_RANGE = new ValueRange(1, 31);
var HOUR_OF_DAY_RANGE = new ValueRange(0, 23);
var MINUTE_OF_HOUR_RANGE = new ValueRange(0, 59);
var SECOND_OF_MINUTE_RANGE = new ValueRange(0, 59);
var NANOSECOND_OF_SECOND_RANGE = new ValueRange(0, 999999999);
var MINUTES_PER_HOUR = 60;
var SECONDS_PER_MINUTE = 60;
var SECONDS_PER_HOUR = SECONDS_PER_MINUTE * MINUTES_PER_HOUR;
var NANOS_PER_SECOND = 1000000000;
var NANOS_PER_MILLISECOND = 1000000;
var NANOS_PER_MINUTE = NANOS_PER_SECOND * SECONDS_PER_MINUTE;
var NANOS_PER_HOUR = NANOS_PER_MINUTE * MINUTES_PER_HOUR;
var DAYS_0000_TO_1970 = 719528;
var DAYS_PER_400_YEAR_CYCLE = 146097;
var SECONDS_PER_DAY = 86400;

function normalizeSecondsForDuration(seconds, nanoseconds) {
  return (0, _integer["int"])(seconds).add(floorDiv(nanoseconds, NANOS_PER_SECOND));
}

function normalizeNanosecondsForDuration(nanoseconds) {
  return floorMod(nanoseconds, NANOS_PER_SECOND);
}
/**
 * Converts given local time into a single integer representing this same time in nanoseconds of the day.
 * @param {Integer|number|string} hour the hour of the local time to convert.
 * @param {Integer|number|string} minute the minute of the local time to convert.
 * @param {Integer|number|string} second the second of the local time to convert.
 * @param {Integer|number|string} nanosecond the nanosecond of the local time to convert.
 * @return {Integer} nanoseconds representing the given local time.
 */


function localTimeToNanoOfDay(hour, minute, second, nanosecond) {
  hour = (0, _integer["int"])(hour);
  minute = (0, _integer["int"])(minute);
  second = (0, _integer["int"])(second);
  nanosecond = (0, _integer["int"])(nanosecond);
  var totalNanos = hour.multiply(NANOS_PER_HOUR);
  totalNanos = totalNanos.add(minute.multiply(NANOS_PER_MINUTE));
  totalNanos = totalNanos.add(second.multiply(NANOS_PER_SECOND));
  return totalNanos.add(nanosecond);
}
/**
 * Converts nanoseconds of the day into local time.
 * @param {Integer|number|string} nanoOfDay the nanoseconds of the day to convert.
 * @return {LocalTime} the local time representing given nanoseconds of the day.
 */


function nanoOfDayToLocalTime(nanoOfDay) {
  nanoOfDay = (0, _integer["int"])(nanoOfDay);
  var hour = nanoOfDay.div(NANOS_PER_HOUR);
  nanoOfDay = nanoOfDay.subtract(hour.multiply(NANOS_PER_HOUR));
  var minute = nanoOfDay.div(NANOS_PER_MINUTE);
  nanoOfDay = nanoOfDay.subtract(minute.multiply(NANOS_PER_MINUTE));
  var second = nanoOfDay.div(NANOS_PER_SECOND);
  var nanosecond = nanoOfDay.subtract(second.multiply(NANOS_PER_SECOND));
  return new _temporalTypes.LocalTime(hour, minute, second, nanosecond);
}
/**
 * Converts given local date time into a single integer representing this same time in epoch seconds UTC.
 * @param {Integer|number|string} year the year of the local date-time to convert.
 * @param {Integer|number|string} month the month of the local date-time to convert.
 * @param {Integer|number|string} day the day of the local date-time to convert.
 * @param {Integer|number|string} hour the hour of the local date-time to convert.
 * @param {Integer|number|string} minute the minute of the local date-time to convert.
 * @param {Integer|number|string} second the second of the local date-time to convert.
 * @param {Integer|number|string} nanosecond the nanosecond of the local date-time to convert.
 * @return {Integer} epoch second in UTC representing the given local date time.
 */


function localDateTimeToEpochSecond(year, month, day, hour, minute, second, nanosecond) {
  var epochDay = dateToEpochDay(year, month, day);
  var localTimeSeconds = localTimeToSecondOfDay(hour, minute, second);
  return epochDay.multiply(SECONDS_PER_DAY).add(localTimeSeconds);
}
/**
 * Converts given epoch second and nanosecond adjustment into a local date time object.
 * @param {Integer|number|string} epochSecond the epoch second to use.
 * @param {Integer|number|string} nano the nanosecond to use.
 * @return {LocalDateTime} the local date time representing given epoch second and nano.
 */


function epochSecondAndNanoToLocalDateTime(epochSecond, nano) {
  var epochDay = floorDiv(epochSecond, SECONDS_PER_DAY);
  var secondsOfDay = floorMod(epochSecond, SECONDS_PER_DAY);
  var nanoOfDay = secondsOfDay.multiply(NANOS_PER_SECOND).add(nano);
  var localDate = epochDayToDate(epochDay);
  var localTime = nanoOfDayToLocalTime(nanoOfDay);
  return new _temporalTypes.LocalDateTime(localDate.year, localDate.month, localDate.day, localTime.hour, localTime.minute, localTime.second, localTime.nanosecond);
}
/**
 * Converts given local date into a single integer representing it's epoch day.
 * @param {Integer|number|string} year the year of the local date to convert.
 * @param {Integer|number|string} month the month of the local date to convert.
 * @param {Integer|number|string} day the day of the local date to convert.
 * @return {Integer} epoch day representing the given date.
 */


function dateToEpochDay(year, month, day) {
  year = (0, _integer["int"])(year);
  month = (0, _integer["int"])(month);
  day = (0, _integer["int"])(day);
  var epochDay = year.multiply(365);

  if (year.greaterThanOrEqual(0)) {
    epochDay = epochDay.add(year.add(3).div(4).subtract(year.add(99).div(100)).add(year.add(399).div(400)));
  } else {
    epochDay = epochDay.subtract(year.div(-4).subtract(year.div(-100)).add(year.div(-400)));
  }

  epochDay = epochDay.add(month.multiply(367).subtract(362).div(12));
  epochDay = epochDay.add(day.subtract(1));

  if (month.greaterThan(2)) {
    epochDay = epochDay.subtract(1);

    if (!isLeapYear(year)) {
      epochDay = epochDay.subtract(1);
    }
  }

  return epochDay.subtract(DAYS_0000_TO_1970);
}
/**
 * Converts given epoch day to a local date.
 * @param {Integer|number|string} epochDay the epoch day to convert.
 * @return {Date} the date representing the epoch day in years, months and days.
 */


function epochDayToDate(epochDay) {
  epochDay = (0, _integer["int"])(epochDay);
  var zeroDay = epochDay.add(DAYS_0000_TO_1970).subtract(60);
  var adjust = (0, _integer["int"])(0);

  if (zeroDay.lessThan(0)) {
    var adjustCycles = zeroDay.add(1).div(DAYS_PER_400_YEAR_CYCLE).subtract(1);
    adjust = adjustCycles.multiply(400);
    zeroDay = zeroDay.add(adjustCycles.multiply(-DAYS_PER_400_YEAR_CYCLE));
  }

  var year = zeroDay.multiply(400).add(591).div(DAYS_PER_400_YEAR_CYCLE);
  var dayOfYearEst = zeroDay.subtract(year.multiply(365).add(year.div(4)).subtract(year.div(100)).add(year.div(400)));

  if (dayOfYearEst.lessThan(0)) {
    year = year.subtract(1);
    dayOfYearEst = zeroDay.subtract(year.multiply(365).add(year.div(4)).subtract(year.div(100)).add(year.div(400)));
  }

  year = year.add(adjust);
  var marchDayOfYear = dayOfYearEst;
  var marchMonth = marchDayOfYear.multiply(5).add(2).div(153);
  var month = marchMonth.add(2).modulo(12).add(1);
  var day = marchDayOfYear.subtract(marchMonth.multiply(306).add(5).div(10)).add(1);
  year = year.add(marchMonth.div(10));
  return new _temporalTypes.Date(year, month, day);
}
/**
 * Format given duration to an ISO 8601 string.
 * @param {Integer|number|string} months the number of months.
 * @param {Integer|number|string} days the number of days.
 * @param {Integer|number|string} seconds the number of seconds.
 * @param {Integer|number|string} nanoseconds the number of nanoseconds.
 * @return {string} ISO string that represents given duration.
 */


function durationToIsoString(months, days, seconds, nanoseconds) {
  var monthsString = formatNumber(months);
  var daysString = formatNumber(days);
  var secondsAndNanosecondsString = formatSecondsAndNanosecondsForDuration(seconds, nanoseconds);
  return "P".concat(monthsString, "M").concat(daysString, "DT").concat(secondsAndNanosecondsString, "S");
}
/**
 * Formats given time to an ISO 8601 string.
 * @param {Integer|number|string} hour the hour value.
 * @param {Integer|number|string} minute the minute value.
 * @param {Integer|number|string} second the second value.
 * @param {Integer|number|string} nanosecond the nanosecond value.
 * @return {string} ISO string that represents given time.
 */


function timeToIsoString(hour, minute, second, nanosecond) {
  var hourString = formatNumber(hour, 2);
  var minuteString = formatNumber(minute, 2);
  var secondString = formatNumber(second, 2);
  var nanosecondString = formatNanosecond(nanosecond);
  return "".concat(hourString, ":").concat(minuteString, ":").concat(secondString).concat(nanosecondString);
}
/**
 * Formats given time zone offset in seconds to string representation like 'HH:MM', 'HH:MM:SS' or 'Z' for UTC.
 * @param {Integer|number|string} offsetSeconds the offset in seconds.
 * @return {string} ISO string that represents given offset.
 */


function timeZoneOffsetToIsoString(offsetSeconds) {
  offsetSeconds = (0, _integer["int"])(offsetSeconds);

  if (offsetSeconds.equals(0)) {
    return 'Z';
  }

  var isNegative = offsetSeconds.isNegative();

  if (isNegative) {
    offsetSeconds = offsetSeconds.multiply(-1);
  }

  var signPrefix = isNegative ? '-' : '+';
  var hours = formatNumber(offsetSeconds.div(SECONDS_PER_HOUR), 2);
  var minutes = formatNumber(offsetSeconds.div(SECONDS_PER_MINUTE).modulo(MINUTES_PER_HOUR), 2);
  var secondsValue = offsetSeconds.modulo(SECONDS_PER_MINUTE);
  var seconds = secondsValue.equals(0) ? null : formatNumber(secondsValue, 2);
  return seconds ? "".concat(signPrefix).concat(hours, ":").concat(minutes, ":").concat(seconds) : "".concat(signPrefix).concat(hours, ":").concat(minutes);
}
/**
 * Formats given date to an ISO 8601 string.
 * @param {Integer|number|string} year the date year.
 * @param {Integer|number|string} month the date month.
 * @param {Integer|number|string} day the date day.
 * @return {string} ISO string that represents given date.
 */


function dateToIsoString(year, month, day) {
  year = (0, _integer["int"])(year);
  var isNegative = year.isNegative();

  if (isNegative) {
    year = year.multiply(-1);
  }

  var yearString = formatNumber(year, 4);

  if (isNegative) {
    yearString = '-' + yearString;
  }

  var monthString = formatNumber(month, 2);
  var dayString = formatNumber(day, 2);
  return "".concat(yearString, "-").concat(monthString, "-").concat(dayString);
}
/**
 * Get the total number of nanoseconds from the milliseconds of the given standard JavaScript date and optional nanosecond part.
 * @param {global.Date} standardDate the standard JavaScript date.
 * @param {Integer|number|undefined} nanoseconds the optional number of nanoseconds.
 * @return {Integer|number} the total amount of nanoseconds.
 */


function totalNanoseconds(standardDate, nanoseconds) {
  nanoseconds = nanoseconds || 0;
  var nanosFromMillis = standardDate.getMilliseconds() * NANOS_PER_MILLISECOND;
  return (0, _integer.isInt)(nanoseconds) ? nanoseconds.add(nanosFromMillis) : nanoseconds + nanosFromMillis;
}
/**
 * Get the time zone offset in seconds from the given standard JavaScript date.
 *
 * <b>Implementation note:</b>
 * Time zone offset returned by the standard JavaScript date is the difference, in minutes, from local time to UTC.
 * So positive value means offset is behind UTC and negative value means it is ahead.
 * For Neo4j temporal types, like `Time` or `DateTime` offset is in seconds and represents difference from UTC to local time.
 * This is different from standard JavaScript dates and that's why implementation negates the returned value.
 *
 * @param {global.Date} standardDate the standard JavaScript date.
 * @return {number} the time zone offset in seconds.
 */


function timeZoneOffsetInSeconds(standardDate) {
  var offsetInMinutes = standardDate.getTimezoneOffset();

  if (offsetInMinutes === 0) {
    return 0;
  }

  return -1 * offsetInMinutes * SECONDS_PER_MINUTE;
}
/**
 * Assert that the year value is valid.
 * @param {Integer|number} year the value to check.
 * @return {Integer|number} the value of the year if it is valid. Exception is thrown otherwise.
 */


function assertValidYear(year) {
  return assertValidTemporalValue(year, YEAR_RANGE, 'Year');
}
/**
 * Assert that the month value is valid.
 * @param {Integer|number} month the value to check.
 * @return {Integer|number} the value of the month if it is valid. Exception is thrown otherwise.
 */


function assertValidMonth(month) {
  return assertValidTemporalValue(month, MONTH_OF_YEAR_RANGE, 'Month');
}
/**
 * Assert that the day value is valid.
 * @param {Integer|number} day the value to check.
 * @return {Integer|number} the value of the day if it is valid. Exception is thrown otherwise.
 */


function assertValidDay(day) {
  return assertValidTemporalValue(day, DAY_OF_MONTH_RANGE, 'Day');
}
/**
 * Assert that the hour value is valid.
 * @param {Integer|number} hour the value to check.
 * @return {Integer|number} the value of the hour if it is valid. Exception is thrown otherwise.
 */


function assertValidHour(hour) {
  return assertValidTemporalValue(hour, HOUR_OF_DAY_RANGE, 'Hour');
}
/**
 * Assert that the minute value is valid.
 * @param {Integer|number} minute the value to check.
 * @return {Integer|number} the value of the minute if it is valid. Exception is thrown otherwise.
 */


function assertValidMinute(minute) {
  return assertValidTemporalValue(minute, MINUTE_OF_HOUR_RANGE, 'Minute');
}
/**
 * Assert that the second value is valid.
 * @param {Integer|number} second the value to check.
 * @return {Integer|number} the value of the second if it is valid. Exception is thrown otherwise.
 */


function assertValidSecond(second) {
  return assertValidTemporalValue(second, SECOND_OF_MINUTE_RANGE, 'Second');
}
/**
 * Assert that the nanosecond value is valid.
 * @param {Integer|number} nanosecond the value to check.
 * @return {Integer|number} the value of the nanosecond if it is valid. Exception is thrown otherwise.
 */


function assertValidNanosecond(nanosecond) {
  return assertValidTemporalValue(nanosecond, NANOSECOND_OF_SECOND_RANGE, 'Nanosecond');
}
/**
 * Check if the given value is of expected type and is in the expected range.
 * @param {Integer|number} value the value to check.
 * @param {ValueRange} range the range.
 * @param {string} name the name of the value.
 * @return {Integer|number} the value if valid. Exception is thrown otherwise.
 */


function assertValidTemporalValue(value, range, name) {
  (0, _util.assertNumberOrInteger)(value, name);

  if (!range.contains(value)) {
    throw (0, _error.newError)("".concat(name, " is expected to be in range ").concat(range, " but was: ").concat(value));
  }

  return value;
}
/**
 * Converts given local time into a single integer representing this same time in seconds of the day. Nanoseconds are skipped.
 * @param {Integer|number|string} hour the hour of the local time.
 * @param {Integer|number|string} minute the minute of the local time.
 * @param {Integer|number|string} second the second of the local time.
 * @return {Integer} seconds representing the given local time.
 */


function localTimeToSecondOfDay(hour, minute, second) {
  hour = (0, _integer["int"])(hour);
  minute = (0, _integer["int"])(minute);
  second = (0, _integer["int"])(second);
  var totalSeconds = hour.multiply(SECONDS_PER_HOUR);
  totalSeconds = totalSeconds.add(minute.multiply(SECONDS_PER_MINUTE));
  return totalSeconds.add(second);
}
/**
 * Check if given year is a leap year. Uses algorithm described here {@link https://en.wikipedia.org/wiki/Leap_year#Algorithm}.
 * @param {Integer|number|string} year the year to check. Will be converted to {@link Integer} for all calculations.
 * @return {boolean} `true` if given year is a leap year, `false` otherwise.
 */


function isLeapYear(year) {
  year = (0, _integer["int"])(year);

  if (!year.modulo(4).equals(0)) {
    return false;
  } else if (!year.modulo(100).equals(0)) {
    return true;
  } else if (!year.modulo(400).equals(0)) {
    return false;
  } else {
    return true;
  }
}
/**
 * @param {Integer|number|string} x the divident.
 * @param {Integer|number|string} y the divisor.
 * @return {Integer} the result.
 */


function floorDiv(x, y) {
  x = (0, _integer["int"])(x);
  y = (0, _integer["int"])(y);
  var result = x.div(y);

  if (x.isPositive() !== y.isPositive() && result.multiply(y).notEquals(x)) {
    result = result.subtract(1);
  }

  return result;
}
/**
 * @param {Integer|number|string} x the divident.
 * @param {Integer|number|string} y the divisor.
 * @return {Integer} the result.
 */


function floorMod(x, y) {
  x = (0, _integer["int"])(x);
  y = (0, _integer["int"])(y);
  return x.subtract(floorDiv(x, y).multiply(y));
}
/**
 * @param {Integer|number|string} seconds the number of seconds to format.
 * @param {Integer|number|string} nanoseconds the number of nanoseconds to format.
 * @return {string} formatted value.
 */


function formatSecondsAndNanosecondsForDuration(seconds, nanoseconds) {
  seconds = (0, _integer["int"])(seconds);
  nanoseconds = (0, _integer["int"])(nanoseconds);
  var secondsString;
  var nanosecondsString;
  var secondsNegative = seconds.isNegative();
  var nanosecondsGreaterThanZero = nanoseconds.greaterThan(0);

  if (secondsNegative && nanosecondsGreaterThanZero) {
    if (seconds.equals(-1)) {
      secondsString = '-0';
    } else {
      secondsString = seconds.add(1).toString();
    }
  } else {
    secondsString = seconds.toString();
  }

  if (nanosecondsGreaterThanZero) {
    if (secondsNegative) {
      nanosecondsString = formatNanosecond(nanoseconds.negate().add(2 * NANOS_PER_SECOND).modulo(NANOS_PER_SECOND));
    } else {
      nanosecondsString = formatNanosecond(nanoseconds.add(NANOS_PER_SECOND).modulo(NANOS_PER_SECOND));
    }
  }

  return nanosecondsString ? secondsString + nanosecondsString : secondsString;
}
/**
 * @param {Integer|number|string} value the number of nanoseconds to format.
 * @return {string} formatted and possibly left-padded nanoseconds part as string.
 */


function formatNanosecond(value) {
  value = (0, _integer["int"])(value);
  return value.equals(0) ? '' : '.' + formatNumber(value, 9);
}
/**
 * @param {Integer|number|string} num the number to format.
 * @param {number} [stringLength=undefined] the string length to left-pad to.
 * @return {string} formatted and possibly left-padded number as string.
 */


function formatNumber(num) {
  var stringLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
  num = (0, _integer["int"])(num);
  var isNegative = num.isNegative();

  if (isNegative) {
    num = num.negate();
  }

  var numString = num.toString();

  if (stringLength) {
    // left pad the string with zeroes
    while (numString.length < stringLength) {
      numString = '0' + numString;
    }
  }

  return isNegative ? '-' + numString : numString;
}

},{"../error":231,"../integer":234,"../temporal-types":297,"./util":288,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":12}],285:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _error = require("../error");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var DEFAULT_MAX_RETRY_TIME_MS = 30 * 1000; // 30 seconds

var DEFAULT_INITIAL_RETRY_DELAY_MS = 1000; // 1 seconds

var DEFAULT_RETRY_DELAY_MULTIPLIER = 2.0;
var DEFAULT_RETRY_DELAY_JITTER_FACTOR = 0.2;

var TransactionExecutor =
/*#__PURE__*/
function () {
  function TransactionExecutor(maxRetryTimeMs, initialRetryDelayMs, multiplier, jitterFactor) {
    (0, _classCallCheck2["default"])(this, TransactionExecutor);
    this._maxRetryTimeMs = _valueOrDefault(maxRetryTimeMs, DEFAULT_MAX_RETRY_TIME_MS);
    this._initialRetryDelayMs = _valueOrDefault(initialRetryDelayMs, DEFAULT_INITIAL_RETRY_DELAY_MS);
    this._multiplier = _valueOrDefault(multiplier, DEFAULT_RETRY_DELAY_MULTIPLIER);
    this._jitterFactor = _valueOrDefault(jitterFactor, DEFAULT_RETRY_DELAY_JITTER_FACTOR);
    this._inFlightTimeoutIds = [];

    this._verifyAfterConstruction();
  }

  (0, _createClass2["default"])(TransactionExecutor, [{
    key: "execute",
    value: function execute(transactionCreator, transactionWork) {
      var _this = this;

      return new Promise(function (resolve, reject) {
        _this._executeTransactionInsidePromise(transactionCreator, transactionWork, resolve, reject);
      })["catch"](function (error) {
        var retryStartTimeMs = Date.now();
        var retryDelayMs = _this._initialRetryDelayMs;
        return _this._retryTransactionPromise(transactionCreator, transactionWork, error, retryStartTimeMs, retryDelayMs);
      });
    }
  }, {
    key: "close",
    value: function close() {
      // cancel all existing timeouts to prevent further retries
      this._inFlightTimeoutIds.forEach(function (timeoutId) {
        return clearTimeout(timeoutId);
      });

      this._inFlightTimeoutIds = [];
    }
  }, {
    key: "_retryTransactionPromise",
    value: function _retryTransactionPromise(transactionCreator, transactionWork, error, retryStartTime, retryDelayMs) {
      var _this2 = this;

      var elapsedTimeMs = Date.now() - retryStartTime;

      if (elapsedTimeMs > this._maxRetryTimeMs || !TransactionExecutor._canRetryOn(error)) {
        return Promise.reject(error);
      }

      return new Promise(function (resolve, reject) {
        var nextRetryTime = _this2._computeDelayWithJitter(retryDelayMs);

        var timeoutId = setTimeout(function () {
          // filter out this timeoutId when time has come and function is being executed
          _this2._inFlightTimeoutIds = _this2._inFlightTimeoutIds.filter(function (id) {
            return id !== timeoutId;
          });

          _this2._executeTransactionInsidePromise(transactionCreator, transactionWork, resolve, reject);
        }, nextRetryTime); // add newly created timeoutId to the list of all in-flight timeouts

        _this2._inFlightTimeoutIds.push(timeoutId);
      })["catch"](function (error) {
        var nextRetryDelayMs = retryDelayMs * _this2._multiplier;
        return _this2._retryTransactionPromise(transactionCreator, transactionWork, error, retryStartTime, nextRetryDelayMs);
      });
    }
  }, {
    key: "_executeTransactionInsidePromise",
    value: function _executeTransactionInsidePromise(transactionCreator, transactionWork, resolve, reject) {
      var _this3 = this;

      var tx;

      try {
        tx = transactionCreator();
      } catch (error) {
        // failed to create a transaction
        reject(error);
        return;
      }

      var resultPromise = this._safeExecuteTransactionWork(tx, transactionWork);

      resultPromise.then(function (result) {
        return _this3._handleTransactionWorkSuccess(result, tx, resolve, reject);
      })["catch"](function (error) {
        return _this3._handleTransactionWorkFailure(error, tx, reject);
      });
    }
  }, {
    key: "_safeExecuteTransactionWork",
    value: function _safeExecuteTransactionWork(tx, transactionWork) {
      try {
        var result = transactionWork(tx); // user defined callback is supposed to return a promise, but it might not; so to protect against an
        // incorrect API usage we wrap the returned value with a resolved promise; this is effectively a
        // validation step without type checks

        return Promise.resolve(result);
      } catch (error) {
        return Promise.reject(error);
      }
    }
  }, {
    key: "_handleTransactionWorkSuccess",
    value: function _handleTransactionWorkSuccess(result, tx, resolve, reject) {
      if (tx.isOpen()) {
        // transaction work returned resolved promise and transaction has not been committed/rolled back
        // try to commit the transaction
        tx.commit().then(function () {
          // transaction was committed, return result to the user
          resolve(result);
        })["catch"](function (error) {
          // transaction failed to commit, propagate the failure
          reject(error);
        });
      } else {
        // transaction work returned resolved promise and transaction is already committed/rolled back
        // return the result returned by given transaction work
        resolve(result);
      }
    }
  }, {
    key: "_handleTransactionWorkFailure",
    value: function _handleTransactionWorkFailure(error, tx, reject) {
      if (tx.isOpen()) {
        // transaction work failed and the transaction is still open, roll it back and propagate the failure
        tx.rollback()["catch"](function (ignore) {// ignore the rollback error
        }).then(function () {
          return reject(error);
        }); // propagate the original error we got from the transaction work
      } else {
        // transaction is already rolled back, propagate the error
        reject(error);
      }
    }
  }, {
    key: "_computeDelayWithJitter",
    value: function _computeDelayWithJitter(delayMs) {
      var jitter = delayMs * this._jitterFactor;
      var min = delayMs - jitter;
      var max = delayMs + jitter;
      return Math.random() * (max - min) + min;
    }
  }, {
    key: "_verifyAfterConstruction",
    value: function _verifyAfterConstruction() {
      if (this._maxRetryTimeMs < 0) {
        throw (0, _error.newError)('Max retry time should be >= 0: ' + this._maxRetryTimeMs);
      }

      if (this._initialRetryDelayMs < 0) {
        throw (0, _error.newError)('Initial retry delay should >= 0: ' + this._initialRetryDelayMs);
      }

      if (this._multiplier < 1.0) {
        throw (0, _error.newError)('Multiplier should be >= 1.0: ' + this._multiplier);
      }

      if (this._jitterFactor < 0 || this._jitterFactor > 1) {
        throw (0, _error.newError)('Jitter factor should be in [0.0, 1.0]: ' + this._jitterFactor);
      }
    }
  }], [{
    key: "_canRetryOn",
    value: function _canRetryOn(error) {
      return error && error instanceof _error.Neo4jError && error.code && (error.code === _error.SERVICE_UNAVAILABLE || error.code === _error.SESSION_EXPIRED || this._isTransientError(error));
    }
  }, {
    key: "_isTransientError",
    value: function _isTransientError(error) {
      // Retries should not happen when transaction was explicitly terminated by the user.
      // Termination of transaction might result in two different error codes depending on where it was
      // terminated. These are really client errors but classification on the server is not entirely correct and
      // they are classified as transient.
      var code = error.code;

      if (code.indexOf('TransientError') >= 0) {
        if (code === 'Neo.TransientError.Transaction.Terminated' || code === 'Neo.TransientError.Transaction.LockClientStopped') {
          return false;
        }

        return true;
      }

      return false;
    }
  }]);
  return TransactionExecutor;
}();

exports["default"] = TransactionExecutor;

function _valueOrDefault(value, defaultValue) {
  if (value || value === 0) {
    return value;
  }

  return defaultValue;
}

},{"../error":231,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":12}],286:[function(require,module,exports){
"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var util = _interopRequireWildcard(require("./util"));

var _integer = require("../integer");

var _error = require("../error");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Internal holder of the transaction configuration.
 * It performs input validation and value conversion for further serialization by the Bolt protocol layer.
 * Users of the driver provide transaction configuration as regular objects `{timeout: 10, metadata: {key: 'value'}}`.
 * Driver converts such objects to {@link TxConfig} immediately and uses converted values everywhere.
 */
var TxConfig =
/*#__PURE__*/
function () {
  /**
   * @constructor
   * @param {Object} config the raw configuration object.
   */
  function TxConfig(config) {
    (0, _classCallCheck2["default"])(this, TxConfig);
    assertValidConfig(config);
    this.timeout = extractTimeout(config);
    this.metadata = extractMetadata(config);
  }
  /**
   * Get an empty config object.
   * @return {TxConfig} an empty config.
   */


  (0, _createClass2["default"])(TxConfig, [{
    key: "isEmpty",

    /**
     * Check if this config object is empty. I.e. has no configuration values specified.
     * @return {boolean} `true` if this object is empty, `false` otherwise.
     */
    value: function isEmpty() {
      return Object.values(this).every(function (value) {
        return value == null;
      });
    }
  }], [{
    key: "empty",
    value: function empty() {
      return EMPTY_CONFIG;
    }
  }]);
  return TxConfig;
}();

exports["default"] = TxConfig;
var EMPTY_CONFIG = new TxConfig({});
/**
 * @return {Integer|null}
 */

function extractTimeout(config) {
  if (util.isObject(config) && (config.timeout || config.timeout === 0)) {
    util.assertNumberOrInteger(config.timeout, 'Transaction timeout');
    var timeout = (0, _integer["int"])(config.timeout);

    if (timeout.isZero()) {
      throw (0, _error.newError)('Transaction timeout should not be zero');
    }

    if (timeout.isNegative()) {
      throw (0, _error.newError)('Transaction timeout should not be negative');
    }

    return timeout;
  }

  return null;
}
/**
 * @return {object|null}
 */


function extractMetadata(config) {
  if (util.isObject(config) && config.metadata) {
    var metadata = config.metadata;
    util.assertObject(metadata);

    if (Object.keys(metadata).length !== 0) {
      // not an empty object
      return metadata;
    }
  }

  return null;
}

function assertValidConfig(config) {
  if (config) {
    util.assertObject(config, 'Transaction config');
  }
}

},{"../error":231,"../integer":234,"./util":288,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/interopRequireWildcard":13}],287:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _uriJs = require("uri-js");

var _util = require("./util");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var DEFAULT_BOLT_PORT = 7687;
var DEFAULT_HTTP_PORT = 7474;
var DEFAULT_HTTPS_PORT = 7473;

var Url = function Url(scheme, host, port, hostAndPort, query) {
  (0, _classCallCheck2["default"])(this, Url);

  /**
   * Nullable scheme (protocol) of the URL.
   * Example: 'bolt', 'neo4j', 'http', 'https', etc.
   * @type {string}
   */
  this.scheme = scheme;
  /**
   * Nonnull host name or IP address. IPv6 not wrapped in square brackets.
   * Example: 'neo4j.com', 'localhost', '127.0.0.1', '192.168.10.15', '::1', '2001:4860:4860::8844', etc.
   * @type {string}
   */

  this.host = host;
  /**
   * Nonnull number representing port. Default port for the given scheme is used if given URL string
   * does not contain port. Example: 7687 for bolt, 7474 for HTTP and 7473 for HTTPS.
   * @type {number}
   */

  this.port = port;
  /**
   * Nonnull host name or IP address plus port, separated by ':'. IPv6 wrapped in square brackets.
   * Example: 'neo4j.com', 'neo4j.com:7687', '127.0.0.1', '127.0.0.1:8080', '[2001:4860:4860::8844]',
   * '[2001:4860:4860::8844]:9090', etc.
   * @type {string}
   */

  this.hostAndPort = hostAndPort;
  /**
   * Nonnull object representing parsed query string key-value pairs. Duplicated keys not supported.
   * Example: '{}', '{'key1': 'value1', 'key2': 'value2'}', etc.
   * @type {Object}
   */

  this.query = query;
};

function parseDatabaseUrl(url) {
  (0, _util.assertString)(url, 'URL');
  var sanitized = sanitizeUrl(url);
  var parsedUrl = (0, _uriJs.parse)(sanitized.url);
  var scheme = sanitized.schemeMissing ? null : extractScheme(parsedUrl.scheme);
  var host = extractHost(parsedUrl.host); // no square brackets for IPv6

  var formattedHost = formatHost(host); // has square brackets for IPv6

  var port = extractPort(parsedUrl.port, scheme);
  var hostAndPort = "".concat(formattedHost, ":").concat(port);
  var query = extractQuery(parsedUrl.query || extractResourceQueryString(parsedUrl.resourceName), url);
  return new Url(scheme, host, port, hostAndPort, query);
}

function extractResourceQueryString(resource) {
  if (typeof resource !== 'string') {
    return null;
  }

  var _resource$split = resource.split('?'),
      _resource$split2 = (0, _slicedToArray2["default"])(_resource$split, 2),
      _ = _resource$split2[0],
      query = _resource$split2[1];

  return query;
}

function sanitizeUrl(url) {
  url = url.trim();

  if (url.indexOf('://') === -1) {
    // url does not contain scheme, add dummy 'none://' to make parser work correctly
    return {
      schemeMissing: true,
      url: "none://".concat(url)
    };
  }

  return {
    schemeMissing: false,
    url: url
  };
}

function extractScheme(scheme) {
  if (scheme) {
    scheme = scheme.trim();

    if (scheme.charAt(scheme.length - 1) === ':') {
      scheme = scheme.substring(0, scheme.length - 1);
    }

    return scheme;
  }

  return null;
}

function extractHost(host, url) {
  if (!host) {
    throw new Error("Unable to extract host from ".concat(url));
  }

  return host.trim();
}

function extractPort(portString, scheme) {
  var port = parseInt(portString, 10);
  return port === 0 || port ? port : defaultPortForScheme(scheme);
}

function extractQuery(queryString, url) {
  var query = trimAndSanitizeQuery(queryString);
  var context = {};

  if (query) {
    query.split('&').forEach(function (pair) {
      var keyValue = pair.split('=');

      if (keyValue.length !== 2) {
        throw new Error("Invalid parameters: '".concat(keyValue, "' in URL '").concat(url, "'."));
      }

      var key = trimAndVerifyQueryElement(keyValue[0], 'key', url);
      var value = trimAndVerifyQueryElement(keyValue[1], 'value', url);

      if (context[key]) {
        throw new Error("Duplicated query parameters with key '".concat(key, "' in URL '").concat(url, "'"));
      }

      context[key] = value;
    });
  }

  return context;
}

function trimAndSanitizeQuery(query) {
  query = (query || '').trim();

  if (query && query.charAt(0) === '?') {
    query = query.substring(1, query.length);
  }

  return query;
}

function trimAndVerifyQueryElement(element, name, url) {
  element = (element || '').trim();

  if (!element) {
    throw new Error("Illegal empty ".concat(name, " in URL query '").concat(url, "'"));
  }

  return element;
}

function escapeIPv6Address(address) {
  var startsWithSquareBracket = address.charAt(0) === '[';
  var endsWithSquareBracket = address.charAt(address.length - 1) === ']';

  if (!startsWithSquareBracket && !endsWithSquareBracket) {
    return "[".concat(address, "]");
  } else if (startsWithSquareBracket && endsWithSquareBracket) {
    return address;
  } else {
    throw new Error("Illegal IPv6 address ".concat(address));
  }
}

function formatHost(host) {
  if (!host) {
    throw new Error("Illegal host ".concat(host));
  }

  var isIPv6Address = host.indexOf(':') >= 0;
  return isIPv6Address ? escapeIPv6Address(host) : host;
}

function formatIPv4Address(address, port) {
  return "".concat(address, ":").concat(port);
}

function formatIPv6Address(address, port) {
  var escapedAddress = escapeIPv6Address(address);
  return "".concat(escapedAddress, ":").concat(port);
}

function defaultPortForScheme(scheme) {
  if (scheme === 'http') {
    return DEFAULT_HTTP_PORT;
  } else if (scheme === 'https') {
    return DEFAULT_HTTPS_PORT;
  } else {
    return DEFAULT_BOLT_PORT;
  }
}

var _default = {
  parseDatabaseUrl: parseDatabaseUrl,
  defaultPortForScheme: defaultPortForScheme,
  formatIPv4Address: formatIPv4Address,
  formatIPv6Address: formatIPv6Address
};
exports["default"] = _default;

},{"./util":288,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/slicedToArray":21,"uri-js":229}],288:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isEmptyObjectOrNull = isEmptyObjectOrNull;
exports.isObject = isObject;
exports.isString = isString;
exports.assertObject = assertObject;
exports.assertString = assertString;
exports.assertNumber = assertNumber;
exports.assertNumberOrInteger = assertNumberOrInteger;
exports.assertValidDate = assertValidDate;
exports.validateQueryAndParameters = validateQueryAndParameters;
exports.ENCRYPTION_OFF = exports.ENCRYPTION_ON = void 0;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _integer = require("../integer");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var ENCRYPTION_ON = 'ENCRYPTION_ON';
exports.ENCRYPTION_ON = ENCRYPTION_ON;
var ENCRYPTION_OFF = 'ENCRYPTION_OFF';
exports.ENCRYPTION_OFF = ENCRYPTION_OFF;

function isEmptyObjectOrNull(obj) {
  if (obj === null) {
    return true;
  }

  if (!isObject(obj)) {
    return false;
  }

  for (var prop in obj) {
    if (obj.hasOwnProperty(prop)) {
      return false;
    }
  }

  return true;
}

function isObject(obj) {
  return (0, _typeof2["default"])(obj) === 'object' && !Array.isArray(obj) && obj !== null;
}
/**
 * Check and normalize given query and parameters.
 * @param {string|{text: string, parameters: object}} query the query to check.
 * @param {Object} parameters
 * @return {{query: string, params: object}} the normalized query with parameters.
 * @throws TypeError when either given query or parameters are invalid.
 */


function validateQueryAndParameters(query, parameters) {
  var validatedQuery = query;
  var params = parameters || {};

  if ((0, _typeof2["default"])(query) === 'object' && query.text) {
    validatedQuery = query.text;
    params = query.parameters || {};
  }

  assertCypherQuery(validatedQuery);
  assertQueryParameters(params);
  return {
    validatedQuery: validatedQuery,
    params: params
  };
}

function assertObject(obj, objName) {
  if (!isObject(obj)) {
    throw new TypeError(objName + ' expected to be an object but was: ' + JSON.stringify(obj));
  }

  return obj;
}

function assertString(obj, objName) {
  if (!isString(obj)) {
    throw new TypeError(objName + ' expected to be string but was: ' + JSON.stringify(obj));
  }

  return obj;
}

function assertNumber(obj, objName) {
  if (typeof obj !== 'number') {
    throw new TypeError(objName + ' expected to be a number but was: ' + JSON.stringify(obj));
  }

  return obj;
}

function assertNumberOrInteger(obj, objName) {
  if (typeof obj !== 'number' && !(0, _integer.isInt)(obj)) {
    throw new TypeError(objName + ' expected to be either a number or an Integer object but was: ' + JSON.stringify(obj));
  }

  return obj;
}

function assertValidDate(obj, objName) {
  if (Object.prototype.toString.call(obj) !== '[object Date]') {
    throw new TypeError(objName + ' expected to be a standard JavaScript Date but was: ' + JSON.stringify(obj));
  }

  if (Number.isNaN(obj.getTime())) {
    throw new TypeError(objName + ' expected to be valid JavaScript Date but its time was NaN: ' + JSON.stringify(obj));
  }

  return obj;
}

function assertCypherQuery(obj) {
  assertString(obj, 'Cypher query');

  if (obj.trim().length === 0) {
    throw new TypeError('Cypher query is expected to be a non-empty string.');
  }
}

function assertQueryParameters(obj) {
  if (!isObject(obj)) {
    // objects created with `Object.create(null)` do not have a constructor property
    var _constructor = obj.constructor ? ' ' + obj.constructor.name : '';

    throw new TypeError("Query parameters are expected to either be undefined/null or an object, given:".concat(_constructor, " ").concat(obj));
  }
}

function isString(str) {
  return Object.prototype.toString.call(str) === '[object String]';
}

},{"../integer":234,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/typeof":24}],289:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _error = require("./error");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function generateFieldLookup(keys) {
  var lookup = {};
  keys.forEach(function (name, idx) {
    lookup[name] = idx;
  });
  return lookup;
}
/**
 * Records make up the contents of the {@link Result}, and is how you access
 * the output of a query. A simple query might yield a result stream
 * with a single record, for instance:
 *
 *     MATCH (u:User) RETURN u.name, u.age
 *
 * This returns a stream of records with two fields, named `u.name` and `u.age`,
 * each record represents one user found by the query above. You can access
 * the values of each field either by name:
 *
 *     record.get("u.name")
 *
 * Or by it's position:
 *
 *     record.get(0)
 *
 * @access public
 */


var Record =
/*#__PURE__*/
function () {
  /**
   * Create a new record object.
   * @constructor
   * @protected
   * @param {string[]} keys An array of field keys, in the order the fields appear in the record
   * @param {Array} fields An array of field values
   * @param {Object} fieldLookup An object of fieldName -> value index, used to map
   *                            field names to values. If this is null, one will be
   *                            generated.
   */
  function Record(keys, fields) {
    var fieldLookup = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    (0, _classCallCheck2["default"])(this, Record);

    /**
     * Field keys, in the order the fields appear in the record.
     * @type {string[]}
     */
    this.keys = keys;
    /**
     * Number of fields
     * @type {Number}
     */

    this.length = keys.length;
    this._fields = fields;
    this._fieldLookup = fieldLookup || generateFieldLookup(keys);
  }
  /**
   * Run the given function for each field in this record. The function
   * will get three arguments - the value, the key and this record, in that
   * order.
   *
   * @param {function(value: Object, key: string, record: Record)} visitor the function to apply to each field.
   */


  (0, _createClass2["default"])(Record, [{
    key: "forEach",
    value: function forEach(visitor) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _step$value = (0, _slicedToArray2["default"])(_step.value, 2),
              key = _step$value[0],
              value = _step$value[1];

          visitor(value, key, this);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
    /**
     * Run the given function for each field in this record. The function
     * will get three arguments - the value, the key and this record, in that
     * order.
     *
     * @param {function(value: Object, key: string, record: Record)} visitor the function to apply on each field
     * and return a value that is saved to the returned Array.
     *
     * @returns {Array}
     */

  }, {
    key: "map",
    value: function map(visitor) {
      var resultArray = [];
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this.entries()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var _step2$value = (0, _slicedToArray2["default"])(_step2.value, 2),
              key = _step2$value[0],
              value = _step2$value[1];

          resultArray.push(visitor(value, key, this));
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return resultArray;
    }
    /**
     * Iterate over results. Each iteration will yield an array
     * of exactly two items - the key, and the value (in order).
     *
     * @generator
     * @returns {IterableIterator<Array>}
     */

  }, {
    key: "entries",
    value:
    /*#__PURE__*/
    _regenerator["default"].mark(function entries() {
      var i;
      return _regenerator["default"].wrap(function entries$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              i = 0;

            case 1:
              if (!(i < this.keys.length)) {
                _context.next = 7;
                break;
              }

              _context.next = 4;
              return [this.keys[i], this._fields[i]];

            case 4:
              i++;
              _context.next = 1;
              break;

            case 7:
            case "end":
              return _context.stop();
          }
        }
      }, entries, this);
    })
    /**
     * Iterate over values.
     *
     * @generator
     * @returns {IterableIterator<Object>}
     */

  }, {
    key: "values",
    value:
    /*#__PURE__*/
    _regenerator["default"].mark(function values() {
      var i;
      return _regenerator["default"].wrap(function values$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              i = 0;

            case 1:
              if (!(i < this.keys.length)) {
                _context2.next = 7;
                break;
              }

              _context2.next = 4;
              return this._fields[i];

            case 4:
              i++;
              _context2.next = 1;
              break;

            case 7:
            case "end":
              return _context2.stop();
          }
        }
      }, values, this);
    })
    /**
     * Iterate over values. Delegates to {@link Record#values}
     *
     * @generator
     * @returns {IterableIterator<Object>}
     */

  }, {
    key: Symbol.iterator,
    value:
    /*#__PURE__*/
    _regenerator["default"].mark(function value() {
      return _regenerator["default"].wrap(function value$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              return _context3.delegateYield(this.values(), "t0", 1);

            case 1:
            case "end":
              return _context3.stop();
          }
        }
      }, value, this);
    })
    /**
     * Generates an object out of the current Record
     *
     * @returns {Object}
     */

  }, {
    key: "toObject",
    value: function toObject() {
      var object = {};
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = this.entries()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var _step3$value = (0, _slicedToArray2["default"])(_step3.value, 2),
              key = _step3$value[0],
              _value = _step3$value[1];

          object[key] = _value;
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
            _iterator3["return"]();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      return object;
    }
    /**
     * Get a value from this record, either by index or by field key.
     *
     * @param {string|Number} key Field key, or the index of the field.
     * @returns {*}
     */

  }, {
    key: "get",
    value: function get(key) {
      var index;

      if (!(typeof key === 'number')) {
        index = this._fieldLookup[key];

        if (index === undefined) {
          throw (0, _error.newError)("This record has no field with key '" + key + "', available key are: [" + this.keys + '].');
        }
      } else {
        index = key;
      }

      if (index > this._fields.length - 1 || index < 0) {
        throw (0, _error.newError)("This record has no field with index '" + index + "'. Remember that indexes start at `0`, " + 'and make sure your query returns records in the shape you meant it to.');
      }

      return this._fields[index];
    }
    /**
     * Check if a value from this record, either by index or by field key, exists.
     *
     * @param {string|Number} key Field key, or the index of the field.
     * @returns {boolean}
     */

  }, {
    key: "has",
    value: function has(key) {
      // if key is a number, we check if it is in the _fields array
      if (typeof key === 'number') {
        return key >= 0 && key < this._fields.length;
      } // if it's not a number, we check _fieldLookup dictionary directly


      return this._fieldLookup[key] !== undefined;
    }
  }]);
  return Record;
}();

var _default = Record;
exports["default"] = _default;

},{"./error":231,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/slicedToArray":21,"@babel/runtime/regenerator":27}],290:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _error = require("./error");

var _resultSummary = _interopRequireDefault(require("./result-summary"));

var _rxjs = require("rxjs");

var _operators = require("rxjs/operators");

var _record = _interopRequireDefault(require("./record"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var States = {
  READY: 0,
  STREAMING: 1,
  COMPLETED: 2
  /**
   * The reactive result interface.
   */

};

var RxResult =
/*#__PURE__*/
function () {
  /**
   * @constructor
   * @protected
   * @param {Observable<Result>} result - An observable of single Result instance to relay requests.
   */
  function RxResult(result) {
    (0, _classCallCheck2["default"])(this, RxResult);
    var replayedResult = result.pipe((0, _operators.publishReplay)(1), (0, _operators.refCount)());
    this._result = replayedResult;
    this._keys = replayedResult.pipe((0, _operators.flatMap)(function (r) {
      return (0, _rxjs.from)(r.keys());
    }), (0, _operators.publishReplay)(1), (0, _operators.refCount)());
    this._records = new _rxjs.Subject();
    this._summary = new _rxjs.ReplaySubject();
    this._state = States.READY;
  }
  /**
   * Returns an observable that exposes a single item containing field names
   * returned by the executing query.
   *
   * Errors raised by actual query execution can surface on the returned
   * observable stream.
   *
   * @public
   * @returns {Observable<string[]>} - An observable stream (with exactly one element) of field names.
   */


  (0, _createClass2["default"])(RxResult, [{
    key: "keys",
    value: function keys() {
      return this._keys;
    }
    /**
     * Returns an observable that exposes each record returned by the executing query.
     *
     * Errors raised during the streaming phase can surface on the returned observable stream.
     *
     * @public
     * @returns {Observable<Record>} - An observable stream of records.
     */

  }, {
    key: "records",
    value: function records() {
      var _this = this;

      return this._result.pipe((0, _operators.flatMap)(function (result) {
        return new _rxjs.Observable(function (recordsObserver) {
          return _this._startStreaming({
            result: result,
            recordsObserver: recordsObserver
          });
        });
      }));
    }
    /**
     * Returns an observable that exposes a single item of {@link ResultSummary} that is generated by
     * the server after the streaming of the executing query is completed.
     *
     * *Subscribing to this stream before subscribing to records() stream causes the results to be discarded on the server.*
     *
     * @public
     * @returns {Observable<ResultSummary>} - An observable stream (with exactly one element) of result summary.
     */

  }, {
    key: "consume",
    value: function consume() {
      var _this2 = this;

      return this._result.pipe((0, _operators.flatMap)(function (result) {
        return new _rxjs.Observable(function (summaryObserver) {
          return _this2._startStreaming({
            result: result,
            summaryObserver: summaryObserver
          });
        });
      }));
    }
  }, {
    key: "_startStreaming",
    value: function _startStreaming() {
      var _this3 = this;

      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          result = _ref.result,
          _ref$recordsObserver = _ref.recordsObserver,
          recordsObserver = _ref$recordsObserver === void 0 ? null : _ref$recordsObserver,
          _ref$summaryObserver = _ref.summaryObserver,
          summaryObserver = _ref$summaryObserver === void 0 ? null : _ref$summaryObserver;

      var subscriptions = [];

      if (summaryObserver) {
        subscriptions.push(this._summary.subscribe(summaryObserver));
      }

      if (this._state < States.STREAMING) {
        this._state = States.STREAMING;

        if (recordsObserver) {
          subscriptions.push(this._records.subscribe(recordsObserver));
        }

        subscriptions.push({
          unsubscribe: function unsubscribe() {
            if (result._cancel) {
              result._cancel();
            }
          }
        });

        if (this._records.observers.length === 0) {
          result._cancel();
        }

        result.subscribe({
          onNext: function onNext(record) {
            _this3._records.next(record);
          },
          onCompleted: function onCompleted(summary) {
            _this3._records.complete();

            _this3._summary.next(summary);

            _this3._summary.complete();

            _this3._state = States.COMPLETED;
          },
          onError: function onError(err) {
            _this3._records.error(err);

            _this3._summary.error(err);

            _this3._state = States.COMPLETED;
          }
        });
      } else if (recordsObserver) {
        recordsObserver.error((0, _error.newError)('Streaming has already started/consumed with a previous records or summary subscription.'));
      }

      return function () {
        subscriptions.forEach(function (s) {
          return s.unsubscribe();
        });
      };
    }
  }]);
  return RxResult;
}();

exports["default"] = RxResult;

},{"./error":231,"./record":289,"./result-summary":291,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":12,"rxjs":28,"rxjs/operators":227}],291:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.queryType = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _integer = require("./integer");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * A ResultSummary instance contains structured metadata for a {@link Result}.
 * @access public
 */
var ResultSummary =
/*#__PURE__*/
function () {
  /**
   * @constructor
   * @param {string} query - The query this summary is for
   * @param {Object} parameters - Parameters for the query
   * @param {Object} metadata - Query metadata
   * @param {number} protocolVersion - Bolt protocol version
   */
  function ResultSummary(query, parameters, metadata, protocolVersion) {
    (0, _classCallCheck2["default"])(this, ResultSummary);

    /**
     * The query and parameters this summary is for.
     * @type {{text: string, parameters: Object}}
     * @public
     */
    this.query = {
      text: query,
      parameters: parameters
      /**
       * The type of query executed. Can be "r" for read-only query, "rw" for read-write query,
       * "w" for write-only query and "s" for schema-write query.
       * String constants are available in {@link queryType} object.
       * @type {string}
       * @public
       */

    };
    this.queryType = metadata.type;
    /**
     * Counters for operations the query triggered.
     * @type {QueryStatistics}
     * @public
     */

    this.counters = new QueryStatistics(metadata.stats || {}); // for backwards compatibility, remove in future version

    /**
     * Use {@link ResultSummary.counters} instead.
     * @type {QueryStatistics}
     * @deprecated
     */

    this.updateStatistics = this.counters;
    /**
     * This describes how the database will execute the query.
     * Query plan for the executed query if available, otherwise undefined.
     * Will only be populated for queries that start with "EXPLAIN".
     * @type {Plan}
     * @public
     */

    this.plan = metadata.plan || metadata.profile ? new Plan(metadata.plan || metadata.profile) : false;
    /**
     * This describes how the database did execute your query. This will contain detailed information about what
     * each step of the plan did. Profiled query plan for the executed query if available, otherwise undefined.
     * Will only be populated for queries that start with "PROFILE".
     * @type {ProfiledPlan}
     * @public
     */

    this.profile = metadata.profile ? new ProfiledPlan(metadata.profile) : false;
    /**
     * An array of notifications that might arise when executing the query. Notifications can be warnings about
     * problematic queries or other valuable information that can be presented in a client. Unlike failures
     * or errors, notifications do not affect the execution of a query.
     * @type {Array<Notification>}
     * @public
     */

    this.notifications = this._buildNotifications(metadata.notifications);
    /**
     * The basic information of the server where the result is obtained from.
     * @type {ServerInfo}
     * @public
     */

    this.server = new ServerInfo(metadata.server, protocolVersion);
    /**
     * The time it took the server to consume the result.
     * @type {number}
     * @public
     */

    this.resultConsumedAfter = metadata.result_consumed_after;
    /**
     * The time it took the server to make the result available for consumption in milliseconds.
     * @type {number}
     * @public
     */

    this.resultAvailableAfter = metadata.result_available_after;
    /**
     * The database name where this summary is obtained from.
     * @type {{name: string}}
     * @public
     */

    this.database = {
      name: metadata.db || null
    };
  }

  (0, _createClass2["default"])(ResultSummary, [{
    key: "_buildNotifications",
    value: function _buildNotifications(notifications) {
      if (!notifications) {
        return [];
      }

      return notifications.map(function (n) {
        return new Notification(n);
      });
    }
    /**
     * Check if the result summary has a plan
     * @return {boolean}
     */

  }, {
    key: "hasPlan",
    value: function hasPlan() {
      return this.plan instanceof Plan;
    }
    /**
     * Check if the result summary has a profile
     * @return {boolean}
     */

  }, {
    key: "hasProfile",
    value: function hasProfile() {
      return this.profile instanceof ProfiledPlan;
    }
  }]);
  return ResultSummary;
}();
/**
 * Class for execution plan received by prepending Cypher with EXPLAIN.
 * @access public
 */


var Plan =
/**
 * Create a Plan instance
 * @constructor
 * @param {Object} plan - Object with plan data
 */
function Plan(plan) {
  (0, _classCallCheck2["default"])(this, Plan);
  this.operatorType = plan.operatorType;
  this.identifiers = plan.identifiers;
  this.arguments = plan.args;
  this.children = plan.children ? plan.children.map(function (child) {
    return new Plan(child);
  }) : [];
};
/**
 * Class for execution plan received by prepending Cypher with PROFILE.
 * @access public
 */


var ProfiledPlan =
/*#__PURE__*/
function () {
  /**
   * Create a ProfiledPlan instance
   * @constructor
   * @param {Object} profile - Object with profile data
   */
  function ProfiledPlan(profile) {
    (0, _classCallCheck2["default"])(this, ProfiledPlan);
    this.operatorType = profile.operatorType;
    this.identifiers = profile.identifiers;
    this.arguments = profile.args;
    this.dbHits = valueOrDefault('dbHits', profile);
    this.rows = valueOrDefault('rows', profile);
    this.pageCacheMisses = valueOrDefault('pageCacheMisses', profile);
    this.pageCacheHits = valueOrDefault('pageCacheHits', profile);
    this.pageCacheHitRatio = valueOrDefault('pageCacheHitRatio', profile);
    this.time = valueOrDefault('time', profile);
    this.children = profile.children ? profile.children.map(function (child) {
      return new ProfiledPlan(child);
    }) : [];
  }

  (0, _createClass2["default"])(ProfiledPlan, [{
    key: "hasPageCacheStats",
    value: function hasPageCacheStats() {
      return this.pageCacheMisses > 0 || this.pageCacheHits > 0 || this.pageCacheHitRatio > 0;
    }
  }]);
  return ProfiledPlan;
}();
/**
 * Get statistical information for a {@link Result}.
 * @access public
 */


var QueryStatistics =
/*#__PURE__*/
function () {
  /**
   * Structurize the statistics
   * @constructor
   * @param {Object} statistics - Result statistics
   */
  function QueryStatistics(statistics) {
    var _this = this;

    (0, _classCallCheck2["default"])(this, QueryStatistics);
    this._stats = {
      nodesCreated: 0,
      nodesDeleted: 0,
      relationshipsCreated: 0,
      relationshipsDeleted: 0,
      propertiesSet: 0,
      labelsAdded: 0,
      labelsRemoved: 0,
      indexesAdded: 0,
      indexesRemoved: 0,
      constraintsAdded: 0,
      constraintsRemoved: 0
    };
    this._systemUpdates = 0;
    Object.keys(statistics).forEach(function (index) {
      // To camelCase
      var camelCaseIndex = index.replace(/(-\w)/g, function (m) {
        return m[1].toUpperCase();
      });

      if (camelCaseIndex in _this._stats) {
        _this._stats[camelCaseIndex] = intValue(statistics[index]);
      } else if (camelCaseIndex === 'systemUpdates') {
        _this._systemUpdates = intValue(statistics[index]);
      }
    });
    this._stats = Object.freeze(this._stats);
  }
  /**
   * Did the database get updated?
   * @return {boolean}
   */


  (0, _createClass2["default"])(QueryStatistics, [{
    key: "containsUpdates",
    value: function containsUpdates() {
      var _this2 = this;

      return Object.keys(this._stats).reduce(function (last, current) {
        return last + _this2._stats[current];
      }, 0) > 0;
    }
    /**
     * Returns the query statistics updates in a dictionary.
     * @returns {*}
     */

  }, {
    key: "updates",
    value: function updates() {
      return this._stats;
    }
    /**
     * Return true if the system database get updated, otherwise false
     * @returns {boolean} - If the system database get updated or not.
     */

  }, {
    key: "containsSystemUpdates",
    value: function containsSystemUpdates() {
      return this._systemUpdates > 0;
    }
    /**
     * @returns {number} - Number of system updates
     */

  }, {
    key: "systemUpdates",
    value: function systemUpdates() {
      return this._systemUpdates;
    }
  }]);
  return QueryStatistics;
}();
/**
 * Class for Cypher notifications
 * @access public
 */


var Notification =
/*#__PURE__*/
function () {
  /**
   * Create a Notification instance
   * @constructor
   * @param {Object} notification - Object with notification data
   */
  function Notification(notification) {
    (0, _classCallCheck2["default"])(this, Notification);
    this.code = notification.code;
    this.title = notification.title;
    this.description = notification.description;
    this.severity = notification.severity;
    this.position = Notification._constructPosition(notification.position);
  }

  (0, _createClass2["default"])(Notification, null, [{
    key: "_constructPosition",
    value: function _constructPosition(pos) {
      if (!pos) {
        return {};
      }

      return {
        offset: intValue(pos.offset),
        line: intValue(pos.line),
        column: intValue(pos.column)
      };
    }
  }]);
  return Notification;
}();
/**
 * Class for exposing server info from a result.
 * @access public
 */


var ServerInfo =
/**
 * Create a ServerInfo instance
 * @constructor
 * @param {Object} serverMeta - Object with serverMeta data
 * @param {number} protocolVersion - Bolt protocol version
 */
function ServerInfo(serverMeta, protocolVersion) {
  (0, _classCallCheck2["default"])(this, ServerInfo);

  if (serverMeta) {
    this.address = serverMeta.address;
    this.version = serverMeta.version;
  }

  this.protocolVersion = protocolVersion;
};

function intValue(value) {
  return (0, _integer.isInt)(value) ? value.toInt() : value;
}

function valueOrDefault(key, values) {
  var defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

  if (key in values) {
    var value = values[key];
    return (0, _integer.isInt)(value) ? value.toInt() : value;
  } else {
    return defaultValue;
  }
}
/**
 * The constants for query types
 * @type {{SCHEMA_WRITE: string, WRITE_ONLY: string, READ_ONLY: string, READ_WRITE: string}}
 */


var queryType = {
  READ_ONLY: 'r',
  READ_WRITE: 'rw',
  WRITE_ONLY: 'w',
  SCHEMA_WRITE: 's'
};
exports.queryType = queryType;
var _default = ResultSummary;
exports["default"] = _default;

},{"./integer":234,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":12}],292:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _resultSummary = _interopRequireDefault(require("./result-summary"));

var _connectionHolder = require("./internal/connection-holder");

var _streamObservers = require("./internal/stream-observers");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var DEFAULT_ON_ERROR = function DEFAULT_ON_ERROR(error) {
  console.log('Uncaught error when processing result: ' + error);
};

var DEFAULT_ON_COMPLETED = function DEFAULT_ON_COMPLETED(summary) {};

var DEFAULT_METADATA_SUPPLIER = function DEFAULT_METADATA_SUPPLIER(metadata) {};
/**
 * A stream of {@link Record} representing the result of a query.
 * Can be consumed eagerly as {@link Promise} resolved with array of records and {@link ResultSummary}
 * summary, or rejected with error that contains {@link string} code and {@link string} message.
 * Alternatively can be consumed lazily using {@link Result#subscribe} function.
 * @access public
 */


var Result =
/*#__PURE__*/
function () {
  /**
   * Inject the observer to be used.
   * @constructor
   * @access private
   * @param {Promise<ResultStreamObserver>} streamObserverPromise
   * @param {mixed} query - Cypher query to execute
   * @param {Object} parameters - Map with parameters to use in query
   * @param {ConnectionHolder} connectionHolder - to be notified when result is either fully consumed or error happened.
   */
  function Result(streamObserverPromise, query, parameters, connectionHolder) {
    (0, _classCallCheck2["default"])(this, Result);
    this._stack = captureStacktrace();
    this._streamObserverPromise = streamObserverPromise;
    this._p = null;
    this._query = query;
    this._parameters = parameters || {};
    this._connectionHolder = connectionHolder || _connectionHolder.EMPTY_CONNECTION_HOLDER;
  }
  /**
   * Returns a promise for the field keys.
   *
   * *Should not be combined with {@link Result#subscribe} function.*
   *
   * @public
   * @returns {Promise<string[]>} - Field keys, in the order they will appear in records.
   }
   */


  (0, _createClass2["default"])(Result, [{
    key: "keys",
    value: function keys() {
      var _this = this;

      return new Promise(function (resolve, reject) {
        _this._streamObserverPromise.then(function (observer) {
          return observer.subscribe({
            onKeys: function onKeys(keys) {
              return resolve(keys);
            },
            onError: function onError(err) {
              return reject(err);
            }
          });
        });
      });
    }
    /**
     * Returns a promise for the result summary.
     *
     * *Should not be combined with {@link Result#subscribe} function.*
     *
     * @public
     * @returns {Promise<ResultSummary>} - Result summary.
     *
     */

  }, {
    key: "summary",
    value: function summary() {
      var _this2 = this;

      return new Promise(function (resolve, reject) {
        _this2._streamObserverPromise.then(function (o) {
          o.cancel();
          o.subscribe({
            onCompleted: function onCompleted(metadata) {
              return resolve(metadata);
            },
            onError: function onError(err) {
              return reject(err);
            }
          });
        });
      });
    }
    /**
     * Create and return new Promise
     *
     * @private
     * @return {Promise} new Promise.
     */

  }, {
    key: "_getOrCreatePromise",
    value: function _getOrCreatePromise() {
      var _this3 = this;

      if (!this._p) {
        this._p = new Promise(function (resolve, reject) {
          var records = [];
          var observer = {
            onNext: function onNext(record) {
              records.push(record);
            },
            onCompleted: function onCompleted(summary) {
              resolve({
                records: records,
                summary: summary
              });
            },
            onError: function onError(error) {
              reject(error);
            }
          };

          _this3.subscribe(observer);
        });
      }

      return this._p;
    }
    /**
     * Waits for all results and calls the passed in function with the results.
     *
     * *Should not be combined with {@link Result#subscribe} function.*
     *
     * @param {function(result: {records:Array<Record>, summary: ResultSummary})} onFulfilled - function to be called
     * when finished.
     * @param {function(error: {message:string, code:string})} onRejected - function to be called upon errors.
     * @return {Promise} promise.
     */

  }, {
    key: "then",
    value: function then(onFulfilled, onRejected) {
      return this._getOrCreatePromise().then(onFulfilled, onRejected);
    }
    /**
     * Catch errors when using promises.
     *
     * *Should not be combined with {@link Result#subscribe} function.*
     *
     * @param {function(error: Neo4jError)} onRejected - Function to be called upon errors.
     * @return {Promise} promise.
     */

  }, {
    key: "catch",
    value: function _catch(onRejected) {
      return this._getOrCreatePromise()["catch"](onRejected);
    }
    /**
     * Stream records to observer as they come in, this is a more efficient method
     * of handling the results, and allows you to handle arbitrarily large results.
     *
     * @param {Object} observer - Observer object
     * @param {function(keys: string[])} observer.onKeys - handle stream head, the field keys.
     * @param {function(record: Record)} observer.onNext - handle records, one by one.
     * @param {function(summary: ResultSummary)} observer.onCompleted - handle stream tail, the result summary.
     * @param {function(error: {message:string, code:string})} observer.onError - handle errors.
     * @return
     */

  }, {
    key: "subscribe",
    value: function subscribe(observer) {
      var _this4 = this;

      var onCompletedOriginal = observer.onCompleted || DEFAULT_ON_COMPLETED;

      var onCompletedWrapper = function onCompletedWrapper(metadata) {
        var connectionHolder = _this4._connectionHolder;
        var query = _this4._query;
        var parameters = _this4._parameters;

        function complete(protocolVersion) {
          onCompletedOriginal.call(observer, new _resultSummary["default"](query, parameters, metadata, protocolVersion));
        }

        function release() {
          // notify connection holder that the used connection is not needed any more because result has
          // been fully consumed; call the original onCompleted callback after that
          return connectionHolder.releaseConnection();
        }

        connectionHolder.getConnection().then( // onFulfilled:
        function (connection) {
          release().then(function () {
            return complete(connection !== undefined ? connection.protocol().version : undefined);
          });
        }, // onRejected:
        function (_) {
          complete();
        });
      };

      observer.onCompleted = onCompletedWrapper;
      var onErrorOriginal = observer.onError || DEFAULT_ON_ERROR;

      var onErrorWrapper = function onErrorWrapper(error) {
        // notify connection holder that the used connection is not needed any more because error happened
        // and result can't bee consumed any further; call the original onError callback after that
        _this4._connectionHolder.releaseConnection().then(function () {
          replaceStacktrace(error, _this4._stack);
          onErrorOriginal.call(observer, error);
        });
      };

      observer.onError = onErrorWrapper;

      this._streamObserverPromise.then(function (o) {
        return o.subscribe(observer);
      });
    }
    /**
     * Signals the stream observer that the future records should be discarded on the server.
     *
     * @protected
     * @since 4.0.0
     */

  }, {
    key: "_cancel",
    value: function _cancel() {
      this._streamObserverPromise.then(function (o) {
        return o.cancel();
      });
    }
  }]);
  return Result;
}();

function captureStacktrace() {
  var error = new Error('');

  if (error.stack) {
    return error.stack.replace(/^Error(\n\r)*/, ''); // we don't need the 'Error\n' part, if only it exists
  }

  return null;
}

function replaceStacktrace(error, newStack) {
  if (newStack) {
    // Error.prototype.toString() concatenates error.name and error.message nicely
    // then we add the rest of the stack trace
    error.stack = error.toString() + '\n' + newStack;
  }
}

var _default = Result;
exports["default"] = _default;

},{"./internal/connection-holder":256,"./internal/stream-observers":283,"./result-summary":291,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":12}],293:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _driver = require("./driver");

var _error = require("./error");

var _connectionProviderRouting = _interopRequireDefault(require("./internal/connection-provider-routing"));

var _leastConnectedLoadBalancingStrategy = _interopRequireDefault(require("./internal/least-connected-load-balancing-strategy"));

var _connectionErrorHandler = _interopRequireDefault(require("./internal/connection-error-handler"));

var _configuredCustomResolver = _interopRequireDefault(require("./internal/resolver/configured-custom-resolver"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * A driver that supports routing in a causal cluster.
 * @private
 */
var RoutingDriver =
/*#__PURE__*/
function (_Driver) {
  (0, _inherits2["default"])(RoutingDriver, _Driver);

  function RoutingDriver(address, routingContext, userAgent) {
    var _this;

    var token = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    var config = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
    (0, _classCallCheck2["default"])(this, RoutingDriver);
    _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(RoutingDriver).call(this, address, userAgent, token, validateConfig(config)));
    _this._routingContext = routingContext;
    return _this;
  }

  (0, _createClass2["default"])(RoutingDriver, [{
    key: "_afterConstruction",
    value: function _afterConstruction() {
      this._log.info("Routing driver ".concat(this._id, " created for server address ").concat(this._address));
    }
  }, {
    key: "_createConnectionProvider",
    value: function _createConnectionProvider(address, userAgent, authToken) {
      return new _connectionProviderRouting["default"]({
        id: this._id,
        address: address,
        routingContext: this._routingContext,
        hostNameResolver: createHostNameResolver(this._config),
        config: this._config,
        log: this._log,
        userAgent: userAgent,
        authToken: authToken
      });
    }
  }, {
    key: "_supportsRouting",
    value: function _supportsRouting() {
      return true;
    }
  }]);
  return RoutingDriver;
}(_driver.Driver);
/**
 * @private
 * @returns {ConfiguredCustomResolver} new custom resolver that wraps the passed-in resolver function.
 *              If resolved function is not specified, it defaults to an identity resolver.
 */


function createHostNameResolver(config) {
  return new _configuredCustomResolver["default"](config.resolver);
}
/**
 * @private
 * @returns {Object} the given config.
 */


function validateConfig(config) {
  var resolver = config.resolver;

  if (resolver && typeof resolver !== 'function') {
    throw new TypeError("Configured resolver should be a function. Got: ".concat(resolver));
  }

  return config;
}

var _default = RoutingDriver;
exports["default"] = _default;

},{"./driver":230,"./error":231,"./internal/connection-error-handler":254,"./internal/connection-provider-routing":259,"./internal/least-connected-load-balancing-strategy":265,"./internal/resolver/configured-custom-resolver":276,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/getPrototypeOf":10,"@babel/runtime/helpers/inherits":11,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/possibleConstructorReturn":19}],294:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _rxjs = require("rxjs");

var _operators = require("rxjs/operators");

var _resultRx = _interopRequireDefault(require("./result-rx"));

var _session = _interopRequireDefault(require("./session"));

var _transactionRx = _interopRequireDefault(require("./transaction-rx"));

var _constants = require("./internal/constants");

var _txConfig = _interopRequireDefault(require("./internal/tx-config"));

var _retryLogicRx = _interopRequireDefault(require("./internal/retry-logic-rx"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * A Reactive session, which provides the same functionality as {@link Session} but through a Reactive API.
 */
var RxSession =
/*#__PURE__*/
function () {
  /**
   * Constructs a reactive session with given default session instance and provided driver configuration.
   *
   * @protected
   * @param {Object} param - Object parameter
   * @param {Session} param.session - The underlying session instance to relay requests
   */
  function RxSession() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        session = _ref.session,
        config = _ref.config;

    (0, _classCallCheck2["default"])(this, RxSession);
    this._session = session;
    this._retryLogic = _createRetryLogic(config);
  }
  /**
   * Creates a reactive result that will execute the  query with the provided parameters and the provided
   * transaction configuration that applies to the underlying auto-commit transaction.
   *
   * @public
   * @param {string} query - Query to be executed.
   * @param {Object} parameters - Parameter values to use in query execution.
   * @param {TransactionConfig} transactionConfig - Configuration for the new auto-commit transaction.
   * @returns {RxResult} - A reactive result
   */


  (0, _createClass2["default"])(RxSession, [{
    key: "run",
    value: function run(query, parameters, transactionConfig) {
      var _this = this;

      return new _resultRx["default"](new _rxjs.Observable(function (observer) {
        try {
          observer.next(_this._session.run(query, parameters, transactionConfig));
          observer.complete();
        } catch (err) {
          observer.error(err);
        }

        return function () {};
      }));
    }
    /**
     * Starts a new explicit transaction with the provided transaction configuration.
     *
     * @public
     * @param {TransactionConfig} transactionConfig - Configuration for the new transaction.
     * @returns {Observable<RxTransaction>} - A reactive stream that will generate at most **one** RxTransaction instance.
     */

  }, {
    key: "beginTransaction",
    value: function beginTransaction(transactionConfig) {
      return this._beginTransaction(this._session._mode, transactionConfig);
    }
    /**
     * Executes the provided unit of work in a {@link READ} reactive transaction which is created with the provided
     * transaction configuration.
     * @public
     * @param {function(txc: RxTransaction): Observable} work - A unit of work to be executed.
     * @param {TransactionConfig} transactionConfig - Configuration for the enclosing transaction created by the driver.
     * @returns {Observable} - A reactive stream returned by the unit of work.
     */

  }, {
    key: "readTransaction",
    value: function readTransaction(work, transactionConfig) {
      return this._runTransaction(_constants.ACCESS_MODE_READ, work, transactionConfig);
    }
    /**
     * Executes the provided unit of work in a {@link WRITE} reactive transaction which is created with the provided
     * transaction configuration.
     * @public
     * @param {function(txc: RxTransaction): Observable} work - A unit of work to be executed.
     * @param {TransactionConfig} transactionConfig - Configuration for the enclosing transaction created by the driver.
     * @returns {Observable} - A reactive stream returned by the unit of work.
     */

  }, {
    key: "writeTransaction",
    value: function writeTransaction(work, transactionConfig) {
      return this._runTransaction(_constants.ACCESS_MODE_WRITE, work, transactionConfig);
    }
    /**
     * Closes this reactive session.
     *
     * @public
     * @returns {Observable} - An empty reactive stream
     */

  }, {
    key: "close",
    value: function close() {
      var _this2 = this;

      return new _rxjs.Observable(function (observer) {
        _this2._session.close().then(function () {
          observer.complete();
        })["catch"](function (err) {
          return observer.error(err);
        });
      });
    }
    /**
     * Returns the bookmark received following the last successfully completed query, which is executed
     * either in an {@link RxTransaction} obtained from this session instance or directly through one of
     * the {@link RxSession#run} method of this session instance.
     *
     * If no bookmark was received or if this transaction was rolled back, the bookmark value will not be
     * changed.
     *
     * @public
     * @returns {string}
     */

  }, {
    key: "lastBookmark",
    value: function lastBookmark() {
      return this._session.lastBookmark();
    }
    /**
     * @private
     */

  }, {
    key: "_beginTransaction",
    value: function _beginTransaction(accessMode, transactionConfig) {
      var _this3 = this;

      var txConfig = _txConfig["default"].empty();

      if (transactionConfig) {
        txConfig = new _txConfig["default"](transactionConfig);
      }

      return new _rxjs.Observable(function (observer) {
        try {
          observer.next(new _transactionRx["default"](_this3._session._beginTransaction(accessMode, txConfig)));
          observer.complete();
        } catch (err) {
          observer.error(err);
        }

        return function () {};
      });
    }
    /**
     * @private
     */

  }, {
    key: "_runTransaction",
    value: function _runTransaction(accessMode, work, transactionConfig) {
      var txConfig = _txConfig["default"].empty();

      if (transactionConfig) {
        txConfig = new _txConfig["default"](transactionConfig);
      }

      return this._retryLogic.retry(this._beginTransaction(accessMode, transactionConfig).pipe((0, _operators.flatMap)(function (txc) {
        return (0, _rxjs.defer)(function () {
          try {
            return work(txc);
          } catch (err) {
            return (0, _rxjs.throwError)(err);
          }
        }).pipe((0, _operators.catchError)(function (err) {
          return txc.rollback().pipe((0, _operators.concat)((0, _rxjs.throwError)(err)));
        }), (0, _operators.concat)(txc.commit()));
      })));
    }
  }]);
  return RxSession;
}();

exports["default"] = RxSession;

function _createRetryLogic(config) {
  var maxRetryTimeout = config && config.maxTransactionRetryTime ? config.maxTransactionRetryTime : null;
  return new _retryLogicRx["default"]({
    maxRetryTimeout: maxRetryTimeout
  });
}

},{"./internal/constants":264,"./internal/retry-logic-rx":277,"./internal/tx-config":286,"./result-rx":290,"./session":295,"./transaction-rx":298,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":12,"rxjs":28,"rxjs/operators":227}],295:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _streamObservers = require("./internal/stream-observers");

var _result = _interopRequireDefault(require("./result"));

var _transaction = _interopRequireDefault(require("./transaction"));

var _error = require("./error");

var _util = require("./internal/util");

var _connectionHolder = _interopRequireDefault(require("./internal/connection-holder"));

var _driver = _interopRequireDefault(require("./driver"));

var _constants = require("./internal/constants");

var _transactionExecutor = _interopRequireDefault(require("./internal/transaction-executor"));

var _bookmark = _interopRequireDefault(require("./internal/bookmark"));

var _txConfig = _interopRequireDefault(require("./internal/tx-config"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * A Session instance is used for handling the connection and
 * sending queries through the connection.
 * In a single session, multiple queries will be executed serially.
 * In order to execute parallel queries, multiple sessions are required.
 * @access public
 */
var Session =
/*#__PURE__*/
function () {
  /**
   * @constructor
   * @protected
   * @param {Object} args
   * @param {string} args.mode the default access mode for this session.
   * @param {ConnectionProvider} args.connectionProvider - The connection provider to acquire connections from.
   * @param {Bookmark} args.bookmark - The initial bookmark for this session.
   * @param {string} args.database the database name
   * @param {Object} args.config={} - This driver configuration.
   * @param {boolean} args.reactive - Whether this session should create reactive streams
   * @param {number} args.fetchSize - Defines how many records is pulled in each pulling batch
   */
  function Session(_ref) {
    var mode = _ref.mode,
        connectionProvider = _ref.connectionProvider,
        bookmark = _ref.bookmark,
        database = _ref.database,
        config = _ref.config,
        reactive = _ref.reactive,
        fetchSize = _ref.fetchSize;
    (0, _classCallCheck2["default"])(this, Session);
    this._mode = mode;
    this._database = database;
    this._reactive = reactive;
    this._fetchSize = fetchSize;
    this._readConnectionHolder = new _connectionHolder["default"]({
      mode: _constants.ACCESS_MODE_READ,
      database: database,
      bookmark: bookmark,
      connectionProvider: connectionProvider
    });
    this._writeConnectionHolder = new _connectionHolder["default"]({
      mode: _constants.ACCESS_MODE_WRITE,
      database: database,
      bookmark: bookmark,
      connectionProvider: connectionProvider
    });
    this._open = true;
    this._hasTx = false;
    this._lastBookmark = bookmark;
    this._transactionExecutor = _createTransactionExecutor(config);
    this._onComplete = this._onCompleteCallback.bind(this);
  }
  /**
   * Run Cypher query
   * Could be called with a query object i.e.: `{text: "MATCH ...", prameters: {param: 1}}`
   * or with the query and parameters as separate arguments.
   *
   * @public
   * @param {mixed} query - Cypher query to execute
   * @param {Object} parameters - Map with parameters to use in query
   * @param {TransactionConfig} [transactionConfig] - Configuration for the new auto-commit transaction.
   * @return {Result} New Result.
   */


  (0, _createClass2["default"])(Session, [{
    key: "run",
    value: function run(query, parameters, transactionConfig) {
      var _this = this;

      var _validateQueryAndPara = (0, _util.validateQueryAndParameters)(query, parameters),
          validatedQuery = _validateQueryAndPara.validatedQuery,
          params = _validateQueryAndPara.params;

      var autoCommitTxConfig = transactionConfig ? new _txConfig["default"](transactionConfig) : _txConfig["default"].empty();
      return this._run(validatedQuery, params, function (connection) {
        _this._assertSessionIsOpen();

        return connection.protocol().run(validatedQuery, params, {
          bookmark: _this._lastBookmark,
          txConfig: autoCommitTxConfig,
          mode: _this._mode,
          database: _this._database,
          afterComplete: _this._onComplete,
          reactive: _this._reactive,
          fetchSize: _this._fetchSize
        });
      });
    }
  }, {
    key: "_run",
    value: function _run(query, parameters, customRunner) {
      var connectionHolder = this._connectionHolderWithMode(this._mode);

      var observerPromise;

      if (!this._open) {
        observerPromise = Promise.resolve(new _streamObservers.FailedObserver({
          error: (0, _error.newError)('Cannot run query in a closed session.')
        }));
      } else if (!this._hasTx && connectionHolder.initializeConnection()) {
        observerPromise = connectionHolder.getConnection().then(function (connection) {
          return customRunner(connection);
        })["catch"](function (error) {
          return Promise.resolve(new _streamObservers.FailedObserver({
            error: error
          }));
        });
      } else {
        observerPromise = Promise.resolve(new _streamObservers.FailedObserver({
          error: (0, _error.newError)('Queries cannot be run directly on a ' + 'session with an open transaction; either run from within the ' + 'transaction or use a different session.')
        }));
      }

      return new _result["default"](observerPromise, query, parameters, connectionHolder);
    }
    /**
     * Begin a new transaction in this session. A session can have at most one transaction running at a time, if you
     * want to run multiple concurrent transactions, you should use multiple concurrent sessions.
     *
     * While a transaction is open the session cannot be used to run queries outside the transaction.
     *
     * @param {TransactionConfig} [transactionConfig] - Configuration for the new auto-commit transaction.
     * @returns {Transaction} New Transaction.
     */

  }, {
    key: "beginTransaction",
    value: function beginTransaction(transactionConfig) {
      // this function needs to support bookmarks parameter for backwards compatibility
      // parameter was of type {string|string[]} and represented either a single or multiple bookmarks
      // that's why we need to check parameter type and decide how to interpret the value
      var arg = transactionConfig;

      var txConfig = _txConfig["default"].empty();

      if (arg) {
        txConfig = new _txConfig["default"](arg);
      }

      return this._beginTransaction(this._mode, txConfig);
    }
  }, {
    key: "_beginTransaction",
    value: function _beginTransaction(accessMode, txConfig) {
      if (!this._open) {
        throw (0, _error.newError)('Cannot begin a transaction on a closed session.');
      }

      if (this._hasTx) {
        throw (0, _error.newError)('You cannot begin a transaction on a session with an open transaction; ' + 'either run from within the transaction or use a different session.');
      }

      var mode = _driver["default"]._validateSessionMode(accessMode);

      var connectionHolder = this._connectionHolderWithMode(mode);

      connectionHolder.initializeConnection();
      this._hasTx = true;
      var tx = new _transaction["default"]({
        connectionHolder: connectionHolder,
        onClose: this._transactionClosed.bind(this),
        onBookmark: this._updateBookmark.bind(this),
        onConnection: this._assertSessionIsOpen.bind(this),
        reactive: this._reactive,
        fetchSize: this._fetchSize
      });

      tx._begin(this._lastBookmark, txConfig);

      return tx;
    }
  }, {
    key: "_assertSessionIsOpen",
    value: function _assertSessionIsOpen() {
      if (!this._open) {
        throw (0, _error.newError)('You cannot run more transactions on a closed session.');
      }
    }
  }, {
    key: "_transactionClosed",
    value: function _transactionClosed() {
      this._hasTx = false;
    }
    /**
     * Return the bookmark received following the last completed {@link Transaction}.
     *
     * @return {string[]} A reference to a previous transaction.
     */

  }, {
    key: "lastBookmark",
    value: function lastBookmark() {
      return this._lastBookmark.values();
    }
    /**
     * Execute given unit of work in a {@link READ} transaction.
     *
     * Transaction will automatically be committed unless the given function throws or returns a rejected promise.
     * Some failures of the given function or the commit itself will be retried with exponential backoff with initial
     * delay of 1 second and maximum retry time of 30 seconds. Maximum retry time is configurable via driver config's
     * `maxTransactionRetryTime` property in milliseconds.
     *
     * @param {function(tx: Transaction): Promise} transactionWork - Callback that executes operations against
     * a given {@link Transaction}.
     * @param {TransactionConfig} [transactionConfig] - Configuration for all transactions started to execute the unit of work.
     * @return {Promise} Resolved promise as returned by the given function or rejected promise when given
     * function or commit fails.
     */

  }, {
    key: "readTransaction",
    value: function readTransaction(transactionWork, transactionConfig) {
      var config = new _txConfig["default"](transactionConfig);
      return this._runTransaction(_constants.ACCESS_MODE_READ, config, transactionWork);
    }
    /**
     * Execute given unit of work in a {@link WRITE} transaction.
     *
     * Transaction will automatically be committed unless the given function throws or returns a rejected promise.
     * Some failures of the given function or the commit itself will be retried with exponential backoff with initial
     * delay of 1 second and maximum retry time of 30 seconds. Maximum retry time is configurable via driver config's
     * `maxTransactionRetryTime` property in milliseconds.
     *
     * @param {function(tx: Transaction): Promise} transactionWork - Callback that executes operations against
     * a given {@link Transaction}.
     * @param {TransactionConfig} [transactionConfig] - Configuration for all transactions started to execute the unit of work.
     * @return {Promise} Resolved promise as returned by the given function or rejected promise when given
     * function or commit fails.
     */

  }, {
    key: "writeTransaction",
    value: function writeTransaction(transactionWork, transactionConfig) {
      var config = new _txConfig["default"](transactionConfig);
      return this._runTransaction(_constants.ACCESS_MODE_WRITE, config, transactionWork);
    }
  }, {
    key: "_runTransaction",
    value: function _runTransaction(accessMode, transactionConfig, transactionWork) {
      var _this2 = this;

      return this._transactionExecutor.execute(function () {
        return _this2._beginTransaction(accessMode, transactionConfig);
      }, transactionWork);
    }
    /**
     * Update value of the last bookmark.
     * @param {Bookmark} newBookmark - The new bookmark.
     */

  }, {
    key: "_updateBookmark",
    value: function _updateBookmark(newBookmark) {
      if (newBookmark && !newBookmark.isEmpty()) {
        this._lastBookmark = newBookmark;
      }
    }
    /**
     * Close this session.
     * @return {Promise}
     */

  }, {
    key: "close",
    value: function () {
      var _close = (0, _asyncToGenerator2["default"])(
      /*#__PURE__*/
      _regenerator["default"].mark(function _callee() {
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!this._open) {
                  _context.next = 7;
                  break;
                }

                this._open = false;

                this._transactionExecutor.close();

                _context.next = 5;
                return this._readConnectionHolder.close();

              case 5:
                _context.next = 7;
                return this._writeConnectionHolder.close();

              case 7:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function close() {
        return _close.apply(this, arguments);
      }

      return close;
    }()
  }, {
    key: "_connectionHolderWithMode",
    value: function _connectionHolderWithMode(mode) {
      if (mode === _constants.ACCESS_MODE_READ) {
        return this._readConnectionHolder;
      } else if (mode === _constants.ACCESS_MODE_WRITE) {
        return this._writeConnectionHolder;
      } else {
        throw (0, _error.newError)('Unknown access mode: ' + mode);
      }
    }
  }, {
    key: "_onCompleteCallback",
    value: function _onCompleteCallback(meta) {
      this._updateBookmark(new _bookmark["default"](meta.bookmark));
    }
  }]);
  return Session;
}();

function _createTransactionExecutor(config) {
  var maxRetryTimeMs = config && config.maxTransactionRetryTime ? config.maxTransactionRetryTime : null;
  return new _transactionExecutor["default"](maxRetryTimeMs);
}

var _default = Session;
exports["default"] = _default;

},{"./driver":230,"./error":231,"./internal/bookmark":242,"./internal/connection-holder":256,"./internal/constants":264,"./internal/stream-observers":283,"./internal/transaction-executor":285,"./internal/tx-config":286,"./internal/util":288,"./result":292,"./transaction":299,"@babel/runtime/helpers/asyncToGenerator":4,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/regenerator":27}],296:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isPoint = isPoint;
exports.Point = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _util = require("./internal/util");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var POINT_IDENTIFIER_PROPERTY = '__isPoint__';
/**
 * Represents a single two or three-dimensional point in a particular coordinate reference system.
 * Created `Point` objects are frozen with `Object.freeze()` in constructor and thus immutable.
 */

var Point =
/*#__PURE__*/
function () {
  /**
   * @constructor
   * @param {Integer|number} srid - The coordinate reference system identifier.
   * @param {number} x - The `x` coordinate of the point.
   * @param {number} y - The `y` coordinate of the point.
   * @param {number} [z=undefined] - The `z` coordinate of the point or `undefined` if point has 2 dimensions.
   */
  function Point(srid, x, y, z) {
    (0, _classCallCheck2["default"])(this, Point);

    /**
     * The coordinate reference system identifier.
     * @type {Integer|number}
     */
    this.srid = (0, _util.assertNumberOrInteger)(srid, 'SRID');
    /**
     * The `x` coordinate of the point.
     * @type {number}
     */

    this.x = (0, _util.assertNumber)(x, 'X coordinate');
    /**
     * The `y` coordinate of the point.
     * @type {number}
     */

    this.y = (0, _util.assertNumber)(y, 'Y coordinate');
    /**
     * The `z` coordinate of the point or `undefined` if point is 2-dimensional.
     * @type {number}
     */

    this.z = z === null || z === undefined ? z : (0, _util.assertNumber)(z, 'Z coordinate');
    Object.freeze(this);
  }
  /**
   * @ignore
   */


  (0, _createClass2["default"])(Point, [{
    key: "toString",
    value: function toString() {
      return this.z || this.z === 0 ? "Point{srid=".concat(formatAsFloat(this.srid), ", x=").concat(formatAsFloat(this.x), ", y=").concat(formatAsFloat(this.y), ", z=").concat(formatAsFloat(this.z), "}") : "Point{srid=".concat(formatAsFloat(this.srid), ", x=").concat(formatAsFloat(this.x), ", y=").concat(formatAsFloat(this.y), "}");
    }
  }]);
  return Point;
}();

exports.Point = Point;

function formatAsFloat(number) {
  return Number.isInteger(number) ? number + '.0' : number.toString();
}

Object.defineProperty(Point.prototype, POINT_IDENTIFIER_PROPERTY, {
  value: true,
  enumerable: false,
  configurable: false,
  writable: false
});
/**
 * Test if given object is an instance of {@link Point} class.
 * @param {Object} obj the object to test.
 * @return {boolean} `true` if given object is a {@link Point}, `false` otherwise.
 */

function isPoint(obj) {
  return (obj && obj[POINT_IDENTIFIER_PROPERTY]) === true;
}

},{"./internal/util":288,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":12}],297:[function(require,module,exports){
"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isDuration = isDuration;
exports.isLocalTime = isLocalTime;
exports.isTime = isTime;
exports.isDate = isDate;
exports.isLocalDateTime = isLocalDateTime;
exports.isDateTime = isDateTime;
exports.DateTime = exports.LocalDateTime = exports.Date = exports.Time = exports.LocalTime = exports.Duration = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var util = _interopRequireWildcard(require("./internal/temporal-util"));

var _util = require("./internal/util");

var _error = require("./error");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var IDENTIFIER_PROPERTY_ATTRIBUTES = {
  value: true,
  enumerable: false,
  configurable: false,
  writable: false
};
var DURATION_IDENTIFIER_PROPERTY = '__isDuration__';
var LOCAL_TIME_IDENTIFIER_PROPERTY = '__isLocalTime__';
var TIME_IDENTIFIER_PROPERTY = '__isTime__';
var DATE_IDENTIFIER_PROPERTY = '__isDate__';
var LOCAL_DATE_TIME_IDENTIFIER_PROPERTY = '__isLocalDateTime__';
var DATE_TIME_IDENTIFIER_PROPERTY = '__isDateTime__';
/**
 * Represents an ISO 8601 duration. Contains both date-based values (years, months, days) and time-based values (seconds, nanoseconds).
 * Created `Duration` objects are frozen with `Object.freeze()` in constructor and thus immutable.
 */

var Duration =
/*#__PURE__*/
function () {
  /**
   * @constructor
   * @param {Integer|number} months - The number of months for the new duration.
   * @param {Integer|number} days - The number of days for the new duration.
   * @param {Integer|number} seconds - The number of seconds for the new duration.
   * @param {Integer|number} nanoseconds - The number of nanoseconds for the new duration.
   */
  function Duration(months, days, seconds, nanoseconds) {
    (0, _classCallCheck2["default"])(this, Duration);

    /**
     * The number of months.
     * @type {Integer|number}
     */
    this.months = (0, _util.assertNumberOrInteger)(months, 'Months');
    /**
     * The number of days.
     * @type {Integer|number}
     */

    this.days = (0, _util.assertNumberOrInteger)(days, 'Days');
    (0, _util.assertNumberOrInteger)(seconds, 'Seconds');
    (0, _util.assertNumberOrInteger)(nanoseconds, 'Nanoseconds');
    /**
     * The number of seconds.
     * @type {Integer|number}
     */

    this.seconds = util.normalizeSecondsForDuration(seconds, nanoseconds);
    /**
     * The number of nanoseconds.
     * @type {Integer|number}
     */

    this.nanoseconds = util.normalizeNanosecondsForDuration(nanoseconds);
    Object.freeze(this);
  }
  /**
   * @ignore
   */


  (0, _createClass2["default"])(Duration, [{
    key: "toString",
    value: function toString() {
      return util.durationToIsoString(this.months, this.days, this.seconds, this.nanoseconds);
    }
  }]);
  return Duration;
}();

exports.Duration = Duration;
Object.defineProperty(Duration.prototype, DURATION_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);
/**
 * Test if given object is an instance of {@link Duration} class.
 * @param {Object} obj the object to test.
 * @return {boolean} `true` if given object is a {@link Duration}, `false` otherwise.
 */

function isDuration(obj) {
  return hasIdentifierProperty(obj, DURATION_IDENTIFIER_PROPERTY);
}
/**
 * Represents an instant capturing the time of day, but not the date, nor the timezone.
 * Created {@link LocalTime} objects are frozen with `Object.freeze()` in constructor and thus immutable.
 */


var LocalTime =
/*#__PURE__*/
function () {
  /**
   * @constructor
   * @param {Integer|number} hour - The hour for the new local time.
   * @param {Integer|number} minute - The minute for the new local time.
   * @param {Integer|number} second - The second for the new local time.
   * @param {Integer|number} nanosecond - The nanosecond for the new local time.
   */
  function LocalTime(hour, minute, second, nanosecond) {
    (0, _classCallCheck2["default"])(this, LocalTime);

    /**
     * The hour.
     * @type {Integer|number}
     */
    this.hour = util.assertValidHour(hour);
    /**
     * The minute.
     * @type {Integer|number}
     */

    this.minute = util.assertValidMinute(minute);
    /**
     * The second.
     * @type {Integer|number}
     */

    this.second = util.assertValidSecond(second);
    /**
     * The nanosecond.
     * @type {Integer|number}
     */

    this.nanosecond = util.assertValidNanosecond(nanosecond);
    Object.freeze(this);
  }
  /**
   * Create a {@link LocalTime} object from the given standard JavaScript `Date` and optional nanoseconds.
   * Year, month, day and time zone offset components of the given date are ignored.
   * @param {global.Date} standardDate - The standard JavaScript date to convert.
   * @param {Integer|number|undefined} nanosecond - The optional amount of nanoseconds.
   * @return {LocalTime} New LocalTime.
   */


  (0, _createClass2["default"])(LocalTime, [{
    key: "toString",

    /**
     * @ignore
     */
    value: function toString() {
      return util.timeToIsoString(this.hour, this.minute, this.second, this.nanosecond);
    }
  }], [{
    key: "fromStandardDate",
    value: function fromStandardDate(standardDate, nanosecond) {
      verifyStandardDateAndNanos(standardDate, nanosecond);
      return new LocalTime(standardDate.getHours(), standardDate.getMinutes(), standardDate.getSeconds(), util.totalNanoseconds(standardDate, nanosecond));
    }
  }]);
  return LocalTime;
}();

exports.LocalTime = LocalTime;
Object.defineProperty(LocalTime.prototype, LOCAL_TIME_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);
/**
 * Test if given object is an instance of {@link LocalTime} class.
 * @param {Object} obj the object to test.
 * @return {boolean} `true` if given object is a {@link LocalTime}, `false` otherwise.
 */

function isLocalTime(obj) {
  return hasIdentifierProperty(obj, LOCAL_TIME_IDENTIFIER_PROPERTY);
}
/**
 * Represents an instant capturing the time of day, and the timezone offset in seconds, but not the date.
 * Created {@link Time} objects are frozen with `Object.freeze()` in constructor and thus immutable.
 */


var Time =
/*#__PURE__*/
function () {
  /**
   * @constructor
   * @param {Integer|number} hour - The hour for the new local time.
   * @param {Integer|number} minute - The minute for the new local time.
   * @param {Integer|number} second - The second for the new local time.
   * @param {Integer|number} nanosecond - The nanosecond for the new local time.
   * @param {Integer|number} timeZoneOffsetSeconds - The time zone offset in seconds. Value represents the difference, in seconds, from UTC to local time.
   * This is different from standard JavaScript `Date.getTimezoneOffset()` which is the difference, in minutes, from local time to UTC.
   */
  function Time(hour, minute, second, nanosecond, timeZoneOffsetSeconds) {
    (0, _classCallCheck2["default"])(this, Time);

    /**
     * The hour.
     * @type {Integer|number}
     */
    this.hour = util.assertValidHour(hour);
    /**
     * The minute.
     * @type {Integer|number}
     */

    this.minute = util.assertValidMinute(minute);
    /**
     * The second.
     * @type {Integer|number}
     */

    this.second = util.assertValidSecond(second);
    /**
     * The nanosecond.
     * @type {Integer|number}
     */

    this.nanosecond = util.assertValidNanosecond(nanosecond);
    /**
     * The time zone offset in seconds.
     * @type {Integer|number}
     */

    this.timeZoneOffsetSeconds = (0, _util.assertNumberOrInteger)(timeZoneOffsetSeconds, 'Time zone offset in seconds');
    Object.freeze(this);
  }
  /**
   * Create a {@link Time} object from the given standard JavaScript `Date` and optional nanoseconds.
   * Year, month and day components of the given date are ignored.
   * @param {global.Date} standardDate - The standard JavaScript date to convert.
   * @param {Integer|number|undefined} nanosecond - The optional amount of nanoseconds.
   * @return {Time} New Time.
   */


  (0, _createClass2["default"])(Time, [{
    key: "toString",

    /**
     * @ignore
     */
    value: function toString() {
      return util.timeToIsoString(this.hour, this.minute, this.second, this.nanosecond) + util.timeZoneOffsetToIsoString(this.timeZoneOffsetSeconds);
    }
  }], [{
    key: "fromStandardDate",
    value: function fromStandardDate(standardDate, nanosecond) {
      verifyStandardDateAndNanos(standardDate, nanosecond);
      return new Time(standardDate.getHours(), standardDate.getMinutes(), standardDate.getSeconds(), util.totalNanoseconds(standardDate, nanosecond), util.timeZoneOffsetInSeconds(standardDate));
    }
  }]);
  return Time;
}();

exports.Time = Time;
Object.defineProperty(Time.prototype, TIME_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);
/**
 * Test if given object is an instance of {@link Time} class.
 * @param {Object} obj the object to test.
 * @return {boolean} `true` if given object is a {@link Time}, `false` otherwise.
 */

function isTime(obj) {
  return hasIdentifierProperty(obj, TIME_IDENTIFIER_PROPERTY);
}
/**
 * Represents an instant capturing the date, but not the time, nor the timezone.
 * Created {@link Date} objects are frozen with `Object.freeze()` in constructor and thus immutable.
 */


var Date =
/*#__PURE__*/
function () {
  /**
   * @constructor
   * @param {Integer|number} year - The year for the new local date.
   * @param {Integer|number} month - The month for the new local date.
   * @param {Integer|number} day - The day for the new local date.
   */
  function Date(year, month, day) {
    (0, _classCallCheck2["default"])(this, Date);

    /**
     * The year.
     * @type {Integer|number}
     */
    this.year = util.assertValidYear(year);
    /**
     * The month.
     * @type {Integer|number}
     */

    this.month = util.assertValidMonth(month);
    /**
     * The day.
     * @type {Integer|number}
     */

    this.day = util.assertValidDay(day);
    Object.freeze(this);
  }
  /**
   * Create a {@link Date} object from the given standard JavaScript `Date`.
   * Hour, minute, second, millisecond and time zone offset components of the given date are ignored.
   * @param {global.Date} standardDate - The standard JavaScript date to convert.
   * @return {Date} New Date.
   */


  (0, _createClass2["default"])(Date, [{
    key: "toString",

    /**
     * @ignore
     */
    value: function toString() {
      return util.dateToIsoString(this.year, this.month, this.day);
    }
  }], [{
    key: "fromStandardDate",
    value: function fromStandardDate(standardDate) {
      verifyStandardDateAndNanos(standardDate, null);
      return new Date(standardDate.getFullYear(), standardDate.getMonth() + 1, standardDate.getDate());
    }
  }]);
  return Date;
}();

exports.Date = Date;
Object.defineProperty(Date.prototype, DATE_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);
/**
 * Test if given object is an instance of {@link Date} class.
 * @param {Object} obj - The object to test.
 * @return {boolean} `true` if given object is a {@link Date}, `false` otherwise.
 */

function isDate(obj) {
  return hasIdentifierProperty(obj, DATE_IDENTIFIER_PROPERTY);
}
/**
 * Represents an instant capturing the date and the time, but not the timezone.
 * Created {@link LocalDateTime} objects are frozen with `Object.freeze()` in constructor and thus immutable.
 */


var LocalDateTime =
/*#__PURE__*/
function () {
  /**
   * @constructor
   * @param {Integer|number} year - The year for the new local date.
   * @param {Integer|number} month - The month for the new local date.
   * @param {Integer|number} day - The day for the new local date.
   * @param {Integer|number} hour - The hour for the new local time.
   * @param {Integer|number} minute - The minute for the new local time.
   * @param {Integer|number} second - The second for the new local time.
   * @param {Integer|number} nanosecond - The nanosecond for the new local time.
   */
  function LocalDateTime(year, month, day, hour, minute, second, nanosecond) {
    (0, _classCallCheck2["default"])(this, LocalDateTime);

    /**
     * The year.
     * @type {Integer|number}
     */
    this.year = util.assertValidYear(year);
    /**
     * The month.
     * @type {Integer|number}
     */

    this.month = util.assertValidMonth(month);
    /**
     * The day.
     * @type {Integer|number}
     */

    this.day = util.assertValidDay(day);
    /**
     * The hour.
     * @type {Integer|number}
     */

    this.hour = util.assertValidHour(hour);
    /**
     * The minute.
     * @type {Integer|number}
     */

    this.minute = util.assertValidMinute(minute);
    /**
     * The second.
     * @type {Integer|number}
     */

    this.second = util.assertValidSecond(second);
    /**
     * The nanosecond.
     * @type {Integer|number}
     */

    this.nanosecond = util.assertValidNanosecond(nanosecond);
    Object.freeze(this);
  }
  /**
   * Create a {@link LocalDateTime} object from the given standard JavaScript `Date` and optional nanoseconds.
   * Time zone offset component of the given date is ignored.
   * @param {global.Date} standardDate - The standard JavaScript date to convert.
   * @param {Integer|number|undefined} nanosecond - The optional amount of nanoseconds.
   * @return {LocalDateTime} New LocalDateTime.
   */


  (0, _createClass2["default"])(LocalDateTime, [{
    key: "toString",

    /**
     * @ignore
     */
    value: function toString() {
      return localDateTimeToString(this.year, this.month, this.day, this.hour, this.minute, this.second, this.nanosecond);
    }
  }], [{
    key: "fromStandardDate",
    value: function fromStandardDate(standardDate, nanosecond) {
      verifyStandardDateAndNanos(standardDate, nanosecond);
      return new LocalDateTime(standardDate.getFullYear(), standardDate.getMonth() + 1, standardDate.getDate(), standardDate.getHours(), standardDate.getMinutes(), standardDate.getSeconds(), util.totalNanoseconds(standardDate, nanosecond));
    }
  }]);
  return LocalDateTime;
}();

exports.LocalDateTime = LocalDateTime;
Object.defineProperty(LocalDateTime.prototype, LOCAL_DATE_TIME_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);
/**
 * Test if given object is an instance of {@link LocalDateTime} class.
 * @param {Object} obj - The object to test.
 * @return {boolean} `true` if given object is a {@link LocalDateTime}, `false` otherwise.
 */

function isLocalDateTime(obj) {
  return hasIdentifierProperty(obj, LOCAL_DATE_TIME_IDENTIFIER_PROPERTY);
}
/**
 * Represents an instant capturing the date, the time and the timezone identifier.
 * Created {@ DateTime} objects are frozen with `Object.freeze()` in constructor and thus immutable.
 */


var DateTime =
/*#__PURE__*/
function () {
  /**
   * @constructor
   * @param {Integer|number} year - The year for the new date-time.
   * @param {Integer|number} month - The month for the new date-time.
   * @param {Integer|number} day - The day for the new date-time.
   * @param {Integer|number} hour - The hour for the new date-time.
   * @param {Integer|number} minute - The minute for the new date-time.
   * @param {Integer|number} second - The second for the new date-time.
   * @param {Integer|number} nanosecond - The nanosecond for the new date-time.
   * @param {Integer|number} timeZoneOffsetSeconds - The time zone offset in seconds. Either this argument or `timeZoneId` should be defined.
   * Value represents the difference, in seconds, from UTC to local time.
   * This is different from standard JavaScript `Date.getTimezoneOffset()` which is the difference, in minutes, from local time to UTC.
   * @param {string|null} timeZoneId - The time zone id for the new date-time. Either this argument or `timeZoneOffsetSeconds` should be defined.
   */
  function DateTime(year, month, day, hour, minute, second, nanosecond, timeZoneOffsetSeconds, timeZoneId) {
    (0, _classCallCheck2["default"])(this, DateTime);

    /**
     * The year.
     * @type {Integer|number}
     */
    this.year = util.assertValidYear(year);
    /**
     * The month.
     * @type {Integer|number}
     */

    this.month = util.assertValidMonth(month);
    /**
     * The day.
     * @type {Integer|number}
     */

    this.day = util.assertValidDay(day);
    /**
     * The hour.
     * @type {Integer|number}
     */

    this.hour = util.assertValidHour(hour);
    /**
     * The minute.
     * @type {Integer|number}
     */

    this.minute = util.assertValidMinute(minute);
    /**
     * The second.
     * @type {Integer|number}
     */

    this.second = util.assertValidSecond(second);
    /**
     * The nanosecond.
     * @type {Integer|number}
     */

    this.nanosecond = util.assertValidNanosecond(nanosecond);

    var _verifyTimeZoneArgume = verifyTimeZoneArguments(timeZoneOffsetSeconds, timeZoneId),
        _verifyTimeZoneArgume2 = (0, _slicedToArray2["default"])(_verifyTimeZoneArgume, 2),
        offset = _verifyTimeZoneArgume2[0],
        id = _verifyTimeZoneArgume2[1];
    /**
     * The time zone offset in seconds.
     *
     * *Either this or {@link timeZoneId} is defined.*
     *
     * @type {Integer|number}
     */


    this.timeZoneOffsetSeconds = offset;
    /**
     * The time zone id.
     *
     * *Either this or {@link timeZoneOffsetSeconds} is defined.*
     *
     * @type {string}
     */

    this.timeZoneId = id;
    Object.freeze(this);
  }
  /**
   * Create a {@link DateTime} object from the given standard JavaScript `Date` and optional nanoseconds.
   * @param {global.Date} standardDate - The standard JavaScript date to convert.
   * @param {Integer|number|undefined} nanosecond - The optional amount of nanoseconds.
   * @return {DateTime} New DateTime.
   */


  (0, _createClass2["default"])(DateTime, [{
    key: "toString",

    /**
     * @ignore
     */
    value: function toString() {
      var localDateTimeStr = localDateTimeToString(this.year, this.month, this.day, this.hour, this.minute, this.second, this.nanosecond);
      var timeZoneStr = this.timeZoneId ? "[".concat(this.timeZoneId, "]") : util.timeZoneOffsetToIsoString(this.timeZoneOffsetSeconds);
      return localDateTimeStr + timeZoneStr;
    }
  }], [{
    key: "fromStandardDate",
    value: function fromStandardDate(standardDate, nanosecond) {
      verifyStandardDateAndNanos(standardDate, nanosecond);
      return new DateTime(standardDate.getFullYear(), standardDate.getMonth() + 1, standardDate.getDate(), standardDate.getHours(), standardDate.getMinutes(), standardDate.getSeconds(), util.totalNanoseconds(standardDate, nanosecond), util.timeZoneOffsetInSeconds(standardDate), null
      /* no time zone id */
      );
    }
  }]);
  return DateTime;
}();

exports.DateTime = DateTime;
Object.defineProperty(DateTime.prototype, DATE_TIME_IDENTIFIER_PROPERTY, IDENTIFIER_PROPERTY_ATTRIBUTES);
/**
 * Test if given object is an instance of {@link DateTime} class.
 * @param {Object} obj - The object to test.
 * @return {boolean} `true` if given object is a {@link DateTime}, `false` otherwise.
 */

function isDateTime(obj) {
  return hasIdentifierProperty(obj, DATE_TIME_IDENTIFIER_PROPERTY);
}

function hasIdentifierProperty(obj, property) {
  return (obj && obj[property]) === true;
}

function localDateTimeToString(year, month, day, hour, minute, second, nanosecond) {
  return util.dateToIsoString(year, month, day) + 'T' + util.timeToIsoString(hour, minute, second, nanosecond);
}

function verifyTimeZoneArguments(timeZoneOffsetSeconds, timeZoneId) {
  var offsetDefined = timeZoneOffsetSeconds || timeZoneOffsetSeconds === 0;
  var idDefined = timeZoneId && timeZoneId !== '';

  if (offsetDefined && !idDefined) {
    (0, _util.assertNumberOrInteger)(timeZoneOffsetSeconds, 'Time zone offset in seconds');
    return [timeZoneOffsetSeconds, null];
  } else if (!offsetDefined && idDefined) {
    (0, _util.assertString)(timeZoneId, 'Time zone ID');
    return [null, timeZoneId];
  } else if (offsetDefined && idDefined) {
    throw (0, _error.newError)("Unable to create DateTime with both time zone offset and id. Please specify either of them. Given offset: ".concat(timeZoneOffsetSeconds, " and id: ").concat(timeZoneId));
  } else {
    throw (0, _error.newError)("Unable to create DateTime without either time zone offset or id. Please specify either of them. Given offset: ".concat(timeZoneOffsetSeconds, " and id: ").concat(timeZoneId));
  }
}

function verifyStandardDateAndNanos(standardDate, nanosecond) {
  (0, _util.assertValidDate)(standardDate, 'Standard date');

  if (nanosecond !== null && nanosecond !== undefined) {
    (0, _util.assertNumberOrInteger)(nanosecond, 'Nanosecond');
  }
}

},{"./error":231,"./internal/temporal-util":284,"./internal/util":288,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/interopRequireWildcard":13,"@babel/runtime/helpers/slicedToArray":21}],298:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _rxjs = require("rxjs");

var _resultRx = _interopRequireDefault(require("./result-rx"));

var _transaction = _interopRequireDefault(require("./transaction"));

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * A reactive transaction, which provides the same functionality as {@link Transaction} but through a Reactive API.
 */
var RxTransaction =
/*#__PURE__*/
function () {
  /**
   * @constructor
   * @protected
   * @param {Transaction} txc - The underlying transaction instance to relay requests
   */
  function RxTransaction(txc) {
    (0, _classCallCheck2["default"])(this, RxTransaction);
    this._txc = txc;
  }
  /**
   * Creates a reactive result that will execute the query in this transaction, with the provided parameters.
   *
   * @public
   * @param {string} query - Query to be executed.
   * @param {Object} parameters - Parameter values to use in query execution.
   * @returns {RxResult} - A reactive result
   */


  (0, _createClass2["default"])(RxTransaction, [{
    key: "run",
    value: function run(query, parameters) {
      var _this = this;

      return new _resultRx["default"](new _rxjs.Observable(function (observer) {
        try {
          observer.next(_this._txc.run(query, parameters));
          observer.complete();
        } catch (err) {
          observer.error(err);
        }

        return function () {};
      }));
    }
    /**
     *  Commits the transaction.
     *
     * @public
     * @returns {Observable} - An empty observable
     */

  }, {
    key: "commit",
    value: function commit() {
      var _this2 = this;

      return new _rxjs.Observable(function (observer) {
        _this2._txc.commit().then(function () {
          observer.complete();
        })["catch"](function (err) {
          return observer.error(err);
        });
      });
    }
    /**
     *  Rolls back the transaction.
     *
     * @public
     * @returns {Observable} - An empty observable
     */

  }, {
    key: "rollback",
    value: function rollback() {
      var _this3 = this;

      return new _rxjs.Observable(function (observer) {
        _this3._txc.rollback().then(function () {
          observer.complete();
        })["catch"](function (err) {
          return observer.error(err);
        });
      });
    }
  }]);
  return RxTransaction;
}();

exports["default"] = RxTransaction;

},{"./result-rx":290,"./transaction":299,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":12,"rxjs":28}],299:[function(require,module,exports){
"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _result = _interopRequireDefault(require("./result"));

var _util = require("./internal/util");

var _connectionHolder = _interopRequireWildcard(require("./internal/connection-holder"));

var _connectionHolderReadonly = _interopRequireDefault(require("./internal/connection-holder-readonly"));

var _bookmark = _interopRequireDefault(require("./internal/bookmark"));

var _txConfig = _interopRequireDefault(require("./internal/tx-config"));

var _streamObservers = require("./internal/stream-observers");

var _error = require("./error");

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Represents a transaction in the Neo4j database.
 *
 * @access public
 */
var Transaction =
/*#__PURE__*/
function () {
  /**
   * @constructor
   * @param {ConnectionHolder} connectionHolder - the connection holder to get connection from.
   * @param {function()} onClose - Function to be called when transaction is committed or rolled back.
   * @param {function(bookmark: Bookmark)} onBookmark callback invoked when new bookmark is produced.
   * * @param {function()} onConnection - Function to be called when a connection is obtained to ensure the conneciton
   * is not yet released.
   * @param {boolean} reactive whether this transaction generates reactive streams
   * @param {number} fetchSize - the record fetch size in each pulling batch.
   */
  function Transaction(_ref) {
    var connectionHolder = _ref.connectionHolder,
        onClose = _ref.onClose,
        onBookmark = _ref.onBookmark,
        onConnection = _ref.onConnection,
        reactive = _ref.reactive,
        fetchSize = _ref.fetchSize;
    (0, _classCallCheck2["default"])(this, Transaction);
    this._connectionHolder = connectionHolder;
    this._reactive = reactive;
    this._state = _states.ACTIVE;
    this._onClose = onClose;
    this._onBookmark = onBookmark;
    this._onConnection = onConnection;
    this._onError = this._onErrorCallback.bind(this);
    this._onComplete = this._onCompleteCallback.bind(this);
    this._fetchSize = fetchSize;
    this._results = [];
  }

  (0, _createClass2["default"])(Transaction, [{
    key: "_begin",
    value: function _begin(bookmark, txConfig) {
      var _this = this;

      this._connectionHolder.getConnection().then(function (conn) {
        _this._onConnection();

        return conn.protocol().beginTransaction({
          bookmark: bookmark,
          txConfig: txConfig,
          mode: _this._connectionHolder.mode(),
          database: _this._connectionHolder.database(),
          beforeError: _this._onError,
          afterComplete: _this._onComplete
        });
      })["catch"](function (error) {
        return _this._onError(error);
      });
    }
    /**
     * Run Cypher query
     * Could be called with a query object i.e.: `{text: "MATCH ...", parameters: {param: 1}}`
     * or with the query and parameters as separate arguments.
     * @param {mixed} query - Cypher query to execute
     * @param {Object} parameters - Map with parameters to use in query
     * @return {Result} New Result
     */

  }, {
    key: "run",
    value: function run(query, parameters) {
      var _validateQueryAndPara = (0, _util.validateQueryAndParameters)(query, parameters),
          validatedQuery = _validateQueryAndPara.validatedQuery,
          params = _validateQueryAndPara.params;

      var result = this._state.run(validatedQuery, params, {
        connectionHolder: this._connectionHolder,
        onError: this._onError,
        onComplete: this._onComplete,
        onConnection: this._onConnection,
        reactive: this._reactive,
        fetchSize: this._fetchSize
      });

      this._results.push(result);

      return result;
    }
    /**
     * Commits the transaction and returns the result.
     *
     * After committing the transaction can no longer be used.
     *
     * @returns {Promise<void>} An empty promise if committed successfully or error if any error happened during commit.
     */

  }, {
    key: "commit",
    value: function commit() {
      var committed = this._state.commit({
        connectionHolder: this._connectionHolder,
        onError: this._onError,
        onComplete: this._onComplete,
        onConnection: this._onConnection,
        pendingResults: this._results
      });

      this._state = committed.state; // clean up

      this._onClose();

      return new Promise(function (resolve, reject) {
        committed.result.subscribe({
          onCompleted: function onCompleted() {
            return resolve();
          },
          onError: function onError(error) {
            return reject(error);
          }
        });
      });
    }
    /**
     * Rollbacks the transaction.
     *
     * After rolling back, the transaction can no longer be used.
     *
     * @returns {Promise<void>} An empty promise if rolled back successfully or error if any error happened during
     * rollback.
     */

  }, {
    key: "rollback",
    value: function rollback() {
      var rolledback = this._state.rollback({
        connectionHolder: this._connectionHolder,
        onError: this._onError,
        onComplete: this._onComplete,
        onConnection: this._onConnection,
        pendingResults: this._results
      });

      this._state = rolledback.state; // clean up

      this._onClose();

      return new Promise(function (resolve, reject) {
        rolledback.result.subscribe({
          onCompleted: function onCompleted() {
            return resolve();
          },
          onError: function onError(error) {
            return reject(error);
          }
        });
      });
    }
    /**
     * Check if this transaction is active, which means commit and rollback did not happen.
     * @return {boolean} `true` when not committed and not rolled back, `false` otherwise.
     */

  }, {
    key: "isOpen",
    value: function isOpen() {
      return this._state === _states.ACTIVE;
    }
  }, {
    key: "_onErrorCallback",
    value: function _onErrorCallback(err) {
      // error will be "acknowledged" by sending a RESET message
      // database will then forget about this transaction and cleanup all corresponding resources
      // it is thus safe to move this transaction to a FAILED state and disallow any further interactions with it
      this._state = _states.FAILED;

      this._onClose(); // release connection back to the pool


      return this._connectionHolder.releaseConnection();
    }
  }, {
    key: "_onCompleteCallback",
    value: function _onCompleteCallback(meta) {
      this._onBookmark(new _bookmark["default"](meta.bookmark));
    }
  }]);
  return Transaction;
}();

var _states = {
  // The transaction is running with no explicit success or failure marked
  ACTIVE: {
    commit: function commit(_ref2) {
      var connectionHolder = _ref2.connectionHolder,
          onError = _ref2.onError,
          onComplete = _ref2.onComplete,
          onConnection = _ref2.onConnection,
          pendingResults = _ref2.pendingResults;
      return {
        result: finishTransaction(true, connectionHolder, onError, onComplete, onConnection, pendingResults),
        state: _states.SUCCEEDED
      };
    },
    rollback: function rollback(_ref3) {
      var connectionHolder = _ref3.connectionHolder,
          onError = _ref3.onError,
          onComplete = _ref3.onComplete,
          onConnection = _ref3.onConnection,
          pendingResults = _ref3.pendingResults;
      return {
        result: finishTransaction(false, connectionHolder, onError, onComplete, onConnection, pendingResults),
        state: _states.ROLLED_BACK
      };
    },
    run: function run(query, parameters, _ref4) {
      var connectionHolder = _ref4.connectionHolder,
          onError = _ref4.onError,
          onComplete = _ref4.onComplete,
          onConnection = _ref4.onConnection,
          reactive = _ref4.reactive,
          fetchSize = _ref4.fetchSize;
      // RUN in explicit transaction can't contain bookmarks and transaction configuration
      // No need to include mode and database name as it shall be inclued in begin
      var observerPromise = connectionHolder.getConnection().then(function (conn) {
        onConnection();
        return conn.protocol().run(query, parameters, {
          bookmark: _bookmark["default"].empty(),
          txConfig: _txConfig["default"].empty(),
          beforeError: onError,
          afterComplete: onComplete,
          reactive: reactive,
          fetchSize: fetchSize
        });
      })["catch"](function (error) {
        return new _streamObservers.FailedObserver({
          error: error,
          onError: onError
        });
      });
      return newCompletedResult(observerPromise, query, parameters, connectionHolder);
    }
  },
  // An error has occurred, transaction can no longer be used and no more messages will
  // be sent for this transaction.
  FAILED: {
    commit: function commit(_ref5) {
      var connectionHolder = _ref5.connectionHolder,
          onError = _ref5.onError,
          onComplete = _ref5.onComplete;
      return {
        result: newCompletedResult(new _streamObservers.FailedObserver({
          error: (0, _error.newError)('Cannot commit this transaction, because it has been rolled back either because of an error or explicit termination.'),
          onError: onError
        }), 'COMMIT', {}, connectionHolder),
        state: _states.FAILED
      };
    },
    rollback: function rollback(_ref6) {
      var connectionHolder = _ref6.connectionHolder,
          onError = _ref6.onError,
          onComplete = _ref6.onComplete;
      return {
        result: newCompletedResult(new _streamObservers.CompletedObserver(), 'ROLLBACK', {}, connectionHolder),
        state: _states.FAILED
      };
    },
    run: function run(query, parameters, _ref7) {
      var connectionHolder = _ref7.connectionHolder,
          onError = _ref7.onError,
          onComplete = _ref7.onComplete;
      return newCompletedResult(new _streamObservers.FailedObserver({
        error: (0, _error.newError)('Cannot run query in this transaction, because it has been rolled back either because of an error or explicit termination.'),
        onError: onError
      }), query, parameters, connectionHolder);
    }
  },
  // This transaction has successfully committed
  SUCCEEDED: {
    commit: function commit(_ref8) {
      var connectionHolder = _ref8.connectionHolder,
          onError = _ref8.onError,
          onComplete = _ref8.onComplete;
      return {
        result: newCompletedResult(new _streamObservers.FailedObserver({
          error: (0, _error.newError)('Cannot commit this transaction, because it has already been committed.'),
          onError: onError
        }), 'COMMIT', {}),
        state: _states.SUCCEEDED,
        connectionHolder: connectionHolder
      };
    },
    rollback: function rollback(_ref9) {
      var connectionHolder = _ref9.connectionHolder,
          onError = _ref9.onError,
          onComplete = _ref9.onComplete;
      return {
        result: newCompletedResult(new _streamObservers.FailedObserver({
          error: (0, _error.newError)('Cannot rollback this transaction, because it has already been committed.'),
          onError: onError
        }), 'ROLLBACK', {}),
        state: _states.SUCCEEDED,
        connectionHolder: connectionHolder
      };
    },
    run: function run(query, parameters, _ref10) {
      var connectionHolder = _ref10.connectionHolder,
          onError = _ref10.onError,
          onComplete = _ref10.onComplete;
      return newCompletedResult(new _streamObservers.FailedObserver({
        error: (0, _error.newError)('Cannot run query in this transaction, because it has already been committed.'),
        onError: onError
      }), query, parameters, connectionHolder);
    }
  },
  // This transaction has been rolled back
  ROLLED_BACK: {
    commit: function commit(_ref11) {
      var connectionHolder = _ref11.connectionHolder,
          onError = _ref11.onError,
          onComplete = _ref11.onComplete;
      return {
        result: newCompletedResult(new _streamObservers.FailedObserver({
          error: (0, _error.newError)('Cannot commit this transaction, because it has already been rolled back.'),
          onError: onError
        }), 'COMMIT', {}, connectionHolder),
        state: _states.ROLLED_BACK
      };
    },
    rollback: function rollback(_ref12) {
      var connectionHolder = _ref12.connectionHolder,
          onError = _ref12.onError,
          onComplete = _ref12.onComplete;
      return {
        result: newCompletedResult(new _streamObservers.FailedObserver({
          error: (0, _error.newError)('Cannot rollback this transaction, because it has already been rolled back.')
        }), 'ROLLBACK', {}, connectionHolder),
        state: _states.ROLLED_BACK
      };
    },
    run: function run(query, parameters, _ref13) {
      var connectionHolder = _ref13.connectionHolder,
          onError = _ref13.onError,
          onComplete = _ref13.onComplete;
      return newCompletedResult(new _streamObservers.FailedObserver({
        error: (0, _error.newError)('Cannot run query in this transaction, because it has already been rolled back.'),
        onError: onError
      }), query, parameters, connectionHolder);
    }
  }
  /**
   *
   * @param {boolean} commit
   * @param {ConnectionHolder} connectionHolder
   * @param {function(err:Error): any} onError
   * @param {function(metadata:object): any} onComplete
   * @param {function() : any} onConnection
   * @param {list<Result>>}pendingResults all run results in this transaction
   */

};

function finishTransaction(commit, connectionHolder, onError, onComplete, onConnection, pendingResults) {
  var observerPromise = connectionHolder.getConnection().then(function (connection) {
    onConnection();
    pendingResults.forEach(function (r) {
      return r._cancel();
    });
    return Promise.all(pendingResults).then(function (results) {
      if (commit) {
        return connection.protocol().commitTransaction({
          beforeError: onError,
          afterComplete: onComplete
        });
      } else {
        return connection.protocol().rollbackTransaction({
          beforeError: onError,
          afterComplete: onComplete
        });
      }
    });
  })["catch"](function (error) {
    return new _streamObservers.FailedObserver({
      error: error,
      onError: onError
    });
  }); // for commit & rollback we need result that uses real connection holder and notifies it when
  // connection is not needed and can be safely released to the pool

  return new _result["default"](observerPromise, commit ? 'COMMIT' : 'ROLLBACK', {}, connectionHolder);
}
/**
 * Creates a {@link Result} with empty connection holder.
 * For cases when result represents an intermediate or failed action, does not require any metadata and does not
 * need to influence real connection holder to release connections.
 * @param {ResultStreamObserver} observer - an observer for the created result.
 * @param {string} query - the cypher query that produced the result.
 * @param {Object} parameters - the parameters for cypher query that produced the result.
 * @param {ConnectionHolder} connectionHolder - the connection holder used to get the result
 * @return {Result} new result.
 * @private
 */


function newCompletedResult(observerPromise, query, parameters) {
  var connectionHolder = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _connectionHolder.EMPTY_CONNECTION_HOLDER;
  return new _result["default"](Promise.resolve(observerPromise), query, parameters, new _connectionHolderReadonly["default"](connectionHolder || _connectionHolder.EMPTY_CONNECTION_HOLDER));
}

var _default = Transaction;
exports["default"] = _default;

},{"./error":231,"./internal/bookmark":242,"./internal/connection-holder":256,"./internal/connection-holder-readonly":255,"./internal/stream-observers":283,"./internal/tx-config":286,"./internal/util":288,"./result":292,"@babel/runtime/helpers/classCallCheck":5,"@babel/runtime/helpers/createClass":7,"@babel/runtime/helpers/interopRequireDefault":12,"@babel/runtime/helpers/interopRequireWildcard":13}],300:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

/**
 * Copyright (c) 2002-2020 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// DO NOT CHANGE THE VERSION BELOW HERE
// This is set by the build system at release time, using
//
// gulp set --x <releaseversion>
//
// This is set up this way to keep the version in the code in
// sync with the npm package version, and to allow the build
// system to control version names at packaging time.
var _default = '4.2.2';
exports["default"] = _default;

},{}]},{},[233])(233)
});
